<!DOCTYPE html>
<html>
<head>
  <title>Replay Map - Headway Guard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <style>
    @font-face {
      font-family: 'FGDC';
      src: url('FGDC.ttf') format('truetype');
    }
    html, body { height: 100%; margin: 0; font-family: 'FGDC', sans-serif; }
    #map { height: calc(100% - 90px); width: 100%; }
    #controls { position: fixed; bottom: 0; left: 0; width: 100%; height: 90px; background: rgba(255,255,255,0.9); display: flex; flex-wrap: wrap; align-items: center; padding: 5px; box-sizing: border-box; }
    #controls > * { margin: 2px; }
    #controls input, #controls button {
      padding: 6px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid #ccc;
    }
    #timeline { flex: 1; margin: 0 10px; }
    .play-icons { letter-spacing: -4px; }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="controls">
    <input id="datePicker" placeholder="Date">
    <input id="startTime" placeholder="Start time">
    <input id="endTime" placeholder="End time">
    <button id="loadRangeBtn">Load</button>
    <button id="playPauseBtn">&#9654;</button>
    <button id="ff2Btn"><span class="play-icons">&#9654;&#9654;</span></button>
    <button id="ff4Btn"><span class="play-icons">&#9654;&#9654;&#9654;&#9654;</span></button>
    <input type="range" id="timeline" min="0" value="0">
    <span id="timeLabel"></span>
  </div>
  <script>
    let map = L.map('map', { zoomControl: false }).setView([38.03799212281404, -78.50981502838886], 15);
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    flatpickr("#datePicker", {
      dateFormat: "Y-m-d",
      defaultDate: new Date().toISOString().slice(0,10)
    });
    flatpickr("#startTime", {
      enableTime: true,
      noCalendar: true,
      dateFormat: "H:i",
      time_24hr: true,
      defaultDate: "00:00"
    });
    flatpickr("#endTime", {
      enableTime: true,
      noCalendar: true,
      dateFormat: "H:i",
      time_24hr: true,
      defaultDate: "23:59"
    });

    let logData = [];
    let playbackData = [];
    let markers = {};
    let nameMarkers = {};
    let timer = null;       // handle for scheduled frame advance
    let playbackSpeed = 1;  // 1x, 2x, 4x
    let routeColors = {};
    let isPlaying = false;
    const playPauseBtn = document.getElementById('playPauseBtn');

    function fetchRouteColors() {
      const routesApiUrl = "https://uva.transloc.com/Services/JSONPRelay.svc/GetRoutes?APIKey=8882812681";
      return fetch(routesApiUrl)
        .then(r => r.json())
        .then(data => { if (Array.isArray(data)) data.forEach(route => { routeColors[route.RouteID] = route.MapLineColor; }); });
    }

    function getContrastColor(hexColor) {
      hexColor = hexColor.replace('#', '');
      const r = parseInt(hexColor.substring(0,2), 16);
      const g = parseInt(hexColor.substring(2,4), 16);
      const b = parseInt(hexColor.substring(4,6), 16);
      const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
      return luminance > 0.5 ? '#000000' : '#FFFFFF';
    }

    function loadLog(retryDelay = 2000) {
      // Use absolute path so this works regardless of the current URL
      fetch('/vehicle_log.jsonl', { cache: 'no-store' })
        .then(r => (r.ok ? r.text() : ''))
        .then(text => {
          if (!text.trim()) {
            setTimeout(() => loadLog(retryDelay), retryDelay);
            return;
          }
          logData = text.trim().split('\n').map(line => JSON.parse(line));
          const hasData = logData.some(e => e.ts && (e.vehicles || []).length);
          if (!hasData) {
            setTimeout(() => loadLog(retryDelay), retryDelay);
            return;
          }
          playbackData = logData;
          const timeline = document.getElementById('timeline');
          timeline.max = playbackData.length - 1;
          const datePicker = document.getElementById('datePicker')._flatpickr;
          const first = playbackData[0] && new Date(playbackData[0].ts);
          if (first) { datePicker.setDate(first, true); }
          showFrame(0);
        })
        .catch(err => {
          console.error('Failed to load vehicle log', err);
          setTimeout(() => loadLog(retryDelay), retryDelay);
        });
    }

    function clearMarkers() {
      for (let id in markers) { map.removeLayer(markers[id]); }
      markers = {};
      for (let id in nameMarkers) { map.removeLayer(nameMarkers[id]); }
      nameMarkers = {};
    }

    function showFrame(i) {
      if (!playbackData[i]) return;
      const entry = playbackData[i];
      const timeline = document.getElementById('timeline');
      const date = new Date(entry.ts);
      const formatted = date.toLocaleString();
      timeline.value = i;
      timeline.title = formatted; // show date/time when hovering the slider
      document.getElementById('timeLabel').textContent = formatted;
      clearMarkers();
      entry.vehicles.forEach(vehicle => {
        const routeID = vehicle.RouteID || 0;
        const pos = [vehicle.Latitude, vehicle.Longitude];
        const isMoving = vehicle.GroundSpeed > 0;
        const heading = vehicle.Heading;
        const routeColor = routeColors[routeID] || '#000000';
        const svgIcon = `
          <svg width="40" height="80" viewBox="0 0 40 80" xmlns="http://www.w3.org/2000/svg">
            <g>
              <circle cx="20" cy="20" r="15" fill="${routeColor}" stroke="white" stroke-width="3" />
              ${isMoving ? `
                <line x1="20" y1="10" x2="20" y2="22" stroke="white" stroke-width="4" stroke-linecap="round" style="transform: rotate(${heading + 180}deg); transform-origin: 20px 20px" />
                <polygon points="15,22 25,22 20,30" fill="white" style="transform: rotate(${heading + 180}deg); transform-origin: 20px 20px" />
              ` : `
                <rect x="14" y="14" width="12" height="12" fill="white" />
              `}
            </g>
          </svg>`;
        const busIcon = L.divIcon({ html: svgIcon, className: '', iconSize: [40,40], iconAnchor: [20,20] });
        const marker = L.marker(pos, { icon: busIcon }).addTo(map);
        markers[vehicle.VehicleID] = marker;

        const busName = vehicle.Name ? vehicle.Name.slice(0, -2) : '';
        if (busName) {
          const bubbleWidth = Math.max(40, busName.length * 10);
          const nameBubble = `
            <svg width="${bubbleWidth}" height="30" viewBox="0 0 ${bubbleWidth} 30" xmlns="http://www.w3.org/2000/svg">
              <g>
                <rect x="0" y="5" width="${bubbleWidth}" height="20" rx="10" ry="10" fill="${routeColor}" stroke="white" stroke-width="3" />
                <text x="${bubbleWidth / 2}" y="20" font-size="14" font-weight="bold" text-anchor="middle" fill="${getContrastColor(routeColor)}" font-family="FGDC">${busName}</text>
              </g>
            </svg>`;
          const nameIcon = L.divIcon({ html: nameBubble, className: '', iconSize: [bubbleWidth,30], iconAnchor: [bubbleWidth/2,40] });
          const nameMarker = L.marker(pos, { icon: nameIcon, interactive: false }).addTo(map);
          nameMarkers[vehicle.VehicleID] = nameMarker;
        }
      });
    }

    function scheduleNext() {
      const timeline = document.getElementById('timeline');
      const current = parseInt(timeline.value);
      const next = current + 1;
      if (next >= playbackData.length) { pause(); return; }
      const delta = new Date(playbackData[next].ts) - new Date(playbackData[current].ts);
      timer = setTimeout(() => {
        showFrame(next);
        scheduleNext();
      }, delta / playbackSpeed);
    }

    function play() {
      pause();
      isPlaying = true;
      playPauseBtn.innerHTML = '&#10074;&#10074;';
      scheduleNext();
    }

    function pause() {
      if (timer) clearTimeout(timer);
      timer = null;
      if (isPlaying) {
        isPlaying = false;
        playPauseBtn.innerHTML = '&#9654;';
      }
    }

    function applyRange() {
      if (!logData.length) return;
      const dateStr = document.getElementById('datePicker').value;
      const startStr = document.getElementById('startTime').value || '00:00';
      const endStr = document.getElementById('endTime').value || '23:59';
      const start = new Date(`${dateStr}T${startStr}:00`);
      const end = new Date(`${dateStr}T${endStr}:00`);
      playbackData = logData.filter(entry => {
        const ts = new Date(entry.ts);
        return ts >= start && ts <= end;
      });
      const timeline = document.getElementById('timeline');
      timeline.max = playbackData.length ? playbackData.length - 1 : 0;
      showFrame(0);
    }

    playPauseBtn.onclick = () => {
      if (isPlaying) { pause(); }
      else { playbackSpeed = 1; play(); }
    };
    document.getElementById('ff2Btn').onclick = () => { playbackSpeed = 2; play(); };
    document.getElementById('ff4Btn').onclick = () => { playbackSpeed = 4; play(); };
    document.getElementById('timeline').addEventListener('input', e => { pause(); showFrame(parseInt(e.target.value)); });
    document.getElementById('loadRangeBtn').onclick = () => { pause(); applyRange(); };

    fetchRouteColors().then(loadLog);
  </script>
</body>
</html>
