<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>UTS Metro-Style Schematic</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root {
            color-scheme: light;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: "Inter", "Segoe UI", "Helvetica Neue", Arial, sans-serif;
            background: #ffffff;
            color: #111111;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        h1 {
            font-weight: 600;
            margin: 0;
            font-size: clamp(1.5rem, 1.2rem + 1vw, 2.2rem);
        }

        main {
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            padding: 1.25rem clamp(1rem, 4vw, 3rem) 2rem;
            gap: 1.5rem;
        }

        .map-wrapper {
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            min-height: 60vh;
        }

        .map-container {
            position: relative;
            flex: 1 1 auto;
            min-height: 50vh;
            border: 1px solid #d0d0d0;
            border-radius: 0.75rem;
            overflow: hidden;
            background: #ffffff;
            box-shadow: 0 10px 35px rgba(17, 17, 17, 0.08);
        }

        #schematic {
            width: 100%;
            height: 100%;
            display: block;
            cursor: grab;
            touch-action: none;
        }

        #schematic:active {
            cursor: grabbing;
        }

        .legend {
            border: 1px solid #d0d0d0;
            border-radius: 0.75rem;
            padding: 1rem 1.25rem;
            box-shadow: 0 6px 25px rgba(17, 17, 17, 0.07);
            background: #ffffff;
        }

        .legend h2 {
            margin: 0 0 0.75rem;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .legend ul {
            list-style: none;
            margin: 0;
            padding: 0;
            display: grid;
            gap: 0.5rem 1.25rem;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        }

        .legend li {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 0.95rem;
            cursor: pointer;
            padding: 0.25rem 0.4rem;
            border-radius: 0.5rem;
            transition: background 0.2s ease;
        }

        .legend li:focus-visible {
            outline: 2px solid #111111;
            outline-offset: 2px;
        }

        .legend li:hover {
            background: rgba(0, 0, 0, 0.05);
        }

        .legend .swatch {
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 50%;
            flex: none;
            border: 1px solid rgba(0, 0, 0, 0.2);
        }

        .tooltip {
            position: absolute;
            pointer-events: none;
            background: rgba(255, 255, 255, 0.95);
            color: #111111;
            border: 1px solid rgba(0, 0, 0, 0.15);
            border-radius: 0.5rem;
            padding: 0.6rem 0.75rem;
            box-shadow: 0 12px 30px rgba(17, 17, 17, 0.25);
            font-size: 0.85rem;
            line-height: 1.35;
            transform: translate(-50%, -110%);
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        .tooltip.visible {
            opacity: 1;
        }

        .tooltip .title {
            font-weight: 600;
            margin-bottom: 0.35rem;
        }

        .legend li.is-highlight,
        .legend li.is-highlight:hover {
            background: rgba(0, 0, 0, 0.08);
        }

        .legend li.is-dim {
            opacity: 0.35;
        }

        .route-path {
            fill: none;
            stroke-linecap: round;
            stroke-linejoin: round;
            pointer-events: stroke;
            transition: opacity 0.2s ease;
        }

        .route-path.is-highlight {
            opacity: 1;
        }

        .route-path.is-dim {
            opacity: 0.25;
        }

        .stops circle {
            fill: #ffffff;
            stroke: #111111;
            vector-effect: non-scaling-stroke;
            transition: opacity 0.2s ease;
        }

        .stops circle.is-highlight {
            opacity: 1;
        }

        .stops circle.is-dim {
            opacity: 0.35;
        }

        .termini path {
            fill: none;
            stroke-linecap: round;
            vector-effect: non-scaling-stroke;
        }

        @media (min-width: 960px) {
            .map-wrapper {
                flex-direction: row;
                align-items: stretch;
            }

            .legend {
                width: min(320px, 30%);
                flex: none;
            }
        }
    </style>
</head>
<body>
    <main>
        <header>
            <h1>University Transit Service Schematic</h1>
            <p style="margin: 0.35rem 0 0; max-width: 720px; line-height: 1.5;">
                A DC Metroâ€“style octilinear rendering of Charlottesville's University Transit Service lines. Pan or scroll to explore; hover over a colored line segment to highlight a route, and hover over a stop to see its name and serving routes.
            </p>
        </header>
        <section class="map-wrapper">
            <div class="map-container">
                <svg id="schematic" role="img" aria-label="UTS transit schematic" xmlns="http://www.w3.org/2000/svg">
                    <g class="bundles"></g>
                    <g class="termini"></g>
                    <g class="stops"></g>
                </svg>
                <div class="tooltip" id="tooltip" role="tooltip" aria-hidden="true"></div>
            </div>
            <aside class="legend" aria-label="Route legend">
                <h2>Routes</h2>
                <ul id="legend-list"></ul>
            </aside>
        </section>
    </main>
    <script type="module">
        const TRANSLOC_BASE = 'https://uva.transloc.com/Services/JSONPRelay.svc';
        const TRANSLOC_API_KEY = '8882812681';

        const ROUTE_POLYLINE_URL = `${TRANSLOC_BASE}/GetRoutesForMapWithScheduleWithEncodedLine?APIKey=${TRANSLOC_API_KEY}`;
        const ROUTE_INFO_URL = `${TRANSLOC_BASE}/GetRoutes?APIKey=${TRANSLOC_API_KEY}`;

        const ROUTE_DATA_SOURCES = [
            ROUTE_POLYLINE_URL,
            'GetRoutesForMapWithScheduleWithEncodedLine.txt'
        ];
        const ROUTE_INFO_SOURCES = [
            ROUTE_POLYLINE_URL,
            ROUTE_INFO_URL,
            'GetRoutes.txt'
        ];

        const VEHICLE_POINTS_URL = `${TRANSLOC_BASE}/GetMapVehiclePoints?APIKey=${TRANSLOC_API_KEY}&returnVehiclesNotAssignedToRoute=true`;
        const VEHICLE_POINTS_SOURCES = [
            VEHICLE_POINTS_URL,
            'GetMapVehiclePoints.txt'
        ];

        const SIMPLIFY_TOLERANCE_METERS = 12;
        const DENSIFY_SPACING_METERS = 7;
        const CORRIDOR_ANGULAR_TOLERANCE_DEG = 3;
        const CORRIDOR_ANGULAR_TOLERANCE_RAD = (CORRIDOR_ANGULAR_TOLERANCE_DEG * Math.PI) / 180;
        const CORRIDOR_DISTANCE_TOLERANCE_METERS = 5;
        const CORRIDOR_OVERLAP_THRESHOLD = 0.7;
        const SEGMENT_INDEX_CELL_SIZE = 150;
        const NODE_QUANTIZATION_METERS = 10;
        const NODE_MERGE_DISTANCE = 18;
        const STOP_GROUP_DISTANCE = 10;
        const MIN_DIAGONAL_LENGTH = 40;
        const POLYLINE_DUPLICATE_TOLERANCE = 10;

        const GRAPH_SIMPLIFY_TOLERANCE_METERS = 30;
        const GRAPH_VERTEX_SPACING_METERS = 25;
        const GRAPH_COLLINEAR_ANGLE_DEG = 5;
        const GRAPH_COLLINEAR_ANGLE_RAD = (GRAPH_COLLINEAR_ANGLE_DEG * Math.PI) / 180;
        const GRAPH_MIN_EDGE_LENGTH = 50;
        const DEGREE2_MERGE_ANGLE_DEG = 3;
        const DEGREE2_MERGE_ANGLE_RAD = (DEGREE2_MERGE_ANGLE_DEG * Math.PI) / 180;
        const SNAP_MIN_SEGMENT_LENGTH = 35;

        const ROUTE_LINE_WIDTH_PX = 6;
        const ROUTE_GAP_PX = 2;
        const STOP_RADIUS_PX = 6;
        const STOP_STROKE_PX = 3;
        const TERMINUS_TICK_PX = 12;

        const svgNS = 'http://www.w3.org/2000/svg';

        const state = {
            routes: [],
            routeMeta: new Map(),
            componentToGroup: new Map(),
            graph: null,
            stopGroups: [],
            viewBox: null,
            baseViewBox: null,
            bundleChains: [],
            routePaths: [],
            routePathLookup: new Map(),
            stopElements: [],
            terminusElements: [],
            activeHighlightKey: null,
            scaleUpdatePending: false
        };

        async function initialize() {
            try {
                const { routes, stopGroups, componentToGroup } = await loadData();
                state.routes = routes;
                state.stopGroups = stopGroups;
                state.componentToGroup = componentToGroup;

                state.graph = buildGraph(routes);
                normalizeGraphRouteMembership(state.graph);
                snapOctilinear(state.graph);
                state.bundleChains = buildBundleChains(state.graph);
                cleanChainIntersections(state.graph, state.bundleChains);
                alignStopsToChains(state.stopGroups, state.bundleChains);

                render();
            } catch (error) {
                console.error(error);
                showError(error.message || 'Failed to render schematic.');
            }
        }

        function showError(message) {
            const container = document.querySelector('.map-container');
            const notice = document.createElement('div');
            notice.style.position = 'absolute';
            notice.style.inset = '1.5rem';
            notice.style.background = 'rgba(255,255,255,0.92)';
            notice.style.border = '1px solid rgba(0,0,0,0.15)';
            notice.style.borderRadius = '0.75rem';
            notice.style.display = 'flex';
            notice.style.alignItems = 'center';
            notice.style.justifyContent = 'center';
            notice.style.fontSize = '1rem';
            notice.style.textAlign = 'center';
            notice.textContent = message;
            container.appendChild(notice);
        }

        async function fetchJsonWithFallback(urls) {
            let lastError = null;
            for (const url of urls) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        lastError = new Error(`HTTP ${response.status} fetching ${url}`);
                        continue;
                    }
                    const data = await response.json();
                    return { data, url };
                } catch (error) {
                    lastError = error;
                }
            }
            throw lastError ?? new Error('Unable to load transit datasets.');
        }

        function normalizeRoutePayload(payload) {
            if (Array.isArray(payload)) {
                return payload;
            }
            if (payload && Array.isArray(payload.d)) {
                return payload.d;
            }
            return [];
        }

        function normalizeVehiclePayload(payload) {
            if (Array.isArray(payload)) {
                return payload;
            }
            if (payload && Array.isArray(payload.d)) {
                return payload.d;
            }
            if (payload && Array.isArray(payload.Vehicles)) {
                return payload.Vehicles;
            }
            return [];
        }

        function normalizeRouteDisplayName(name) {
            if (typeof name !== 'string') {
                return 'Route';
            }
            const stripped = name
                .replace(/\b(AM|PM|Inbound|Outbound|Clockwise|Counterclockwise|CW|CCW|Northbound|Southbound|Eastbound|Westbound)\b/gi, '')
                .replace(/\s+/g, ' ')
                .trim();
            const fallback = name.trim();
            return stripped || fallback || 'Route';
        }

        function computeRouteGroupKey(name, color) {
            const normalizedName = normalizeRouteDisplayName(name).toLowerCase();
            const normalizedColor = normalizeColor(color).toLowerCase();
            return `${normalizedName}|${normalizedColor}`;
        }

        async function fetchActiveRouteIds() {
            try {
                const { data } = await fetchJsonWithFallback(VEHICLE_POINTS_SOURCES);
                const vehicles = normalizeVehiclePayload(data);
                const active = new Set();
                for (const vehicle of vehicles) {
                    const rawRouteId = vehicle?.RouteID ?? vehicle?.RouteId ?? vehicle?.routeId ?? vehicle?.Route;
                    const numericRouteId = Number(rawRouteId);
                    if (Number.isFinite(numericRouteId) && numericRouteId > 0) {
                        active.add(numericRouteId);
                    }
                }
                return active;
            } catch (error) {
                console.warn('Failed to load vehicle assignments', error);
                return new Set();
            }
        }

        async function loadData() {
            const activeRouteIds = await fetchActiveRouteIds();
            if (!activeRouteIds.size) {
                throw new Error('No routes currently have vehicles assigned or vehicle data is unavailable.');
            }

            const { data: polylinePayload, url: polylineSource } = await fetchJsonWithFallback(ROUTE_DATA_SOURCES);
            const polylineJson = normalizeRoutePayload(polylinePayload);

            if (!polylineJson.length) {
                throw new Error('No route geometry returned by the feed.');
            }

            let routeInfoJson;
            if (polylineSource === ROUTE_INFO_SOURCES[0]) {
                routeInfoJson = polylineJson;
            } else {
                const { data: infoPayload } = await fetchJsonWithFallback(ROUTE_INFO_SOURCES);
                routeInfoJson = normalizeRoutePayload(infoPayload);
            }

            const routeInfoMap = new Map(routeInfoJson.map((item) => [item.RouteID, item]));

            const allLatLngs = [];
            const rawRoutes = [];

            for (const route of polylineJson) {
                const numericRouteId = Number(route.RouteID);
                if (!Number.isFinite(numericRouteId) || !activeRouteIds.has(numericRouteId)) {
                    continue;
                }

                const routeInfo = routeInfoMap.get(route.RouteID);
                const hideLine = route.HideRouteLine ?? routeInfo?.HideRouteLine ?? false;
                const isVisible = (route.IsVisibleOnMap ?? routeInfo?.IsVisibleOnMap ?? true) && !hideLine;

                if (!isVisible || !route.EncodedPolyline) {
                    continue;
                }

                let decoded;
                try {
                    decoded = decodePolyline(route.EncodedPolyline);
                } catch (err) {
                    console.warn('Failed to decode polyline for route', route.RouteID, err);
                    continue;
                }

                if (decoded.length < 2) {
                    continue;
                }

                decoded.forEach(([lat, lon]) => allLatLngs.push({ lat, lon }));

                const routeStops = Array.isArray(route.Stops)
                    ? route.Stops.filter((stop) => isFinite(stop.Latitude) && isFinite(stop.Longitude))
                    : [];

                const baseName = (routeInfo?.Description || route.Description || `Route ${route.RouteID}`).trim();
                const color = normalizeColor(routeInfo?.MapLineColor || route.MapLineColor || '#000000');
                const displayName = normalizeRouteDisplayName(baseName);
                const groupKey = computeRouteGroupKey(baseName, color);

                rawRoutes.push({
                    routeId: numericRouteId,
                    name: displayName,
                    color,
                    groupKey,
                    decoded,
                    rawStops: routeStops.map((stop) => ({
                        id: stop.RouteStopID ?? `${route.RouteID}-${stop.AddressID ?? stop.GtfsId ?? stop.Description}`,
                        name: (stop.Description || stop.Line1 || stop.Line2 || 'Stop').trim(),
                        lat: stop.Latitude,
                        lon: stop.Longitude
                    }))
                });

                routeStops.forEach((stop) => {
                    if (isFinite(stop.Latitude) && isFinite(stop.Longitude)) {
                        allLatLngs.push({ lat: stop.Latitude, lon: stop.Longitude });
                    }
                });
            }

            if (!rawRoutes.length) {
                throw new Error('No active routes returned by the feed.');
            }

            const { centerLat, centerLon } = computeGeographicCenter(allLatLngs);
            const projection = createProjection(centerLat, centerLon);

            const routeGroups = new Map();

            rawRoutes.forEach((route) => {
                const projectedPoints = route.decoded.map(([lat, lon]) => projection.toPoint(lat, lon));
                const cleanedPoints = removeDuplicatePoints(projectedPoints);
                const simplified = simplifyPath(cleanedPoints, SIMPLIFY_TOLERANCE_METERS);
                const densified = densifyPath(simplified, DENSIFY_SPACING_METERS);

                if (!densified || densified.length < 2) {
                    return;
                }

                const projectedStops = route.rawStops.map((stop) => ({
                    id: stop.id,
                    name: stop.name,
                    lat: stop.lat,
                    lon: stop.lon,
                    routeId: route.groupKey,
                    position: projection.toPoint(stop.lat, stop.lon)
                }));

                let group = routeGroups.get(route.groupKey);
                if (!group) {
                    group = {
                        id: route.groupKey,
                        name: route.name,
                        color: route.color,
                        segments: [],
                        candidateSegments: [],
                        corridors: [],
                        stops: [],
                        componentRouteIds: new Set()
                    };
                    routeGroups.set(route.groupKey, group);
                }

                const segmentDescriptor = createSegmentDescriptor(simplified, densified, route.routeId);
                group.candidateSegments.push(segmentDescriptor);
                projectedStops.forEach((stop) => group.stops.push(stop));
                group.componentRouteIds.add(route.routeId);
            });

            for (const group of routeGroups.values()) {
                if (group.candidateSegments.length) {
                    const corridors = clusterSegmentsIntoCorridors(group.candidateSegments);
                    const graphSegments = [];
                    corridors.forEach((corridor) => {
                        const prepared = prepareCenterlineForGraph(corridor.centerline);
                        corridor.centerlineForGraph = prepared;
                        graphSegments.push(prepared.map(clonePoint));
                    });
                    group.corridors = corridors;
                    group.segments = corridors.map((corridor) => corridor.centerline.map(clonePoint));
                    group.graphSegments = graphSegments;
                } else {
                    group.corridors = [];
                    group.segments = [];
                    group.graphSegments = [];
                }

                if (group.stops.length && group.segments.length) {
                    snapStopsToCorridors(group.stops, group.segments);
                }
            }

            const aggregatedRoutes = Array.from(routeGroups.values()).map((group) => ({
                id: group.id,
                name: group.name,
                color: group.color,
                segments: (group.graphSegments && group.graphSegments.length)
                    ? group.graphSegments.map((segment) => segment.map(clonePoint))
                    : group.segments.map((segment) => segment.map(clonePoint)),
                stops: group.stops,
                componentRouteIds: Array.from(group.componentRouteIds).sort((a, b) => a - b),
                corridorMembers: group.corridors.map((corridor) => Array.from(corridor.memberRouteIds).sort((a, b) => a - b))
            }));

            if (!aggregatedRoutes.length) {
                throw new Error('No active routes with geometry available.');
            }

            const componentToGroup = new Map();
            aggregatedRoutes.forEach((route) => {
                const groupKey = String(route.id);
                componentToGroup.set(groupKey, groupKey);
                route.componentRouteIds.forEach((componentId) => {
                    const key = String(componentId);
                    if (!componentToGroup.has(key)) {
                        componentToGroup.set(key, groupKey);
                    }
                });
            });

            state.routeMeta = new Map(
                aggregatedRoutes.map((route) => {
                    const key = String(route.id);
                    return [
                        key,
                        {
                            id: key,
                            name: route.name,
                            color: route.color,
                            componentRouteIds: route.componentRouteIds,
                            groupKey: key
                        }
                    ];
                })
            );

            const groupedStops = groupStops(aggregatedRoutes.flatMap((route) => route.stops));

            return { routes: aggregatedRoutes, stopGroups: groupedStops, componentToGroup };
        }

        function normalizeColor(color) {
            if (typeof color !== 'string') {
                return '#000000';
            }
            const trimmed = color.trim();
            if (/^#([0-9a-fA-F]{3}){1,2}$/.test(trimmed)) {
                return trimmed;
            }
            return '#000000';
        }

        function computeGeographicCenter(points) {
            if (!points.length) {
                return { centerLat: 0, centerLon: 0 };
            }
            let sumLat = 0;
            let sumLon = 0;
            for (const point of points) {
                sumLat += point.lat;
                sumLon += point.lon;
            }
            return {
                centerLat: sumLat / points.length,
                centerLon: sumLon / points.length
            };
        }

        function createProjection(lat, lon) {
            const origin = projectMercator(lat, lon);
            return {
                toPoint(latitude, longitude) {
                    const projected = projectMercator(latitude, longitude);
                    return {
                        x: projected.x - origin.x,
                        y: origin.y - projected.y
                    };
                }
            };
        }

        function projectMercator(lat, lon) {
            const radLat = (lat * Math.PI) / 180;
            const radLon = (lon * Math.PI) / 180;
            const R = 6378137;
            return {
                x: R * radLon,
                y: R * Math.log(Math.tan(Math.PI / 4 + radLat / 2))
            };
        }

        function decodePolyline(str) {
            let index = 0;
            const len = str.length;
            let lat = 0;
            let lon = 0;
            const coordinates = [];

            while (index < len) {
                let result = 0;
                let shift = 0;
                let b;
                do {
                    if (index >= len) {
                        throw new Error('Invalid polyline encoding');
                    }
                    b = str.charCodeAt(index++) - 63;
                    result |= (b & 0x1f) << shift;
                    shift += 5;
                } while (b >= 0x20);
                const deltaLat = (result & 1) ? ~(result >> 1) : (result >> 1);
                lat += deltaLat;

                result = 0;
                shift = 0;
                do {
                    if (index >= len) {
                        throw new Error('Invalid polyline encoding');
                    }
                    b = str.charCodeAt(index++) - 63;
                    result |= (b & 0x1f) << shift;
                    shift += 5;
                } while (b >= 0x20);
                const deltaLon = (result & 1) ? ~(result >> 1) : (result >> 1);
                lon += deltaLon;

                coordinates.push([lat * 1e-5, lon * 1e-5]);
            }

            return coordinates;
        }

        function removeDuplicatePoints(points, tolerance = 0.2) {
            if (points.length <= 1) {
                return points.map(clonePoint);
            }
            const result = [];
            const sqTol = tolerance * tolerance;
            let prev = points[0];
            result.push(clonePoint(prev));
            for (let i = 1; i < points.length; i++) {
                const point = points[i];
                if (distanceSquared(point, prev) > sqTol) {
                    result.push(clonePoint(point));
                    prev = point;
                }
            }
            return result;
        }

        function simplifyPath(points, tolerance) {
            if (points.length <= 2) {
                return points.map(clonePoint);
            }
            const sqTol = tolerance * tolerance;
            const simplified = [clonePoint(points[0])];
            simplifySegment(points, 0, points.length - 1, sqTol, simplified);
            simplified.push(clonePoint(points[points.length - 1]));
            return simplified;
        }

        function simplifySegment(points, first, last, sqTol, simplified) {
            let maxDistSq = 0;
            let index = -1;
            const a = points[first];
            const b = points[last];

            for (let i = first + 1; i < last; i++) {
                const distSq = pointToSegmentDistanceSquared(points[i], a, b);
                if (distSq > maxDistSq) {
                    index = i;
                    maxDistSq = distSq;
                }
            }

            if (maxDistSq > sqTol && index !== -1) {
                simplifySegment(points, first, index, sqTol, simplified);
                simplified.push(clonePoint(points[index]));
                simplifySegment(points, index, last, sqTol, simplified);
            }
        }

        function removeCloseVertices(points, minDistance) {
            if (!Array.isArray(points) || points.length === 0) {
                return [];
            }
            if (points.length === 1) {
                return [clonePoint(points[0])];
            }
            const minSq = minDistance * minDistance;
            const result = [clonePoint(points[0])];
            for (let i = 1; i < points.length - 1; i++) {
                const prev = result[result.length - 1];
                const current = points[i];
                if (distanceSquared(prev, current) >= minSq) {
                    result.push(clonePoint(current));
                }
            }
            result.push(clonePoint(points[points.length - 1]));
            return result;
        }

        function mergeCollinearByAngle(points, toleranceRadians) {
            if (!Array.isArray(points) || points.length <= 2) {
                return Array.isArray(points) ? points.map(clonePoint) : [];
            }
            const cleaned = [clonePoint(points[0])];
            for (let i = 1; i < points.length - 1; i++) {
                const prev = cleaned[cleaned.length - 1];
                const current = points[i];
                const next = points[i + 1];
                const v1x = current.x - prev.x;
                const v1y = current.y - prev.y;
                const v2x = next.x - current.x;
                const v2y = next.y - current.y;
                const len1 = Math.hypot(v1x, v1y);
                const len2 = Math.hypot(v2x, v2y);
                if (len1 < 1e-6 || len2 < 1e-6) {
                    continue;
                }
                const angle1 = normalizeUndirectedAngle(Math.atan2(v1y, v1x));
                const angle2 = normalizeUndirectedAngle(Math.atan2(v2y, v2x));
                const diff = angularDifferenceRadians(angle1, angle2);
                if (diff <= toleranceRadians) {
                    continue;
                }
                cleaned.push(clonePoint(current));
            }
            cleaned.push(clonePoint(points[points.length - 1]));
            return cleaned;
        }

        function prepareCenterlineForGraph(centerline) {
            if (!Array.isArray(centerline) || centerline.length < 2) {
                return Array.isArray(centerline) ? centerline.map(clonePoint) : [];
            }
            let prepared = simplifyPath(centerline, GRAPH_SIMPLIFY_TOLERANCE_METERS);
            prepared = removeCloseVertices(prepared, GRAPH_VERTEX_SPACING_METERS);
            prepared = mergeCollinearByAngle(prepared, GRAPH_COLLINEAR_ANGLE_RAD);
            if (prepared.length < 2) {
                const first = clonePoint(centerline[0]);
                const last = clonePoint(centerline[centerline.length - 1]);
                return [first, last];
            }
            return prepared.map(clonePoint);
        }

        function densifyPath(points, spacing) {
            if (!Array.isArray(points) || points.length < 2 || !isFinite(spacing) || spacing <= 0) {
                return Array.isArray(points) ? points.map(clonePoint) : [];
            }
            const densified = [clonePoint(points[0])];
            let distanceSinceLast = 0;

            for (let i = 0; i < points.length - 1; i++) {
                const start = points[i];
                const end = points[i + 1];
                const dx = end.x - start.x;
                const dy = end.y - start.y;
                const segmentLength = Math.hypot(dx, dy);
                if (segmentLength < 1e-6) {
                    continue;
                }

                let traversed = 0;
                while (distanceSinceLast + (segmentLength - traversed) >= spacing) {
                    const distanceToNext = spacing - distanceSinceLast;
                    traversed += distanceToNext;
                    const t = traversed / segmentLength;
                    densified.push({
                        x: start.x + dx * t,
                        y: start.y + dy * t
                    });
                    distanceSinceLast = 0;
                }
                distanceSinceLast += segmentLength - traversed;
            }

            const lastPoint = points[points.length - 1];
            const tail = densified[densified.length - 1];
            if (distanceSquared(tail, lastPoint) > 1e-6) {
                densified.push(clonePoint(lastPoint));
            }

            return densified;
        }

        function computeBoundingBox(points) {
            if (!Array.isArray(points) || !points.length) {
                return { minX: 0, minY: 0, maxX: 0, maxY: 0 };
            }
            let minX = points[0].x;
            let maxX = points[0].x;
            let minY = points[0].y;
            let maxY = points[0].y;
            for (let i = 1; i < points.length; i++) {
                const p = points[i];
                if (p.x < minX) minX = p.x;
                if (p.x > maxX) maxX = p.x;
                if (p.y < minY) minY = p.y;
                if (p.y > maxY) maxY = p.y;
            }
            return { minX, minY, maxX, maxY };
        }

        function expandBounds(bounds, padding) {
            if (!bounds) {
                return { minX: 0, minY: 0, maxX: 0, maxY: 0 };
            }
            return {
                minX: bounds.minX - padding,
                minY: bounds.minY - padding,
                maxX: bounds.maxX + padding,
                maxY: bounds.maxY + padding
            };
        }

        function computeSegmentDirection(points) {
            if (!Array.isArray(points) || points.length < 2) {
                return 0;
            }
            let start = points[0];
            let end = points[points.length - 1];
            let index = points.length - 1;
            while (index > 0 && distanceSquared(start, end) < 1e-6) {
                index--;
                end = points[index];
            }
            if (distanceSquared(start, end) < 1e-6) {
                return 0;
            }
            return Math.atan2(end.y - start.y, end.x - start.x);
        }

        function computePolylineSegments(points) {
            const segments = [];
            if (!Array.isArray(points) || points.length < 2) {
                return segments;
            }
            for (let i = 0; i < points.length - 1; i++) {
                const a = points[i];
                const b = points[i + 1];
                if (distanceSquared(a, b) < 1e-6) {
                    continue;
                }
                segments.push({ a, b });
            }
            return segments;
        }

        function distancePointToSegments(point, segments) {
            if (!Array.isArray(segments) || !segments.length) {
                return Infinity;
            }
            let minSq = Infinity;
            for (const segment of segments) {
                const distSq = pointToSegmentDistanceSquared(point, segment.a, segment.b);
                if (distSq < minSq) {
                    minSq = distSq;
                }
            }
            return minSq === Infinity ? Infinity : Math.sqrt(minSq);
        }

        function meanDistancePointsToSegments(points, segments) {
            if (!Array.isArray(points) || !points.length) {
                return Infinity;
            }
            if (!Array.isArray(segments) || !segments.length) {
                return Infinity;
            }
            let total = 0;
            for (const point of points) {
                total += distancePointToSegments(point, segments);
            }
            return total / points.length;
        }

        function computeOverlapFraction(points, segments, tolerance, spacing) {
            if (!Array.isArray(points) || points.length < 2) {
                return 0;
            }
            if (!Array.isArray(segments) || !segments.length) {
                return 0;
            }
            let overlapped = 0;
            let total = 0;
            for (let i = 0; i < points.length - 1; i++) {
                const a = points[i];
                const b = points[i + 1];
                const segmentLength = Math.hypot(b.x - a.x, b.y - a.y);
                if (segmentLength < 1e-6) {
                    continue;
                }
                total += segmentLength;
                const samples = Math.max(1, Math.round(segmentLength / spacing));
                const step = segmentLength / samples;
                for (let s = 0; s < samples; s++) {
                    const t = (s + 0.5) / samples;
                    const samplePoint = {
                        x: a.x + (b.x - a.x) * t,
                        y: a.y + (b.y - a.y) * t
                    };
                    const distance = distancePointToSegments(samplePoint, segments);
                    if (distance <= tolerance) {
                        overlapped += step;
                    }
                }
            }
            if (total < 1e-6) {
                return 0;
            }
            return overlapped / total;
        }

        function angularDifferenceRadians(a, b) {
            const twoPi = Math.PI * 2;
            let diff = Math.abs(a - b) % twoPi;
            if (diff > Math.PI) {
                diff = twoPi - diff;
            }
            return diff;
        }

        function hasEquivalentPolyline(existing, candidate, tolerance = POLYLINE_DUPLICATE_TOLERANCE) {
            if (!Array.isArray(existing) || !candidate) {
                return false;
            }
            for (const polyline of existing) {
                if (polylinesApproximatelyEqual(polyline, candidate, tolerance)) {
                    return true;
                }
            }
            return false;
        }

        function polylinesApproximatelyEqual(a, b, tolerance) {
            if (!Array.isArray(a) || !Array.isArray(b) || !a.length || !b.length) {
                return false;
            }
            const lengthA = computePolylineLength(a);
            const lengthB = computePolylineLength(b);
            if (!isFinite(lengthA) || !isFinite(lengthB)) {
                return false;
            }
            if (Math.abs(lengthA - lengthB) > tolerance) {
                return false;
            }
            const sampleCount = Math.max(4, Math.min(12, Math.max(a.length, b.length)));
            const samplesA = samplePolyline(a, sampleCount);
            const samplesB = samplePolyline(b, sampleCount);
            if (!samplesA.length || !samplesB.length) {
                return false;
            }
            const toleranceSq = tolerance * tolerance;

            if (maxDistanceSquaredBetweenSamples(samplesA, samplesB) <= toleranceSq) {
                return true;
            }

            const aligned = computeAverageOffset(samplesA, samplesB);
            const maxTranslation = tolerance * 4;
            if (aligned.distance <= maxTranslation) {
                const translatedDiff = maxDistanceSquaredBetweenSamples(
                    samplesA,
                    samplesB,
                    aligned.offsetX,
                    aligned.offsetY
                );
                if (translatedDiff <= toleranceSq) {
                    return true;
                }
            }

            const reversedSamplesB = samplePolyline(b.slice().reverse(), sampleCount);
            if (maxDistanceSquaredBetweenSamples(samplesA, reversedSamplesB) <= toleranceSq) {
                return true;
            }

            const reverseAligned = computeAverageOffset(samplesA, reversedSamplesB);
            if (reverseAligned.distance <= maxTranslation) {
                const translatedReverseDiff = maxDistanceSquaredBetweenSamples(
                    samplesA,
                    reversedSamplesB,
                    reverseAligned.offsetX,
                    reverseAligned.offsetY
                );
                if (translatedReverseDiff <= toleranceSq) {
                    return true;
                }
            }

            return false;
        }

        function computePolylineLength(points) {
            let total = 0;
            for (let i = 1; i < points.length; i++) {
                total += Math.hypot(points[i].x - points[i - 1].x, points[i].y - points[i - 1].y);
            }
            return total;
        }

        function samplePolyline(points, count) {
            if (!Array.isArray(points) || !points.length || count <= 0) {
                return [];
            }
            if (points.length === 1 || count === 1) {
                return [clonePoint(points[0])];
            }
            const cumulative = new Array(points.length);
            cumulative[0] = 0;
            for (let i = 1; i < points.length; i++) {
                cumulative[i] = cumulative[i - 1] + Math.hypot(points[i].x - points[i - 1].x, points[i].y - points[i - 1].y);
            }
            const total = cumulative[cumulative.length - 1];
            if (total < 1e-6) {
                return Array.from({ length: count }, () => clonePoint(points[0]));
            }
            const samples = [];
            for (let i = 0; i < count; i++) {
                const target = i === count - 1 ? total : (total * i) / (count - 1);
                samples.push(interpolateAlongPolyline(points, cumulative, target));
            }
            return samples;
        }

        function interpolateAlongPolyline(points, cumulative, target) {
            if (target <= 0) {
                return clonePoint(points[0]);
            }
            const total = cumulative[cumulative.length - 1];
            if (target >= total) {
                return clonePoint(points[points.length - 1]);
            }
            let index = 0;
            while (index < cumulative.length - 1 && cumulative[index + 1] < target) {
                index++;
            }
            const nextIndex = Math.min(index + 1, points.length - 1);
            const start = points[index];
            const end = points[nextIndex];
            const segmentStart = cumulative[index];
            const segmentEnd = cumulative[nextIndex];
            const segmentLength = Math.max(segmentEnd - segmentStart, 1e-6);
            const t = (target - segmentStart) / segmentLength;
            return {
                x: start.x + (end.x - start.x) * t,
                y: start.y + (end.y - start.y) * t
            };
        }

        function maxDistanceSquaredBetweenSamples(a, b, offsetX = 0, offsetY = 0) {
            const length = Math.min(a.length, b.length);
            let max = 0;
            for (let i = 0; i < length; i++) {
                const bx = b[i].x + offsetX;
                const by = b[i].y + offsetY;
                const dx = a[i].x - bx;
                const dy = a[i].y - by;
                const distSq = dx * dx + dy * dy;
                if (distSq > max) {
                    max = distSq;
                }
            }
            return max;
        }

        function computeAverageOffset(samplesA, samplesB) {
            const length = Math.min(samplesA.length, samplesB.length);
            if (!length) {
                return { offsetX: 0, offsetY: 0, distance: 0 };
            }
            let sumX = 0;
            let sumY = 0;
            for (let i = 0; i < length; i++) {
                sumX += samplesA[i].x - samplesB[i].x;
                sumY += samplesA[i].y - samplesB[i].y;
            }
            const offsetX = sumX / length;
            const offsetY = sumY / length;
            return {
                offsetX,
                offsetY,
                distance: Math.hypot(offsetX, offsetY)
            };
        }

        function pointToSegmentDistanceSquared(point, a, b) {
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            if (dx === 0 && dy === 0) {
                return distanceSquared(point, a);
            }
            const t = ((point.x - a.x) * dx + (point.y - a.y) * dy) / (dx * dx + dy * dy);
            const clamped = Math.max(0, Math.min(1, t));
            const proj = {
                x: a.x + clamped * dx,
                y: a.y + clamped * dy
            };
            return distanceSquared(point, proj);
        }

        function clonePoint(point) {
            return { x: point.x, y: point.y };
        }

        function distanceSquared(a, b) {
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            return dx * dx + dy * dy;
        }

        function normalizeUndirectedAngle(angle) {
            const twoPi = Math.PI * 2;
            let normalized = angle % twoPi;
            if (normalized < 0) {
                normalized += twoPi;
            }
            if (normalized >= Math.PI) {
                normalized -= Math.PI;
            }
            return normalized;
        }

        function createSegmentDescriptor(simplified, densified, sourceRouteId) {
            const forward = densified.map(clonePoint);
            const reverse = forward.slice().reverse();
            const forwardSegments = computePolylineSegments(forward);
            const reverseSegments = computePolylineSegments(reverse);
            const bounds = expandBounds(
                computeBoundingBox(forward),
                CORRIDOR_DISTANCE_TOLERANCE_METERS * 2
            );

            return {
                sourceRouteId,
                simplified: Array.isArray(simplified) ? simplified.map(clonePoint) : [],
                forward,
                reverse,
                forwardSegments,
                reverseSegments,
                forwardDirection: computeSegmentDirection(forward),
                reverseDirection: computeSegmentDirection(reverse),
                length: computePolylineLength(forward),
                bounds
            };
        }

        function evaluateSegmentOrientation(segmentA, segmentB, flipB) {
            const pointsA = segmentA.forward;
            const segmentsA = segmentA.forwardSegments;
            const angleA = segmentA.forwardDirection;
            const pointsB = flipB ? segmentB.reverse : segmentB.forward;
            const segmentsB = flipB ? segmentB.reverseSegments : segmentB.forwardSegments;
            const angleB = flipB ? segmentB.reverseDirection : segmentB.forwardDirection;

            if (!pointsA.length || !pointsB.length || !segmentsA.length || !segmentsB.length) {
                return null;
            }

            const angleDiff = angularDifferenceRadians(angleA, angleB);
            if (angleDiff > CORRIDOR_ANGULAR_TOLERANCE_RAD) {
                return null;
            }

            const meanAB = meanDistancePointsToSegments(pointsA, segmentsB);
            const meanBA = meanDistancePointsToSegments(pointsB, segmentsA);
            if (!isFinite(meanAB) || !isFinite(meanBA)) {
                return null;
            }

            const meanDistance = (meanAB + meanBA) / 2;

            const shorterPoints = segmentA.length <= segmentB.length ? pointsA : pointsB;
            const longerSegments = segmentA.length <= segmentB.length ? segmentsB : segmentsA;
            const overlap = computeOverlapFraction(
                shorterPoints,
                longerSegments,
                CORRIDOR_DISTANCE_TOLERANCE_METERS,
                DENSIFY_SPACING_METERS
            );

            return {
                flipB,
                meanDistance,
                overlap,
                angleDiff
            };
        }

        function compareSegmentPair(segmentA, segmentB) {
            const evaluations = [
                evaluateSegmentOrientation(segmentA, segmentB, false),
                evaluateSegmentOrientation(segmentA, segmentB, true)
            ].filter(Boolean);

            let best = null;
            for (const evaluation of evaluations) {
                if (evaluation.angleDiff > CORRIDOR_ANGULAR_TOLERANCE_RAD) {
                    continue;
                }
                if (evaluation.meanDistance > CORRIDOR_DISTANCE_TOLERANCE_METERS) {
                    continue;
                }
                if (evaluation.overlap < CORRIDOR_OVERLAP_THRESHOLD) {
                    continue;
                }
                if (!best || evaluation.meanDistance < best.meanDistance) {
                    best = evaluation;
                }
            }

            if (!best) {
                return { matched: false };
            }

            return {
                matched: true,
                flipB: best.flipB
            };
        }

        function buildSegmentSpatialIndex(segments) {
            const grid = new Map();
            const cellSize = Math.max(SEGMENT_INDEX_CELL_SIZE, CORRIDOR_DISTANCE_TOLERANCE_METERS * 2);

            segments.forEach((segment, index) => {
                const bounds = segment.bounds;
                const minXCell = Math.floor(bounds.minX / cellSize);
                const maxXCell = Math.floor(bounds.maxX / cellSize);
                const minYCell = Math.floor(bounds.minY / cellSize);
                const maxYCell = Math.floor(bounds.maxY / cellSize);
                for (let ix = minXCell; ix <= maxXCell; ix++) {
                    for (let iy = minYCell; iy <= maxYCell; iy++) {
                        const key = `${ix},${iy}`;
                        let bucket = grid.get(key);
                        if (!bucket) {
                            bucket = [];
                            grid.set(key, bucket);
                        }
                        bucket.push(index);
                    }
                }
            });

            return {
                query(bounds) {
                    if (!bounds) {
                        return [];
                    }
                    const minXCell = Math.floor(bounds.minX / cellSize);
                    const maxXCell = Math.floor(bounds.maxX / cellSize);
                    const minYCell = Math.floor(bounds.minY / cellSize);
                    const maxYCell = Math.floor(bounds.maxY / cellSize);
                    const result = new Set();
                    for (let ix = minXCell; ix <= maxXCell; ix++) {
                        for (let iy = minYCell; iy <= maxYCell; iy++) {
                            const key = `${ix},${iy}`;
                            const bucket = grid.get(key);
                            if (!bucket) {
                                continue;
                            }
                            for (const index of bucket) {
                                result.add(index);
                            }
                        }
                    }
                    return Array.from(result);
                }
            };
        }

        function computeCorridorCenterline(members) {
            if (!Array.isArray(members) || !members.length) {
                return [];
            }
            if (members.length === 1) {
                return members[0].orientedPoints.map(clonePoint);
            }
            const lengths = members.map((member) => member.segment.length);
            const maxLength = Math.max(...lengths, 0);
            const sampleCount = Math.max(2, Math.round(maxLength / DENSIFY_SPACING_METERS) + 1);
            const accum = Array.from({ length: sampleCount }, () => ({ x: 0, y: 0 }));

            members.forEach((member) => {
                const samples = samplePolyline(member.orientedPoints, sampleCount);
                for (let i = 0; i < sampleCount; i++) {
                    accum[i].x += samples[i].x;
                    accum[i].y += samples[i].y;
                }
            });

            const count = members.length;
            const averaged = accum.map((point) => ({
                x: point.x / count,
                y: point.y / count
            }));

            const cleaned = removeDuplicatePoints(averaged, 0.05);
            if (cleaned.length >= 2) {
                return cleaned;
            }
            if (averaged.length >= 2) {
                return [clonePoint(averaged[0]), clonePoint(averaged[averaged.length - 1])];
            }
            return averaged.map(clonePoint);
        }

        function clusterSegmentsIntoCorridors(segments) {
            if (!Array.isArray(segments) || !segments.length) {
                return [];
            }

            const adjacency = segments.map(() => []);
            const spatialIndex = buildSegmentSpatialIndex(segments);

            for (let i = 0; i < segments.length; i++) {
                const candidates = spatialIndex.query(segments[i].bounds);
                for (const candidate of candidates) {
                    if (candidate <= i) {
                        continue;
                    }
                    const comparison = compareSegmentPair(segments[i], segments[candidate]);
                    if (comparison.matched) {
                        adjacency[i].push({ index: candidate, flip: comparison.flipB });
                        adjacency[candidate].push({ index: i, flip: comparison.flipB });
                    }
                }
            }

            const visited = new Array(segments.length).fill(false);
            const corridors = [];

            for (let i = 0; i < segments.length; i++) {
                if (visited[i]) {
                    continue;
                }

                const queue = [{ index: i, flip: false }];
                const clusterMembers = [];

                while (queue.length) {
                    const { index, flip } = queue.shift();
                    if (visited[index]) {
                        continue;
                    }
                    visited[index] = true;
                    const segment = segments[index];
                    clusterMembers.push({
                        segment,
                        orientedPoints: flip ? segment.reverse : segment.forward
                    });

                    const neighbors = adjacency[index];
                    for (const neighbor of neighbors) {
                        const nextFlip = flip ? !neighbor.flip : neighbor.flip;
                        if (!visited[neighbor.index]) {
                            queue.push({ index: neighbor.index, flip: nextFlip });
                        }
                    }
                }

                const centerline = computeCorridorCenterline(clusterMembers);
                const memberRouteIds = new Set();
                clusterMembers.forEach(({ segment }) => memberRouteIds.add(segment.sourceRouteId));

                corridors.push({ centerline, memberRouteIds });
            }

            return corridors;
        }

        function snapStopsToCorridors(stops, centerlines) {
            if (!Array.isArray(stops) || !stops.length) {
                return;
            }
            if (!Array.isArray(centerlines) || !centerlines.length) {
                return;
            }
            for (const stop of stops) {
                if (!stop.position) {
                    continue;
                }
                let best = null;
                for (const line of centerlines) {
                    const projection = closestPointOnPolyline(stop.position, line);
                    if (projection && (best === null || projection.distanceSq < best.distanceSq)) {
                        best = projection;
                    }
                }
                if (best) {
                    stop.position = clonePoint(best.point);
                }
            }
        }

        function groupStops(stops) {
            const groups = [];
            const sqTol = STOP_GROUP_DISTANCE * STOP_GROUP_DISTANCE;

            for (const stop of stops) {
                let match = null;
                for (const group of groups) {
                    if (distanceSquared(group.original, stop.position) <= sqTol) {
                        match = group;
                        break;
                    }
                }

                if (!match) {
                    match = {
                        id: `group-${groups.length}`,
                        names: new Set([stop.name]),
                        routeIds: new Set([stop.routeId]),
                        original: clonePoint(stop.position),
                        lat: stop.lat,
                        lon: stop.lon,
                        stops: [stop]
                    };
                    groups.push(match);
                } else {
                    match.names.add(stop.name);
                    match.routeIds.add(stop.routeId);
                    match.stops.push(stop);
                    const count = match.stops.length;
                    match.original.x = (match.original.x * (count - 1) + stop.position.x) / count;
                    match.original.y = (match.original.y * (count - 1) + stop.position.y) / count;
                    match.lat = (match.lat * (count - 1) + stop.lat) / count;
                    match.lon = (match.lon * (count - 1) + stop.lon) / count;
                }
            }

            return groups.map((group) => ({
                id: group.id,
                name: Array.from(group.names).sort().join(' / '),
                routeIds: Array.from(group.routeIds).sort((a, b) => String(a).localeCompare(String(b))),
                original: clonePoint(group.original),
                position: clonePoint(group.original),
                lat: group.lat,
                lon: group.lon
            }));
        }

        function getCanonicalRouteInfo(routeId) {
            const idStr = String(routeId);
            let meta = state.routeMeta.get(idStr);
            if (meta) {
                const canonicalId = meta.id ?? idStr;
                const groupKey = meta.groupKey ?? canonicalId;
                if (!meta.groupKey) {
                    meta.groupKey = groupKey;
                }
                return { routeId: canonicalId, groupKey, meta };
            }

            const componentMap = state.componentToGroup;
            if (componentMap && componentMap.has(idStr)) {
                const mappedKey = String(componentMap.get(idStr));
                meta = state.routeMeta.get(mappedKey);
                if (meta) {
                    const canonicalId = meta.id ?? mappedKey;
                    const groupKey = meta.groupKey ?? canonicalId;
                    if (!meta.groupKey) {
                        meta.groupKey = groupKey;
                    }
                    return { routeId: canonicalId, groupKey, meta };
                }
                return {
                    routeId: mappedKey,
                    groupKey: mappedKey,
                    meta: {
                        id: mappedKey,
                        name: `Route ${mappedKey}`,
                        color: '#000000',
                        componentRouteIds: [],
                        groupKey: mappedKey
                    }
                };
            }

            return {
                routeId: idStr,
                groupKey: idStr,
                meta: {
                    id: idStr,
                    name: `Route ${idStr}`,
                    color: '#000000',
                    componentRouteIds: [],
                    groupKey: idStr
                }
            };
        }

        function normalizeGraphRouteMembership(graph) {
            if (!graph || !Array.isArray(graph.edges)) {
                return;
            }
            for (const edge of graph.edges) {
                const sourceSet = edge.routes instanceof Set ? edge.routes : new Set(edge.routes || []);
                const canonicalRoutes = new Set();
                for (const routeId of sourceSet) {
                    const info = getCanonicalRouteInfo(routeId);
                    canonicalRoutes.add(info.routeId);
                }
                edge.routes = canonicalRoutes;
            }
        }

        function quantizeCoordinate(value, step) {
            return Math.round(value / step) * step;
        }

        function quantizePoint(point, step) {
            return {
                x: quantizeCoordinate(point.x, step),
                y: quantizeCoordinate(point.y, step)
            };
        }

        function quantizePolyline(points, step) {
            if (!Array.isArray(points) || !points.length) {
                return [];
            }
            const quantized = [];
            let prev = null;
            for (const point of points) {
                const qp = quantizePoint(point, step);
                if (!prev || distanceSquared(prev, qp) > 1e-8) {
                    quantized.push(qp);
                    prev = qp;
                }
            }
            if (quantized.length < 2 && points.length >= 2) {
                const first = quantizePoint(points[0], step);
                const last = quantizePoint(points[points.length - 1], step);
                if (!quantized.length) {
                    quantized.push(first);
                }
                if (distanceSquared(quantized[quantized.length - 1], last) > 1e-8) {
                    quantized.push(last);
                }
            }
            return quantized;
        }

        function buildGraph(routes) {
            const nodes = [];
            const edges = [];
            const edgeMap = new Map();
            const nodeLookup = new Map();
            const sqTol = NODE_MERGE_DISTANCE * NODE_MERGE_DISTANCE;

            function nodeKey(point) {
                const gx = Math.round(point.x / NODE_QUANTIZATION_METERS);
                const gy = Math.round(point.y / NODE_QUANTIZATION_METERS);
                return `${gx},${gy}`;
            }

            function findOrCreateNode(point) {
                const quantized = quantizePoint(point, NODE_QUANTIZATION_METERS);
                const key = nodeKey(quantized);
                const existingId = nodeLookup.get(key);
                if (existingId !== undefined) {
                    const existing = nodes[existingId];
                    if (distanceSquared(existing, quantized) <= sqTol) {
                        return existingId;
                    }
                }
                for (const node of nodes) {
                    if (distanceSquared(node, quantized) <= sqTol) {
                        nodeLookup.set(key, node.id);
                        return node.id;
                    }
                }
                const id = nodes.length;
                nodes.push({ id, x: quantized.x, y: quantized.y, edges: new Set() });
                nodeLookup.set(key, id);
                return id;
            }

            function getEdgeBucket(key) {
                let bucket = edgeMap.get(key);
                if (!bucket) {
                    bucket = [];
                    edgeMap.set(key, bucket);
                }
                return bucket;
            }

            for (const route of routes) {
                const segments = Array.isArray(route.segments) && route.segments.length
                    ? route.segments
                    : (route.points ? [route.points] : []);
                for (const points of segments) {
                    if (!points || points.length < 2) {
                        continue;
                    }
                    const quantizedPoints = quantizePolyline(points, NODE_QUANTIZATION_METERS);
                    if (quantizedPoints.length < 2) {
                        continue;
                    }
                    let i = 0;
                    while (i < quantizedPoints.length - 1) {
                        const startPoint = quantizedPoints[i];
                        let j = i + 1;
                        let chosen = null;
                        while (j < quantizedPoints.length) {
                            const candidate = quantizedPoints[j];
                            if (distanceSquared(startPoint, candidate) < 1e-4) {
                                j++;
                                continue;
                            }
                            const length = Math.hypot(candidate.x - startPoint.x, candidate.y - startPoint.y);
                            if (length < GRAPH_MIN_EDGE_LENGTH && j < quantizedPoints.length - 1) {
                                j++;
                                continue;
                            }
                            chosen = { point: candidate, length, index: j };
                            break;
                        }
                        if (!chosen) {
                            break;
                        }
                        const endPoint = chosen.point;
                        const startId = findOrCreateNode(startPoint);
                        const endId = findOrCreateNode(endPoint);
                        if (startId !== endId) {
                            const key = startId < endId ? `${startId}-${endId}` : `${endId}-${startId}`;
                            const bucket = getEdgeBucket(key);
                            const dx = endPoint.x - startPoint.x;
                            const dy = endPoint.y - startPoint.y;
                            const angle = normalizeUndirectedAngle(Math.atan2(dy, dx));
                            let edge = null;
                            for (const candidateEdge of bucket) {
                                if (angularDifferenceRadians(candidateEdge.angle, angle) <= CORRIDOR_ANGULAR_TOLERANCE_RAD) {
                                    edge = candidateEdge;
                                    break;
                                }
                            }
                            if (!edge) {
                                edge = {
                                    id: edges.length,
                                    start: startId,
                                    end: endId,
                                    routes: new Set(),
                                    snapped: null,
                                    angle
                                };
                                bucket.push(edge);
                                edges.push(edge);
                                nodes[startId].edges.add(edge.id);
                                nodes[endId].edges.add(edge.id);
                            }
                            edge.routes.add(route.id);
                        }
                        i = chosen.index;
                    }
                }
            }

            nodes.forEach((node) => {
                node.edges = Array.from(node.edges);
            });

            const graph = { nodes, edges };
            const preCoalesceEdgeCount = edges.length;
            coalesceDegreeTwoRuns(graph);
            const postCoalesceEdgeCount = graph.edges.length;
            if (preCoalesceEdgeCount > 0) {
                const reduction = preCoalesceEdgeCount - postCoalesceEdgeCount;
                console.assert(
                    reduction > preCoalesceEdgeCount * 0.1,
                    `Graph coalescing ineffective: ${preCoalesceEdgeCount} â†’ ${postCoalesceEdgeCount}`
                );
            }

            return graph;
        }

        function coalesceDegreeTwoRuns(graph) {
            if (!graph || !Array.isArray(graph.nodes) || !Array.isArray(graph.edges)) {
                return;
            }
            const { nodes, edges } = graph;
            let changed = true;
            while (changed) {
                changed = false;
                for (const node of nodes) {
                    if (!node || node.removed || !Array.isArray(node.edges) || node.edges.length !== 2) {
                        continue;
                    }
                    const [edgeIdA, edgeIdB] = node.edges;
                    const edgeA = edges[edgeIdA];
                    const edgeB = edges[edgeIdB];
                    if (!edgeA || !edgeB || edgeA.removed || edgeB.removed) {
                        continue;
                    }
                    if (!routeSetsEqual(edgeA.routes, edgeB.routes)) {
                        continue;
                    }
                    const angleA = computeEdgeDirectionAtNode(edgeA, node.id, nodes);
                    const angleB = computeEdgeDirectionAtNode(edgeB, node.id, nodes);
                    if (angleA === null || angleB === null) {
                        continue;
                    }
                    if (angularDifferenceRadians(angleA, angleB) > DEGREE2_MERGE_ANGLE_RAD) {
                        continue;
                    }
                    const otherA = edgeA.start === node.id ? edgeA.end : edgeA.start;
                    const otherB = edgeB.start === node.id ? edgeB.end : edgeB.start;
                    if (otherA === undefined || otherB === undefined || otherA === otherB) {
                        continue;
                    }
                    removeEdgeReference(node, edgeIdA);
                    removeEdgeReference(node, edgeIdB);
                    removeEdgeReference(nodes[otherB], edgeIdB);
                    edgeB.removed = true;
                    node.removed = true;
                    node.edges = [];
                    edgeA.start = otherA;
                    edgeA.end = otherB;
                    addEdgeReference(nodes[otherA], edgeIdA);
                    addEdgeReference(nodes[otherB], edgeIdA);
                    const startNode = nodes[edgeA.start];
                    const endNode = nodes[edgeA.end];
                    if (startNode && endNode) {
                        const mergedDx = endNode.x - startNode.x;
                        const mergedDy = endNode.y - startNode.y;
                        edgeA.angle = normalizeUndirectedAngle(Math.atan2(mergedDy, mergedDx));
                    }
                    changed = true;
                    break;
                }
            }

            const idMap = new Map();
            const compacted = [];
            edges.forEach((edge, index) => {
                if (!edge || edge.removed) {
                    return;
                }
                const newId = compacted.length;
                idMap.set(index, newId);
                edge.id = newId;
                compacted.push(edge);
            });
            graph.edges = compacted;

            nodes.forEach((node) => {
                if (!node) {
                    return;
                }
                if (!Array.isArray(node.edges)) {
                    node.edges = [];
                    return;
                }
                const unique = new Set();
                const remapped = [];
                for (const edgeId of node.edges) {
                    const mapped = idMap.get(edgeId);
                    if (mapped === undefined || unique.has(mapped)) {
                        continue;
                    }
                    unique.add(mapped);
                    remapped.push(mapped);
                }
                node.edges = remapped;
            });
        }

        function addEdgeReference(node, edgeId) {
            if (!node) {
                return;
            }
            if (!Array.isArray(node.edges)) {
                node.edges = [];
            }
            if (!node.edges.includes(edgeId)) {
                node.edges.push(edgeId);
            }
        }

        function removeEdgeReference(node, edgeId) {
            if (!node || !Array.isArray(node.edges)) {
                return;
            }
            const index = node.edges.indexOf(edgeId);
            if (index !== -1) {
                node.edges.splice(index, 1);
            }
        }

        function routeSetsEqual(a, b) {
            if (a === b) {
                return true;
            }
            if (!(a instanceof Set) || !(b instanceof Set) || a.size !== b.size) {
                return false;
            }
            for (const value of a) {
                if (!b.has(value)) {
                    return false;
                }
            }
            return true;
        }

        function computeEdgeDirectionAtNode(edge, nodeId, nodes) {
            if (!edge) {
                return null;
            }
            const otherId = edge.start === nodeId ? edge.end : edge.start;
            const node = nodes[nodeId];
            const other = nodes[otherId];
            if (!node || !other) {
                return null;
            }
            const dx = other.x - node.x;
            const dy = other.y - node.y;
            if (Math.abs(dx) < 1e-6 && Math.abs(dy) < 1e-6) {
                return null;
            }
            return normalizeUndirectedAngle(Math.atan2(dy, dx));
        }

        function snapOctilinear(graph) {
            if (!graph || !Array.isArray(graph.edges)) {
                return;
            }
            for (const edge of graph.edges) {
                if (!edge) {
                    continue;
                }
                const start = graph.nodes[edge.start];
                const end = graph.nodes[edge.end];
                edge.snapped = computeOctilinearPath(start, end);
                let passes = 0;
                while (
                    edge.snapped &&
                    edge.snapped.length > 2 &&
                    pathHasShortSegment(edge.snapped, SNAP_MIN_SEGMENT_LENGTH) &&
                    passes < 5
                ) {
                    console.warn(`Collapsing short snapped segment on edge ${edge.id}`);
                    edge.snapped = collapseShortSegments(edge.snapped, SNAP_MIN_SEGMENT_LENGTH);
                    edge.snapped = mergeCollinear(edge.snapped);
                    passes++;
                }
                console.assert(
                    !pathHasShortSegment(edge.snapped, SNAP_MIN_SEGMENT_LENGTH),
                    `Edge ${edge.id} retains sub-threshold segments after snapping.`
                );
            }
        }

        function computeEdgeRouteKey(edge) {
            if (!edge) {
                return '';
            }
            if (edge.routeKey) {
                return edge.routeKey;
            }
            const values = edge.routes instanceof Set ? Array.from(edge.routes) : Array.from(edge.routes || []);
            const canonical = values.map((value) => String(value)).sort((a, b) => a.localeCompare(b));
            const key = canonical.join('|');
            edge.routeKey = key;
            edge.routeOrder = canonical;
            return key;
        }

        function buildBundleChains(graph) {
            if (!graph || !Array.isArray(graph.edges) || !Array.isArray(graph.nodes)) {
                return [];
            }
            const chains = [];
            const visited = new Set();
            const nodes = graph.nodes;
            const edges = graph.edges;

            function getSameRouteNeighbors(nodeId, routeKey, excludeEdgeId) {
                const node = nodes[nodeId];
                if (!node || !Array.isArray(node.edges)) {
                    return [];
                }
                const neighbors = [];
                for (const edgeId of node.edges) {
                    if (edgeId === excludeEdgeId) {
                        continue;
                    }
                    const candidate = edges[edgeId];
                    if (!candidate) {
                        continue;
                    }
                    if (computeEdgeRouteKey(candidate) === routeKey) {
                        neighbors.push(edgeId);
                    }
                }
                return neighbors;
            }

            function extendDirection(startNode, incomingEdgeId, routeKey, seenEdges) {
                const entries = [];
                let currentNode = startNode;
                let previousEdgeId = incomingEdgeId;
                const safety = new Set();
                while (true) {
                    const neighbors = getSameRouteNeighbors(currentNode, routeKey, previousEdgeId);
                    if (neighbors.length !== 1) {
                        break;
                    }
                    const nextEdgeId = neighbors[0];
                    if (seenEdges.has(nextEdgeId)) {
                        break;
                    }
                    const nextEdge = edges[nextEdgeId];
                    if (!nextEdge) {
                        break;
                    }
                    seenEdges.add(nextEdgeId);
                    const nextNode = nextEdge.start === currentNode ? nextEdge.end : nextEdge.start;
                    const reversed = nextEdge.end === currentNode;
                    entries.push({ edgeId: nextEdgeId, reversed, from: currentNode, to: nextNode });
                    previousEdgeId = nextEdgeId;
                    currentNode = nextNode;
                    const safetyKey = `${currentNode}-${previousEdgeId}`;
                    if (safety.has(safetyKey)) {
                        break;
                    }
                    safety.add(safetyKey);
                }
                return { entries, terminalNode: currentNode };
            }

            for (const edge of edges) {
                if (!edge || visited.has(edge.id)) {
                    continue;
                }
                const routeKey = computeEdgeRouteKey(edge);
                if (!routeKey) {
                    continue;
                }
                const seenEdges = new Set([edge.id]);
                const backward = extendDirection(edge.start, edge.id, routeKey, seenEdges);
                const forward = extendDirection(edge.end, edge.id, routeKey, seenEdges);

                const ordered = [];
                for (let i = backward.entries.length - 1; i >= 0; i--) {
                    const entry = backward.entries[i];
                    ordered.push({ edgeId: entry.edgeId, reversed: !entry.reversed });
                }
                ordered.push({ edgeId: edge.id, reversed: false });
                for (const entry of forward.entries) {
                    ordered.push({ edgeId: entry.edgeId, reversed: entry.reversed });
                }

                const nodesSequence = [];
                const skeletonPoints = [];
                for (let index = 0; index < ordered.length; index++) {
                    const ref = ordered[index];
                    const refEdge = edges[ref.edgeId];
                    if (!refEdge || !Array.isArray(refEdge.snapped) || refEdge.snapped.length < 2) {
                        continue;
                    }
                    const polyline = ref.reversed ? refEdge.snapped.slice().reverse() : refEdge.snapped;
                    const startNodeId = ref.reversed ? refEdge.end : refEdge.start;
                    const endNodeId = ref.reversed ? refEdge.start : refEdge.end;
                    if (!nodesSequence.length) {
                        nodesSequence.push(startNodeId);
                    }
                    nodesSequence.push(endNodeId);

                    for (let i = 0; i < polyline.length; i++) {
                        const point = polyline[i];
                        if (!skeletonPoints.length) {
                            skeletonPoints.push(clonePoint(point));
                            continue;
                        }
                        const last = skeletonPoints[skeletonPoints.length - 1];
                        if (distanceSquared(last, point) < 1e-6) {
                            continue;
                        }
                        skeletonPoints.push(clonePoint(point));
                    }
                }

                let skeleton = mergeCollinear(skeletonPoints);
                skeleton = collapseShortSegments(skeleton, SNAP_MIN_SEGMENT_LENGTH);
                skeleton = mergeCollinear(skeleton);

                const routeIds = Array.from(edge.routes instanceof Set ? edge.routes : new Set(edge.routes || []), (value) => String(value))
                    .sort((a, b) => a.localeCompare(b));

                const members = routeIds.map((routeId) => {
                    const meta = state.routeMeta.get(routeId) || {
                        id: routeId,
                        name: `Route ${routeId}`,
                        color: '#000000',
                        componentRouteIds: [],
                        groupKey: routeId
                    };
                    return {
                        routeId,
                        meta,
                        name: meta.name || `Route ${routeId}`,
                        color: meta.color || '#000000'
                    };
                });

                members.sort((a, b) => {
                    const nameCompare = a.name.localeCompare(b.name, undefined, { sensitivity: 'base' });
                    if (nameCompare !== 0) {
                        return nameCompare;
                    }
                    const colorCompare = a.color.localeCompare(b.color, undefined, { sensitivity: 'base' });
                    if (colorCompare !== 0) {
                        return colorCompare;
                    }
                    return String(a.routeId).localeCompare(String(b.routeId));
                });

                const chainId = chains.length;
                const baseNormal = computeInitialChainNormal(skeleton);
                const chain = {
                    id: chainId,
                    routeKey,
                    routeIds,
                    routeSet: new Set(routeIds),
                    edges: ordered,
                    nodes: nodesSequence,
                    skeleton,
                    members,
                    baseNormal,
                    segmentData: [],
                    casingElement: null,
                    groupElement: null
                };

                chains.push(chain);

                for (const ref of ordered) {
                    visited.add(ref.edgeId);
                    const mappedEdge = edges[ref.edgeId];
                    if (mappedEdge) {
                        mappedEdge.chainId = chainId;
                    }
                }
            }

            const missing = [];
            for (const edge of graph.edges) {
                if (!edge) {
                    continue;
                }
                if (!visited.has(edge.id)) {
                    missing.push(edge.id);
                }
            }
            console.assert(missing.length === 0, `Edges without chain assignment: ${missing.join(', ')}`);
            return chains;
        }

        function cleanChainIntersections(graph, chains) {
            if (!graph || !Array.isArray(graph.nodes) || !Array.isArray(chains)) {
                return;
            }

            const nodeToEntries = new Map();
            for (const chain of chains) {
                if (!chain || !Array.isArray(chain.nodes)) {
                    continue;
                }
                for (let i = 0; i < chain.nodes.length; i++) {
                    const nodeId = chain.nodes[i];
                    if (typeof nodeId !== 'number' || !Number.isFinite(nodeId)) {
                        continue;
                    }
                    let bucket = nodeToEntries.get(nodeId);
                    if (!bucket) {
                        bucket = [];
                        nodeToEntries.set(nodeId, bucket);
                    }
                    bucket.push({ chain, nodeIndex: i });
                }
            }

            const processed = new Set();
            nodeToEntries.forEach((entries, nodeId) => {
                if (!Array.isArray(entries) || entries.length < 2) {
                    return;
                }

                const branchEntries = entries.filter((entry) => {
                    const chain = entry.chain;
                    if (!chain || !Array.isArray(chain.nodes) || chain.nodes.length < 2) {
                        return false;
                    }
                    return entry.nodeIndex === 0 || entry.nodeIndex === chain.nodes.length - 1;
                });

                const throughEntries = entries.filter((entry) => {
                    const chain = entry.chain;
                    if (!chain || !Array.isArray(chain.nodes) || chain.nodes.length < 3) {
                        return false;
                    }
                    return entry.nodeIndex > 0 && entry.nodeIndex < chain.nodes.length - 1;
                });

                if (!branchEntries.length || !throughEntries.length) {
                    return;
                }

                for (const branchEntry of branchEntries) {
                    const key = `${branchEntry.chain.id}:${nodeId}`;
                    if (processed.has(key)) {
                        continue;
                    }

                    const throughEntry = selectThroughCandidate(branchEntry.chain, throughEntries);
                    if (!throughEntry) {
                        continue;
                    }

                    const branchRoutes = branchEntry.chain?.routeSet;
                    const throughRoutes = throughEntry.chain?.routeSet;
                    if (branchRoutes && throughRoutes && setsEqual(branchRoutes, throughRoutes)) {
                        continue;
                    }

                    if (adjustBranchAndThroughAtJunction(branchEntry, throughEntry)) {
                        processed.add(key);
                    }
                }
            });
        }

        function selectThroughCandidate(branchChain, candidates) {
            if (!branchChain || !Array.isArray(candidates) || !candidates.length) {
                return null;
            }
            let best = null;
            let bestScore = -Infinity;
            const branchRoutes = branchChain.routeSet;
            const branchRouteCount = Array.isArray(branchChain.routeIds)
                ? branchChain.routeIds.length
                : branchRoutes?.size ?? 0;
            for (const entry of candidates) {
                const chain = entry.chain;
                if (!chain) {
                    continue;
                }
                const throughRoutes = chain.routeSet;
                const intersection = countSetIntersection(branchRoutes, throughRoutes);
                const subsetBonus = isSubset(branchRoutes, throughRoutes) ? 1000 : 0;
                const throughRouteCount = Array.isArray(chain.routeIds)
                    ? chain.routeIds.length
                    : throughRoutes?.size ?? 0;
                const sizePenalty = Math.abs(throughRouteCount - branchRouteCount) * 0.01;
                const score = subsetBonus + intersection - sizePenalty;
                if (!best || score > bestScore || (score === bestScore && chain.id < best.chain.id)) {
                    best = entry;
                    bestScore = score;
                }
            }
            return best;
        }

        function countSetIntersection(a, b) {
            if (!a || !b) {
                return 0;
            }
            let count = 0;
            a.forEach((value) => {
                if (b.has(value)) {
                    count++;
                }
            });
            return count;
        }

        function isSubset(a, b) {
            if (!a || !b) {
                return false;
            }
            for (const value of a) {
                if (!b.has(value)) {
                    return false;
                }
            }
            return true;
        }

        function setsEqual(a, b) {
            if (a === b) {
                return true;
            }
            if (!a || !b || a.size !== b.size) {
                return false;
            }
            for (const value of a) {
                if (!b.has(value)) {
                    return false;
                }
            }
            return true;
        }

        function adjustBranchAndThroughAtJunction(branchEntry, throughEntry) {
            const branchChain = branchEntry?.chain;
            const throughChain = throughEntry?.chain;
            if (!branchChain || !throughChain) {
                return false;
            }
            const branchSkeleton = branchChain.skeleton;
            const throughSkeleton = throughChain.skeleton;
            if (!Array.isArray(branchSkeleton) || branchSkeleton.length < 2) {
                return false;
            }
            if (!Array.isArray(throughSkeleton) || throughSkeleton.length < 2) {
                return false;
            }

            const branchIsStart = branchEntry.nodeIndex === 0;
            const branchPointIndex = branchIsStart ? 0 : branchSkeleton.length - 1;
            const neighborIndex = branchIsStart ? 1 : branchSkeleton.length - 2;
            if (neighborIndex < 0 || neighborIndex >= branchSkeleton.length || neighborIndex === branchPointIndex) {
                return false;
            }
            const branchNeighbor = branchSkeleton[neighborIndex];
            const branchPoint = branchSkeleton[branchPointIndex];
            if (!branchNeighbor || !branchPoint) {
                return false;
            }

            const projection = closestPointOnPolyline(branchPoint, throughSkeleton);
            if (!projection || typeof projection.segmentIndex !== 'number') {
                return false;
            }
            const segmentIndex = projection.segmentIndex;
            if (segmentIndex < 0 || segmentIndex >= throughSkeleton.length - 1) {
                return false;
            }

            const start = throughSkeleton[segmentIndex];
            const end = throughSkeleton[segmentIndex + 1];
            if (!start || !end) {
                return false;
            }

            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const segmentLength = Math.hypot(dx, dy);
            if (segmentLength < 1e-3) {
                return false;
            }

            const minLeg = SNAP_MIN_SEGMENT_LENGTH;
            if (segmentLength < minLeg * 2 - 1e-3) {
                return false;
            }

            let t = typeof projection.t === 'number' ? projection.t : 0.5;
            t = clamp(t, 0, 1);
            const minT = minLeg / segmentLength;
            const maxT = 1 - minT;
            if (minT >= maxT) {
                return false;
            }
            t = clamp(t, minT, maxT);

            const junctionPoint = {
                x: start.x + dx * t,
                y: start.y + dy * t
            };

            const branchLength = Math.hypot(junctionPoint.x - branchNeighbor.x, junctionPoint.y - branchNeighbor.y);
            if (branchLength < minLeg * 0.5) {
                return false;
            }

            const startDistance = Math.hypot(junctionPoint.x - start.x, junctionPoint.y - start.y);
            const endDistance = Math.hypot(junctionPoint.x - end.x, junctionPoint.y - end.y);
            if (startDistance < minLeg - 1e-3 || endDistance < minLeg - 1e-3) {
                return false;
            }

            const existingIndex = findPointIndex(throughSkeleton, junctionPoint, 0.75);
            if (existingIndex >= 0) {
                throughSkeleton[existingIndex] = { x: junctionPoint.x, y: junctionPoint.y };
            } else {
                throughSkeleton.splice(segmentIndex + 1, 0, { x: junctionPoint.x, y: junctionPoint.y });
            }

            branchSkeleton[branchPointIndex] = { x: junctionPoint.x, y: junctionPoint.y };

            branchChain.baseNormal = null;
            branchChain.segmentData = [];
            throughChain.baseNormal = null;
            throughChain.segmentData = [];

            return true;
        }

        function findPointIndex(points, target, tolerance = 1e-3) {
            if (!Array.isArray(points)) {
                return -1;
            }
            const tol = Math.max(tolerance, 1e-6);
            const tolSq = tol * tol;
            for (let i = 0; i < points.length; i++) {
                const point = points[i];
                if (!point) {
                    continue;
                }
                if (distanceSquared(point, target) <= tolSq) {
                    return i;
                }
            }
            return -1;
        }

        function computeInitialChainNormal(points) {
            if (!Array.isArray(points) || points.length < 2) {
                return { x: 0, y: -1 };
            }
            for (let i = 0; i < points.length - 1; i++) {
                const a = points[i];
                const b = points[i + 1];
                const dx = b.x - a.x;
                const dy = b.y - a.y;
                const length = Math.hypot(dx, dy);
                if (length >= SNAP_MIN_SEGMENT_LENGTH * 0.5) {
                    return normalizeVector({ x: -dy / length, y: dx / length });
                }
            }
            const first = points[0];
            const last = points[points.length - 1];
            const dx = last.x - first.x;
            const dy = last.y - first.y;
            const length = Math.hypot(dx, dy);
            if (length > 1e-6) {
                return normalizeVector({ x: -dy / length, y: dx / length });
            }
            return { x: 0, y: -1 };
        }

        function normalizeVector(vector) {
            if (!vector) {
                return { x: 0, y: 0 };
            }
            const length = Math.hypot(vector.x, vector.y);
            if (length < 1e-6) {
                return { x: 0, y: 0 };
            }
            return { x: vector.x / length, y: vector.y / length };
        }

        function computeOctilinearPath(start, end) {
            if (!start || !end) {
                return [];
            }
            const startPoint = clonePoint(start);
            const endPoint = clonePoint(end);
            const path = [startPoint];

            const dx = endPoint.x - startPoint.x;
            const dy = endPoint.y - startPoint.y;
            const absDx = Math.abs(dx);
            const absDy = Math.abs(dy);
            const signX = Math.sign(dx) || 1;
            const signY = Math.sign(dy) || 1;

            let diagLength = Math.min(absDx, absDy);
            if (diagLength >= MIN_DIAGONAL_LENGTH) {
                let adjustedDiag = diagLength;
                if (absDx > diagLength) {
                    adjustedDiag = Math.min(adjustedDiag, absDx - SNAP_MIN_SEGMENT_LENGTH);
                }
                if (absDy > diagLength) {
                    adjustedDiag = Math.min(adjustedDiag, absDy - SNAP_MIN_SEGMENT_LENGTH);
                }
                if (adjustedDiag >= MIN_DIAGONAL_LENGTH) {
                    diagLength = adjustedDiag;
                } else {
                    diagLength = 0;
                }
            } else {
                diagLength = 0;
            }

            if (diagLength > 0) {
                const diagPoint = {
                    x: startPoint.x + signX * diagLength,
                    y: startPoint.y + signY * diagLength
                };
                if (distanceSquared(diagPoint, path[path.length - 1]) > 1e-6 && distanceSquared(diagPoint, endPoint) > 1e-6) {
                    path.push(diagPoint);
                }
            }

            const remainingX = dx - signX * diagLength;
            const remainingY = dy - signY * diagLength;

            if (Math.abs(remainingX) > 1e-6) {
                const current = path[path.length - 1];
                const horizontal = {
                    x: current.x + signX * Math.abs(remainingX),
                    y: current.y
                };
                if (distanceSquared(horizontal, current) > 1e-6 && distanceSquared(horizontal, endPoint) > 1e-6) {
                    path.push(horizontal);
                }
            }

            if (Math.abs(remainingY) > 1e-6) {
                const current = path[path.length - 1];
                const vertical = {
                    x: current.x,
                    y: current.y + signY * Math.abs(remainingY)
                };
                if (distanceSquared(vertical, current) > 1e-6 && distanceSquared(vertical, endPoint) > 1e-6) {
                    path.push(vertical);
                }
            }

            path.push(endPoint);

            let cleaned = mergeCollinear(path);
            cleaned = collapseShortSegments(cleaned, SNAP_MIN_SEGMENT_LENGTH);
            cleaned = mergeCollinear(cleaned);
            return cleaned;
        }

        function mergeCollinear(points) {
            if (points.length <= 2) {
                return points.map(clonePoint);
            }
            const cleaned = [clonePoint(points[0])];
            for (let i = 1; i < points.length - 1; i++) {
                const prev = cleaned[cleaned.length - 1];
                const current = points[i];
                const next = points[i + 1];
                if (isCollinear(prev, current, next)) {
                    continue;
                }
                cleaned.push(clonePoint(current));
            }
            cleaned.push(clonePoint(points[points.length - 1]));
            return cleaned;
        }

        function collapseShortSegments(points, minLength) {
            if (!Array.isArray(points) || points.length <= 2) {
                return Array.isArray(points) ? points.map(clonePoint) : [];
            }
            const minSq = minLength * minLength;
            const result = points.map(clonePoint);
            let iterations = 0;
            const maxIterations = result.length * 4;
            let changed = true;
            while (changed && iterations < maxIterations) {
                iterations++;
                changed = false;
                for (let i = 0; i < result.length - 1; i++) {
                    const a = result[i];
                    const b = result[i + 1];
                    if (distanceSquared(a, b) >= minSq) {
                        continue;
                    }
                    if (i === 0) {
                        result.splice(i + 1, 1);
                    } else if (i + 1 === result.length - 1) {
                        result.splice(i, 1);
                    } else {
                        const prev = result[i - 1];
                        const next = result[i + 2];
                        const options = [];
                        if (prev && isAxisOrDiagonal45(prev, b)) {
                            options.push({ index: i, length: Math.hypot(b.x - prev.x, b.y - prev.y) });
                        }
                        if (next && isAxisOrDiagonal45(a, next)) {
                            options.push({ index: i + 1, length: Math.hypot(next.x - a.x, next.y - a.y) });
                        }
                        if (options.length) {
                            const preferred = options.find((option) => option.length >= minLength) || options[0];
                            result.splice(preferred.index, 1);
                        } else {
                            result.splice(i + 1, 1);
                        }
                    }
                    changed = true;
                    break;
                }
            }
            return result;
        }

        function pathHasShortSegment(points, minLength) {
            if (!Array.isArray(points) || points.length < 2) {
                return false;
            }
            const minSq = minLength * minLength;
            for (let i = 0; i < points.length - 1; i++) {
                if (distanceSquared(points[i], points[i + 1]) < minSq) {
                    return true;
                }
            }
            return false;
        }

        function isCollinear(a, b, c) {
            const dx1 = b.x - a.x;
            const dy1 = b.y - a.y;
            const dx2 = c.x - b.x;
            const dy2 = c.y - b.y;
            return Math.abs(dx1 * dy2 - dy1 * dx2) < 1e-6;
        }

        function isAxisOrDiagonal45(a, b, tolerance = 1e-3) {
            if (!a || !b) {
                return false;
            }
            const dx = Math.abs(b.x - a.x);
            const dy = Math.abs(b.y - a.y);
            if (dx < tolerance && dy < tolerance) {
                return true;
            }
            if (dx < tolerance || dy < tolerance) {
                return true;
            }
            return Math.abs(dx - dy) < tolerance;
        }

        function alignStopsToChains(stopGroups, chains) {
            if (!Array.isArray(stopGroups) || !Array.isArray(chains)) {
                return;
            }
            for (const group of stopGroups) {
                let best = null;
                for (const chain of chains) {
                    if (!chain || !Array.isArray(chain.skeleton) || chain.skeleton.length < 2) {
                        continue;
                    }
                    const routeMatch = Array.isArray(group.routeIds)
                        ? group.routeIds.some((routeId) => chain.routeSet.has(String(routeId)))
                        : false;
                    if (!routeMatch) {
                        continue;
                    }
                    const projection = closestPointOnPolyline(group.original, chain.skeleton);
                    if (projection && (best === null || projection.distanceSq < best.distanceSq)) {
                        best = { ...projection, chainId: chain.id };
                    }
                }
                if (best) {
                    group.position = best.point;
                    group.chainId = best.chainId;
                } else {
                    group.position = clonePoint(group.original);
                    group.chainId = null;
                }
            }
        }

        function closestPointOnPolyline(point, polyline) {
            if (!polyline || polyline.length === 0) {
                return null;
            }
            let best = null;
            for (let i = 0; i < polyline.length - 1; i++) {
                const a = polyline[i];
                const b = polyline[i + 1];
                const projection = projectPointToSegment(point, a, b);
                if (!best || projection.distanceSq < best.distanceSq) {
                    best = { ...projection, segmentIndex: i };
                }
            }
            return best;
        }

        function projectPointToSegment(point, a, b) {
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const lengthSq = dx * dx + dy * dy;
            if (lengthSq === 0) {
                return {
                    point: clonePoint(a),
                    distanceSq: distanceSquared(point, a),
                    t: 0
                };
            }
            const t = Math.max(0, Math.min(1, ((point.x - a.x) * dx + (point.y - a.y) * dy) / lengthSq));
            const proj = {
                x: a.x + t * dx,
                y: a.y + t * dy
            };
            return {
                point: proj,
                distanceSq: distanceSquared(point, proj),
                t
            };
        }

        function render() {
            const svg = document.getElementById('schematic');
            const bundlesGroup = svg.querySelector('.bundles');
            const stopsGroup = svg.querySelector('.stops');
            const terminiGroup = svg.querySelector('.termini');
            bundlesGroup.innerHTML = '';
            stopsGroup.innerHTML = '';
            terminiGroup.innerHTML = '';

            let chains;
            if (Array.isArray(state.bundleChains) && state.bundleChains.length) {
                chains = state.bundleChains;
            } else {
                chains = buildBundleChains(state.graph);
                cleanChainIntersections(state.graph, chains);
                alignStopsToChains(state.stopGroups, chains);
                state.bundleChains = chains;
            }
            const sortedChains = [...chains].sort((a, b) => a.id - b.id);

            const usedRouteIds = new Set();
            sortedChains.forEach((chain) => {
                chain.routeIds.forEach((routeId) => usedRouteIds.add(routeId));
            });

            renderLegend(usedRouteIds);

            const bounds = computeBounds(state.graph.edges, state.stopGroups);
            const padding = Math.max(bounds.width, bounds.height) * 0.05 + 80;
            const viewBox = {
                x: bounds.minX - padding,
                y: bounds.minY - padding,
                width: bounds.width + padding * 2,
                height: bounds.height + padding * 2
            };

            state.viewBox = { ...viewBox };
            state.baseViewBox = { ...viewBox };
            svg.setAttribute('viewBox', `${viewBox.x} ${viewBox.y} ${viewBox.width} ${viewBox.height}`);
            svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');

            state.routePaths = [];
            state.routePathLookup.clear();

            const chainFragment = document.createDocumentFragment();
            sortedChains.forEach((chain) => {
                const groupEl = document.createElementNS(svgNS, 'g');
                groupEl.classList.add('bundle-chain');
                groupEl.dataset.chain = String(chain.id);

                const casing = document.createElementNS(svgNS, 'path');
                casing.classList.add('bundle-casing');
                casing.setAttribute('fill', 'none');
                casing.setAttribute('stroke', '#ffffff');
                casing.setAttribute('stroke-width', ROUTE_LINE_WIDTH_PX + 2 * ROUTE_GAP_PX);
                casing.setAttribute('vector-effect', 'non-scaling-stroke');
                casing.setAttribute('stroke-linecap', 'round');
                casing.setAttribute('stroke-linejoin', 'round');
                groupEl.appendChild(casing);
                chain.casingElement = casing;
                chain.groupElement = groupEl;

                chain.members.forEach((member, index) => {
                    const pathEl = document.createElementNS(svgNS, 'path');
                    pathEl.classList.add('route-path');
                    pathEl.dataset.route = String(member.routeId);
                    pathEl.dataset.chain = String(chain.id);
                    pathEl.setAttribute('stroke', member.color);
                    pathEl.setAttribute('stroke-width', ROUTE_LINE_WIDTH_PX);
                    pathEl.setAttribute('vector-effect', 'non-scaling-stroke');
                    pathEl.setAttribute('fill', 'none');
                    pathEl.setAttribute('stroke-linecap', 'round');
                    pathEl.setAttribute('stroke-linejoin', 'round');
                    groupEl.appendChild(pathEl);

                    const item = {
                        routeId: member.routeId,
                        chainId: chain.id,
                        bundleIndex: index,
                        bundleCount: chain.members.length,
                        centerline: chain.skeleton,
                        pathElement: pathEl,
                        offsetPoints: null,
                        meta: member.meta
                    };
                    state.routePaths.push(item);
                    state.routePathLookup.set(`${member.routeId}-${chain.id}`, item);

                    pathEl.addEventListener('pointerenter', () => applyHighlight(new Set([member.routeId])));
                    pathEl.addEventListener('pointerleave', (event) => {
                        const related = event.relatedTarget;
                        if (related && (related.closest('.route-path') || related.closest('.stop-circle') || related.closest('.legend-item'))) {
                            return;
                        }
                        clearHighlight();
                    });
                });

                chainFragment.appendChild(groupEl);
            });
            bundlesGroup.appendChild(chainFragment);

            state.stopElements = state.stopGroups.map((stop) => {
                const circle = document.createElementNS(svgNS, 'circle');
                circle.classList.add('stop-circle');
                circle.setAttribute('cx', stop.position.x);
                circle.setAttribute('cy', stop.position.y);
                circle.setAttribute('fill', '#ffffff');
                circle.setAttribute('stroke', '#111111');
                circle.setAttribute('stroke-width', STOP_STROKE_PX);
                circle.setAttribute('vector-effect', 'non-scaling-stroke');
                circle.dataset.stop = stop.id;
                circle.dataset.routes = stop.routeIds.join(',');
                if (typeof stop.chainId === 'number') {
                    circle.dataset.chain = String(stop.chainId);
                }
                stopsGroup.appendChild(circle);

                circle.addEventListener('pointerenter', (event) => {
                    applyHighlight(new Set(stop.routeIds));
                    showStopTooltip(stop, event);
                });
                circle.addEventListener('pointermove', (event) => updateTooltipPosition(event));
                circle.addEventListener('pointerleave', (event) => {
                    const related = event.relatedTarget;
                    if (!related || (!related.closest('.route-path') && !related.closest('.legend-item') && !related.closest('.stop-circle'))) {
                        clearHighlight();
                    }
                    hideTooltip();
                });

                return { stop, element: circle };
            });

            const terminusData = computeTermini(state.graph);
            state.terminusElements = terminusData.map((term) => {
                const meta = state.routeMeta.get(term.routeId) || { color: '#000000' };
                const path = document.createElementNS(svgNS, 'path');
                path.setAttribute('stroke', meta.color);
                path.setAttribute('stroke-width', ROUTE_LINE_WIDTH_PX);
                path.setAttribute('vector-effect', 'non-scaling-stroke');
                path.setAttribute('fill', 'none');
                path.setAttribute('stroke-linecap', 'round');
                path.dataset.route = String(term.routeId);
                path.dataset.chain = String(term.chainId ?? '');
                terminiGroup.appendChild(path);
                return { ...term, element: path };
            });

            attachPanZoom(svg);
            scheduleScaleUpdate();
            window.addEventListener('resize', scheduleScaleUpdate);
        }
        function computeBounds(edges, stops) {
            let minX = Infinity;
            let minY = Infinity;
            let maxX = -Infinity;
            let maxY = -Infinity;

            for (const edge of edges) {
                if (!edge.snapped) continue;
                for (const point of edge.snapped) {
                    minX = Math.min(minX, point.x);
                    minY = Math.min(minY, point.y);
                    maxX = Math.max(maxX, point.x);
                    maxY = Math.max(maxY, point.y);
                }
            }

            for (const stop of stops) {
                if (!stop.position) continue;
                minX = Math.min(minX, stop.position.x);
                minY = Math.min(minY, stop.position.y);
                maxX = Math.max(maxX, stop.position.x);
                maxY = Math.max(maxY, stop.position.y);
            }

            if (!isFinite(minX) || !isFinite(minY)) {
                minX = minY = 0;
                maxX = maxY = 1000;
            }

            return {
                minX,
                minY,
                maxX,
                maxY,
                width: maxX - minX || 1000,
                height: maxY - minY || 1000
            };
        }

        function renderLegend(routeIds) {
            const legendList = document.getElementById('legend-list');
            legendList.innerHTML = '';
            const fragment = document.createDocumentFragment();
            const entries = Array.from(routeIds)
                .map((id) => state.routeMeta.get(id) || { id, name: `Route ${id}`, color: '#000000' })
                .sort((a, b) => a.name.localeCompare(b.name));

            entries.forEach((meta) => {
                const item = document.createElement('li');
                item.classList.add('legend-item');
                item.dataset.route = String(meta.id);
                item.tabIndex = 0;
                const swatch = document.createElement('span');
                swatch.className = 'swatch';
                swatch.style.background = meta.color;
                item.appendChild(swatch);
                const label = document.createElement('span');
                label.textContent = meta.name;
                item.appendChild(label);
                if (Array.isArray(meta.componentRouteIds) && meta.componentRouteIds.length) {
                    const idList = meta.componentRouteIds.join(', ');
                    item.title = meta.componentRouteIds.length > 1
                        ? `Includes routes ${idList}`
                        : `Route ${idList}`;
                }
                item.addEventListener('pointerenter', () => applyHighlight(new Set([meta.id])));
                item.addEventListener('pointerleave', () => clearHighlight());
                item.addEventListener('focus', () => applyHighlight(new Set([meta.id])));
                item.addEventListener('blur', () => clearHighlight());
                fragment.appendChild(item);
            });

            legendList.appendChild(fragment);
        }

        function pointsToPath(points) {
            if (!points.length) {
                return '';
            }
            return points
                .map((p, index) => `${index === 0 ? 'M' : 'L'}${p.x.toFixed(2)} ${p.y.toFixed(2)}`)
                .join(' ');
        }

        function scheduleScaleUpdate() {
            if (state.scaleUpdatePending) {
                return;
            }
            state.scaleUpdatePending = true;
            requestAnimationFrame(() => {
                state.scaleUpdatePending = false;
                updateScale();
            });
        }

        function updateScale() {
            const svg = document.getElementById('schematic');
            const rect = svg.getBoundingClientRect();
            if (!rect.width || !rect.height || !state.viewBox) {
                return;
            }
            const unitPerPx = state.viewBox.width / rect.width;
            updateBundlePaths(unitPerPx);
            updateStopAppearance(unitPerPx);
            updateTermini(unitPerPx);
        }

        function updateBundlePaths(unitPerPx) {
            const spacing = (ROUTE_LINE_WIDTH_PX + ROUTE_GAP_PX) * unitPerPx;
            const minLegLength = SNAP_MIN_SEGMENT_LENGTH * unitPerPx;
            const tolerance = 0.5 * unitPerPx;

            state.bundleChains.forEach((chain) => {
                if (!chain || !Array.isArray(chain.skeleton) || chain.skeleton.length < 2) {
                    chain?.members?.forEach((member) => {
                        const item = state.routePathLookup.get(`${member.routeId}-${chain.id}`);
                        if (item) {
                            item.offsetPoints = [];
                            item.pathElement.setAttribute('d', '');
                        }
                    });
                    if (chain?.casingElement) {
                        chain.casingElement.setAttribute('d', '');
                    }
                    return;
                }

                const skeletonPath = pointsToPath(chain.skeleton);
                if (chain.casingElement) {
                    chain.casingElement.setAttribute('d', skeletonPath);
                }

                prepareChainGeometry(chain);

                const offsets = [];
                const memberCount = chain.members.length;
                let attempts = 0;
                let needsRetry = false;
                do {
                    offsets.length = 0;
                    needsRetry = false;
                    for (let i = 0; i < memberCount; i++) {
                        const offsetDistance = (i - (memberCount - 1) / 2) * spacing;
                        const offsetPoints = computeOffsetPolylineForChain(chain, offsetDistance);
                        offsets.push(offsetPoints);
                    }
                    const shortIndex = findShortInteriorVertex(offsets, minLegLength);
                    if (shortIndex !== null && removeIntermediateVertex(chain, shortIndex)) {
                        prepareChainGeometry(chain);
                        needsRetry = true;
                    }
                    attempts++;
                } while (needsRetry && attempts < 5);

                chain.members.forEach((member, index) => {
                    const key = `${member.routeId}-${chain.id}`;
                    const item = state.routePathLookup.get(key);
                    if (!item) {
                        return;
                    }
                    const offsetPoints = offsets[index] || [];
                    item.offsetPoints = offsetPoints;
                    const d = pointsToPath(offsetPoints);
                    item.pathElement.setAttribute('d', d);
                });

                validateChainGeometry(chain, offsets, spacing, tolerance);
            });
        }

        function prepareChainGeometry(chain) {
            if (!chain || !Array.isArray(chain.skeleton) || chain.skeleton.length < 2) {
                chain.segmentData = [];
                return;
            }
            const skeleton = chain.skeleton;
            let baseNormal = chain.baseNormal;
            if (!baseNormal || (!isFinite(baseNormal.x) && !isFinite(baseNormal.y))) {
                baseNormal = computeInitialChainNormal(skeleton);
                chain.baseNormal = baseNormal;
            }
            baseNormal = normalizeVector(baseNormal);
            const segments = [];
            let lastNormal = null;
            let lastDir = null;
            for (let i = 0; i < skeleton.length - 1; i++) {
                const a = skeleton[i];
                const b = skeleton[i + 1];
                const dx = b.x - a.x;
                const dy = b.y - a.y;
                const length = Math.hypot(dx, dy);
                if (length < 1e-6) {
                    segments.push({ dir: { x: 0, y: 0 }, normal: lastNormal ?? baseNormal, length: 0 });
                    continue;
                }
                const dir = { x: dx / length, y: dy / length };
                let normal = { x: -dir.y, y: dir.x };
                if (!lastNormal) {
                    if (dotProduct(normal, baseNormal) < 0) {
                        normal.x *= -1;
                        normal.y *= -1;
                    }
                } else {
                    const dirDot = dotProduct(lastDir, dir);
                    if (dirDot < -0.999) {
                        normal = { ...lastNormal };
                    } else if (dotProduct(lastNormal, normal) < 0) {
                        normal.x *= -1;
                        normal.y *= -1;
                    }
                }
                const normalized = normalizeVector(normal);
                segments.push({ dir, normal: normalized, length });
                lastNormal = normalized;
                lastDir = dir;
            }
            chain.segmentData = segments;
        }

        function computeOffsetPolylineForChain(chain, offsetDistance) {
            if (!chain || !Array.isArray(chain.skeleton) || chain.skeleton.length < 2) {
                return [];
            }
            const skeleton = chain.skeleton;
            const segments = chain.segmentData || [];
            const result = [];
            for (let i = 0; i < skeleton.length; i++) {
                const point = skeleton[i];
                if (i === 0) {
                    const baseNormal = segments[0]?.normal ?? chain.baseNormal;
                    const normal = ensureNormal(baseNormal);
                    result.push({ x: point.x + normal.x * offsetDistance, y: point.y + normal.y * offsetDistance });
                    continue;
                }
                if (i === skeleton.length - 1) {
                    const baseNormal = segments[segments.length - 1]?.normal ?? chain.baseNormal;
                    const normal = ensureNormal(baseNormal);
                    result.push({ x: point.x + normal.x * offsetDistance, y: point.y + normal.y * offsetDistance });
                    continue;
                }
                const prevSegment = segments[i - 1];
                const nextSegment = segments[i];
                if (!prevSegment || !nextSegment) {
                    const baseNormal = prevSegment?.normal ?? nextSegment?.normal ?? chain.baseNormal;
                    const normal = ensureNormal(baseNormal);
                    result.push({ x: point.x + normal.x * offsetDistance, y: point.y + normal.y * offsetDistance });
                    continue;
                }
                const dir0 = prevSegment.dir;
                const dir1 = nextSegment.dir;
                const normal0 = prevSegment.normal;
                const normal1 = nextSegment.normal;
                const cross = dir0.x * dir1.y - dir0.y * dir1.x;
                const dot = clamp(dotProduct(dir0, dir1), -1, 1);
                const angle = Math.atan2(cross, dot);
                const absAngle = Math.abs(angle);
                if (absAngle < 1e-3) {
                    const sum = { x: normal0.x + normal1.x, y: normal0.y + normal1.y };
                    const normalized = normalizeVector(sum);
                    const chosen = (Math.abs(normalized.x) > 1e-6 || Math.abs(normalized.y) > 1e-6) ? normalized : ensureNormal(normal0);
                    result.push({ x: point.x + chosen.x * offsetDistance, y: point.y + chosen.y * offsetDistance });
                    continue;
                }
                const sinHalf = Math.sin(absAngle / 2) || 1e-6;
                const miterLength = offsetDistance / sinHalf;
                const limit = Math.abs(offsetDistance) * 4;
                if (Math.abs(miterLength) > limit) {
                    const sum = { x: normal0.x + normal1.x, y: normal0.y + normal1.y };
                    const normalized = normalizeVector(sum);
                    const chosen = (Math.abs(normalized.x) > 1e-6 || Math.abs(normalized.y) > 1e-6) ? normalized : ensureNormal(normal0);
                    result.push({ x: point.x + chosen.x * offsetDistance, y: point.y + chosen.y * offsetDistance });
                    continue;
                }
                const line1Point = { x: point.x + normal0.x * offsetDistance, y: point.y + normal0.y * offsetDistance };
                const line2Point = { x: point.x + normal1.x * offsetDistance, y: point.y + normal1.y * offsetDistance };
                const intersection = intersectLines(line1Point, dir0, line2Point, dir1);
                if (intersection) {
                    result.push(intersection);
                } else {
                    const sum = { x: normal0.x + normal1.x, y: normal0.y + normal1.y };
                    const normalized = normalizeVector(sum);
                    const chosen = (Math.abs(normalized.x) > 1e-6 || Math.abs(normalized.y) > 1e-6) ? normalized : ensureNormal(normal0);
                    result.push({ x: point.x + chosen.x * offsetDistance, y: point.y + chosen.y * offsetDistance });
                }
            }
            return result;
        }

        function findShortInteriorVertex(polylines, minLength) {
            if (!Array.isArray(polylines) || !polylines.length) {
                return null;
            }
            const reference = polylines[0];
            if (!Array.isArray(reference) || reference.length < 3) {
                return null;
            }
            const minSq = minLength * minLength;
            const count = reference.length;
            for (let index = 1; index < count - 1; index++) {
                for (const poly of polylines) {
                    if (!poly || poly.length !== count) {
                        return null;
                    }
                    const prev = poly[index - 1];
                    const curr = poly[index];
                    const next = poly[index + 1];
                    if (!prev || !curr || !next) {
                        continue;
                    }
                    if (distanceSquared(prev, curr) < minSq || distanceSquared(curr, next) < minSq) {
                        return index;
                    }
                }
            }
            return null;
        }

        function removeIntermediateVertex(chain, index) {
            if (!chain || !Array.isArray(chain.skeleton)) {
                return false;
            }
            if (index <= 0 || index >= chain.skeleton.length - 1) {
                return false;
            }
            chain.skeleton.splice(index, 1);
            if (chain.skeleton.length < 2) {
                return false;
            }
            const merged = mergeCollinear(chain.skeleton);
            chain.skeleton.length = 0;
            merged.forEach((point) => chain.skeleton.push(point));
            return true;
        }

        function validateChainGeometry(chain, polylines, spacing, tolerance) {
            if (!Array.isArray(polylines) || !polylines.length) {
                return;
            }
            const seenPaths = new Set();
            polylines.forEach((poly, index) => {
                if (!poly) {
                    return;
                }
                if (polylineHasSelfIntersection(poly)) {
                    console.assert(false, `Self-intersection detected on chain ${chain.id} member ${index}`);
                }
                const key = poly.map((p) => `${p.x.toFixed(3)},${p.y.toFixed(3)}`).join('|');
                console.assert(!seenPaths.has(key), `Duplicate geometry detected on chain ${chain.id}`);
                seenPaths.add(key);
            });

            for (let i = 0; i < polylines.length - 1; i++) {
                const current = polylines[i];
                const next = polylines[i + 1];
                if (!current || !next) {
                    continue;
                }
                const count = Math.min(current.length, next.length);
                for (let j = 0; j < count; j++) {
                    const a = current[j];
                    const b = next[j];
                    if (!a || !b) {
                        continue;
                    }
                    const distance = Math.hypot(b.x - a.x, b.y - a.y);
                    console.assert(Math.abs(distance - spacing) <= tolerance + 1e-3, `Inconsistent spacing on chain ${chain.id}`);
                }
            }
        }

        function polylineHasSelfIntersection(points) {
            if (!Array.isArray(points) || points.length < 4) {
                return false;
            }
            for (let i = 0; i < points.length - 1; i++) {
                const a1 = points[i];
                const a2 = points[i + 1];
                for (let j = i + 2; j < points.length - 1; j++) {
                    if (i === 0 && j === points.length - 2) {
                        continue;
                    }
                    const b1 = points[j];
                    const b2 = points[j + 1];
                    if (segmentsIntersect(a1, a2, b1, b2)) {
                        return true;
                    }
                }
            }
            return false;
        }

        function segmentsIntersect(a1, a2, b1, b2) {
            const denom = (a2.x - a1.x) * (b2.y - b1.y) - (a2.y - a1.y) * (b2.x - b1.x);
            if (Math.abs(denom) < 1e-6) {
                return false;
            }
            const ua = ((b1.x - a1.x) * (b2.y - b1.y) - (b1.y - a1.y) * (b2.x - b1.x)) / denom;
            const ub = ((b1.x - a1.x) * (a2.y - a1.y) - (b1.y - a1.y) * (a2.x - a1.x)) / denom;
            return ua > 1e-4 && ua < 1 - 1e-4 && ub > 1e-4 && ub < 1 - 1e-4;
        }

        function intersectLines(point, dir, otherPoint, otherDir) {
            const cross = dir.x * otherDir.y - dir.y * otherDir.x;
            if (Math.abs(cross) < 1e-6) {
                return null;
            }
            const diff = { x: otherPoint.x - point.x, y: otherPoint.y - point.y };
            const t = (diff.x * otherDir.y - diff.y * otherDir.x) / cross;
            return { x: point.x + dir.x * t, y: point.y + dir.y * t };
        }

        function dotProduct(a, b) {
            if (!a || !b) {
                return 0;
            }
            return a.x * b.x + a.y * b.y;
        }

        function ensureNormal(normal) {
            if (!normal) {
                return { x: 0, y: -1 };
            }
            const length = Math.hypot(normal.x, normal.y);
            if (length < 1e-6) {
                return { x: 0, y: -1 };
            }
            return { x: normal.x / length, y: normal.y / length };
        }

        function updateStopAppearance(unitPerPx) {
            const radius = STOP_RADIUS_PX * unitPerPx;
            state.stopElements.forEach(({ element }) => {
                element.setAttribute('r', radius.toString());
            });
            const minDistanceSq = Math.pow(8 * unitPerPx, 2);
            for (let i = 0; i < state.stopElements.length; i++) {
                const a = state.stopElements[i].stop.position;
                for (let j = i + 1; j < state.stopElements.length; j++) {
                    const b = state.stopElements[j].stop.position;
                    if (!a || !b) {
                        continue;
                    }
                    if (distanceSquared(a, b) < minDistanceSq) {
                        console.assert(false, `Stops ${state.stopElements[i].stop.id} and ${state.stopElements[j].stop.id} are within 8px.`);
                    }
                }
            }
        }

        function computeTermini(graph) {
            const routeNodeCounts = new Map();
            for (const edge of graph.edges) {
                for (const routeId of edge.routes) {
                    let nodeMap = routeNodeCounts.get(routeId);
                    if (!nodeMap) {
                        nodeMap = new Map();
                        routeNodeCounts.set(routeId, nodeMap);
                    }
                    nodeMap.set(edge.start, (nodeMap.get(edge.start) || 0) + 1);
                    nodeMap.set(edge.end, (nodeMap.get(edge.end) || 0) + 1);
                }
            }
            const termini = [];
            routeNodeCounts.forEach((nodeMap, routeId) => {
                nodeMap.forEach((count, nodeId) => {
                    if (count !== 1) {
                        return;
                    }
                    const edge = graph.edges.find((candidate) => candidate.routes.has(routeId) && (candidate.start === nodeId || candidate.end === nodeId));
                    if (!edge) {
                        return;
                    }
                    const chainId = edge.chainId;
                    let atStart = true;
                    if (typeof chainId === 'number') {
                        const chain = state.bundleChains[chainId];
                        if (chain && Array.isArray(chain.nodes) && chain.nodes.length) {
                            const firstNode = chain.nodes[0];
                            const lastNode = chain.nodes[chain.nodes.length - 1];
                            if (nodeId === lastNode) {
                                atStart = false;
                            } else if (nodeId !== firstNode) {
                                const nodePoint = state.graph.nodes[nodeId];
                                const startPoint = state.graph.nodes[firstNode];
                                const endPoint = state.graph.nodes[lastNode];
                                if (nodePoint && startPoint && endPoint) {
                                    const distToStart = Math.hypot(nodePoint.x - startPoint.x, nodePoint.y - startPoint.y);
                                    const distToEnd = Math.hypot(nodePoint.x - endPoint.x, nodePoint.y - endPoint.y);
                                    atStart = distToStart <= distToEnd;
                                }
                            }
                        }
                    }
                    termini.push({ routeId, nodeId, chainId, atStart });
                });
            });
            return termini;
        }

        function updateTermini(unitPerPx) {
            const length = TERMINUS_TICK_PX * unitPerPx;
            state.terminusElements.forEach((term) => {
                const chain = typeof term.chainId === 'number' ? state.bundleChains[term.chainId] : null;
                if (!chain || !Array.isArray(chain.skeleton) || chain.skeleton.length < 2) {
                    term.element.setAttribute('d', '');
                    return;
                }
                const skeleton = chain.skeleton;
                const nodeIndex = term.atStart ? 0 : skeleton.length - 1;
                const neighborIndex = term.atStart ? Math.min(1, skeleton.length - 1) : Math.max(skeleton.length - 2, 0);
                const nodePoint = skeleton[nodeIndex];
                const neighbor = skeleton[neighborIndex];
                if (!nodePoint || !neighbor || nodeIndex === neighborIndex) {
                    term.element.setAttribute('d', '');
                    return;
                }
                const dir = { x: nodePoint.x - neighbor.x, y: nodePoint.y - neighbor.y };
                const magnitude = Math.hypot(dir.x, dir.y);
                if (magnitude < 1e-6) {
                    term.element.setAttribute('d', '');
                    return;
                }
                const scale = length / magnitude;
                const endPoint = { x: nodePoint.x + dir.x * scale, y: nodePoint.y + dir.y * scale };
                term.element.setAttribute('d', `M${nodePoint.x.toFixed(2)} ${nodePoint.y.toFixed(2)} L${endPoint.x.toFixed(2)} ${endPoint.y.toFixed(2)}`);
            });
        }

        function attachPanZoom(svg) {
            let isPanning = false;
            let panStart = null;
            let viewBoxStart = null;

            svg.addEventListener('pointerdown', (event) => {
                if (event.button !== 0) {
                    return;
                }
                isPanning = true;
                panStart = { x: event.clientX, y: event.clientY };
                viewBoxStart = { ...state.viewBox };
                svg.setPointerCapture(event.pointerId);
            });

            svg.addEventListener('pointermove', (event) => {
                if (!isPanning || !viewBoxStart) {
                    return;
                }
                const rect = svg.getBoundingClientRect();
                const unitPerPx = state.viewBox.width / rect.width;
                const dx = (event.clientX - panStart.x) * unitPerPx;
                const dy = (event.clientY - panStart.y) * unitPerPx;
                const nextView = {
                    ...state.viewBox,
                    x: viewBoxStart.x - dx,
                    y: viewBoxStart.y - dy
                };
                setViewBox(nextView);
            });

            svg.addEventListener('pointerup', (event) => {
                if (!isPanning) return;
                isPanning = false;
                svg.releasePointerCapture(event.pointerId);
            });

            svg.addEventListener('pointerleave', () => {
                isPanning = false;
            });

            svg.addEventListener('wheel', (event) => {
                event.preventDefault();
                if (!state.viewBox) return;
                const rect = svg.getBoundingClientRect();
                const pointX = (event.clientX - rect.left) / rect.width;
                const pointY = (event.clientY - rect.top) / rect.height;
                const zoomFactor = event.deltaY > 0 ? 1.1 : 0.9;
                const aspect = state.baseViewBox.width / state.baseViewBox.height;
                const newWidth = clamp(state.viewBox.width * zoomFactor, state.baseViewBox.width * 0.15, state.baseViewBox.width * 3);
                const newHeight = newWidth / aspect;
                const newX = state.viewBox.x + (state.viewBox.width - newWidth) * pointX;
                const newY = state.viewBox.y + (state.viewBox.height - newHeight) * pointY;
                setViewBox({ x: newX, y: newY, width: newWidth, height: newHeight });
            }, { passive: false });
        }

        function clamp(value, min, max) {
            return Math.min(Math.max(value, min), max);
        }

        function setViewBox(box) {
            const svg = document.getElementById('schematic');
            if (!svg) return;
            state.viewBox = { ...box };
            const aspect = state.baseViewBox.width / state.baseViewBox.height;
            state.viewBox.height = state.viewBox.width / aspect;
            svg.setAttribute('viewBox', `${state.viewBox.x} ${state.viewBox.y} ${state.viewBox.width} ${state.viewBox.height}`);
            scheduleScaleUpdate();
        }

        function applyHighlight(routeIds) {
            const sorted = Array.from(routeIds, (id) => String(id)).sort((a, b) => a.localeCompare(b));
            const key = sorted.join(',');
            if (key === state.activeHighlightKey) {
                return;
            }
            state.activeHighlightKey = key;
            const highlightSet = new Set(sorted);

            state.routePaths.forEach((item) => {
                const element = item.pathElement;
                const routeKey = String(item.routeId);
                if (highlightSet.has(routeKey)) {
                    element.classList.add('is-highlight');
                    element.classList.remove('is-dim');
                } else {
                    element.classList.add('is-dim');
                    element.classList.remove('is-highlight');
                }
            });

            state.stopElements.forEach(({ stop, element }) => {
                const matches = stop.routeIds.some((id) => highlightSet.has(String(id)));
                if (matches) {
                    element.classList.add('is-highlight');
                    element.classList.remove('is-dim');
                } else {
                    element.classList.add('is-dim');
                    element.classList.remove('is-highlight');
                }
            });

            document.querySelectorAll('.legend-item').forEach((item) => {
                const routeKey = item.dataset.route;
                if (routeKey && highlightSet.has(routeKey)) {
                    item.classList.add('is-highlight');
                    item.classList.remove('is-dim');
                } else {
                    item.classList.add('is-dim');
                    item.classList.remove('is-highlight');
                }
            });
        }

        function clearHighlight() {
            if (state.activeHighlightKey === null) {
                return;
            }
            state.activeHighlightKey = null;
            state.routePaths.forEach((item) => {
                item.pathElement.classList.remove('is-highlight', 'is-dim');
            });
            state.stopElements.forEach(({ element }) => {
                element.classList.remove('is-highlight', 'is-dim');
            });
            document.querySelectorAll('.legend-item').forEach((item) => {
                item.classList.remove('is-highlight', 'is-dim');
            });
        }

        const tooltipEl = document.getElementById('tooltip');
        const mapContainer = document.querySelector('.map-container');

        function showStopTooltip(stop, event) {
            tooltipEl.innerHTML = '';
            tooltipEl.classList.add('visible');
            tooltipEl.setAttribute('aria-hidden', 'false');

            const title = document.createElement('div');
            title.className = 'title';
            title.textContent = stop.name;
            tooltipEl.appendChild(title);

            const routes = document.createElement('div');
            routes.textContent = stop.routeIds
                .map((routeId) => {
                    const meta = state.routeMeta.get(routeId);
                    if (!meta) {
                        return `Route ${routeId}`;
                    }
                    const ids = Array.isArray(meta.componentRouteIds) ? meta.componentRouteIds : [];
                    if (ids.length > 1) {
                        return `${meta.name} (${ids.join(', ')})`;
                    }
                    if (ids.length === 1) {
                        return `${meta.name} (${ids[0]})`;
                    }
                    return meta.name;
                })
                .join(', ');
            tooltipEl.appendChild(routes);

            updateTooltipPosition(event);
        }

        function updateTooltipPosition(event) {
            if (!tooltipEl.classList.contains('visible')) {
                return;
            }
            const rect = mapContainer.getBoundingClientRect();
            const offsetX = event.clientX - rect.left;
            const offsetY = event.clientY - rect.top - 20;
            tooltipEl.style.left = `${offsetX}px`;
            tooltipEl.style.top = `${offsetY}px`;
        }

        function hideTooltip() {
            tooltipEl.classList.remove('visible');
            tooltipEl.setAttribute('aria-hidden', 'true');
        }

        initialize();
    </script>
</body>
</html>
