<!DOCTYPE html>
<html>
  <head>
    <title>Live Map - Headway Guard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@mapbox/polyline@1.1.1"></script>
    <script src="https://unpkg.com/rbush@3.0.1/rbush.min.js"></script>
    <style>
      .custom-popup {
        position: absolute;
        background: #232D4B;
        border: 4px solid white;
        border-radius: 15px;
        padding: 10px;
        pointer-events: auto;
        transform: translate(-50%, -100%);
        white-space: nowrap;
        z-index: 1000;
        color: white;
        text-transform: uppercase;
      }
      .custom-popup-arrow {
        position: absolute;
        left: 50%;
        bottom: -10px;
        width: 0;
        height: 0;
        border-left: 10px solid transparent;
        border-right: 10px solid transparent;
        border-top: 10px solid white;
        transform: translateX(-50%);
      }
      .custom-popup-close {
        position: absolute;
        bottom: 5px;
        right: 5px;
        cursor: pointer;
        background: #f00;
        color: #fff;
        border: none;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        line-height: 20px;
        text-align: center;
        font-size: 14px;
      }
      .route-pill {
        display: inline-block;
        padding: 5px 10px;
        border-radius: 20px;
        color: white;
        font-weight: bold;
        margin-top: 10px;
        text-align: center;
        border: 2px solid #FFFFFF;
      }
      @font-face {
        font-family: 'FGDC';
        src: url('FGDC.ttf') format('truetype');
      }
      body, .custom-popup {
        font-family: 'FGDC', sans-serif;
        font-size: 14px;
      }
      #map {
        height: 100%;
        width: 100%;
      }
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
      }
      /* Route Selector styling */
      #routeSelector {
        width: 300px;
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 1100;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px;
        border-radius: 5px;
        max-height: 90vh;
        overflow-y: auto;
        transition: transform 0.3s ease;
		font-size: 21px;
      }
      #routeSelector.hidden {
        transform: translateX(320px);
      }
      #routeSelector h3 {
        margin-top: 0;
      }
      /* Updated button styles for route selector (including speed toggle) */
      #routeSelector button {
        margin: 5px 2px;
        padding: 5px 10px;
        font-size: 24px;
        font-family: 'FGDC', sans-serif;
        background-color: #E57200;
        color: black;
        border: none;
        border-radius: 20px;
        cursor: pointer;
      }
      #routeSelector label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
      }
      #routeSelector .color-box {
        display: inline-block;
        width: 12px;
        height: 12px;
        margin-right: 5px;
        vertical-align: middle;
      }
      /* Tab styling */
      #routeSelectorTab {
        position: fixed;
        top: 50%;
        right: 0;
        width: 30px;
        height: 60px;
        background: #ccc;
        border-top-left-radius: 10px;
        border-bottom-left-radius: 10px;
        cursor: pointer;
        display: block;
        transform: translateY(-50%);
        z-index: 1150;
        text-align: center;
        line-height: 60px;
        font-size: 20px;
        user-select: none;
        transition: right 0.3s ease;
      }
      #routeLegend {
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 1100;
        background: rgba(255, 255, 255, 0.9);
        padding: 12px 16px;
        border-radius: 8px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        max-width: 320px;
        display: none;
        font-size: 20px;
      }
      #routeLegend .legend-title {
        font-weight: bold;
        margin-bottom: 8px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      #routeLegend .legend-item {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 8px;
      }
      #routeLegend .legend-item:last-child {
        margin-bottom: 0;
      }
      #routeLegend .legend-color {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 2px solid #FFFFFF;
        box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.1);
        flex-shrink: 0;
      }
      #routeLegend .legend-text {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      #routeLegend .legend-name {
        font-weight: bold;
      }
      #routeLegend .legend-description {
        font-size: 16px;
        color: #1b1b1b;
      }
      @media (max-width: 600px) {
        #routeSelector { width: 80%; right: 10%; font-size: 18px; }
        #routeSelector.hidden { transform: translateX(calc(100% + 20px)); }
        #routeSelector button { font-size: 20px; }
        #routeSelector label { font-size: 18px; }
        #routeSelectorTab { width: 40px; height: 80px; font-size: 28px; }
      }
      .credit{position:fixed;bottom:8px;right:8px;font-size:12px;color:var(--muted,#9fb0c9);}
      .cookie-banner{position:fixed;bottom:0;left:0;right:0;background:rgba(0,0,0,0.8);color:white;padding:10px;text-align:center;font-size:14px;z-index:1200;}
      .cookie-banner button{margin-left:10px;}
    </style>
    <script>
      // Manually set these variables.
      // adminMode: true for admin view (with speed/block bubbles and unit numbers).
      //            Can be disabled via URL param `adminMode=false`.
      //            In public mode (adminMode=false) the route selector is still shown
      //            but only for routes that are public-facing.
      // kioskMode: true to hide the route selector/tab and suppress vehicle overlays for a public display.
      // adminKioskMode: true to hide the route selector/tab while retaining admin overlays (previous kiosk behavior).
      // showSpeed/showBlockNumbers: only one may be true at a time.
      let adminMode = true; // shows unit numbers and speed/block bubbles
      let kioskMode = false;
      let adminKioskMode = false;
      let showSpeed = false; // default to showing block numbers
      let showBlockNumbers = true;

      const enableOverlapDashRendering = true;

      const params = new URLSearchParams(window.location.search);
      const kioskParam = params.get('kioskMode');
      if (kioskParam !== null) {
        kioskMode = kioskParam.toLowerCase() === 'true';
      }
      const adminKioskParam = params.get('adminKioskMode');
      if (adminKioskParam !== null) {
        adminKioskMode = adminKioskParam.toLowerCase() === 'true';
      }
      const adminParam = params.get('adminMode');
      if (adminParam !== null) {
        adminMode = adminParam.toLowerCase() === 'true';
      }
      
      const outOfServiceRouteColor = '#000000';
      
      let map;
      let markers = {};
      let routeColors = {};
      let routeLayers = [];
      let stopMarkers = [];
      let nameBubbles = {};
      let busBlocks = {};
      let previousBusData = {};
      let cachedEtas = {};
      let customPopups = [];
      let allRouteBounds = null;
      let mapHasFitAllRoutes = false;
      let refreshIntervals = [];

      let overlapRenderer = null;

      let agencies = [];
      let baseURL = '';

      async function loadAgencies() {
        try {
          const response = await fetch('https://admin.ridesystems.net/api/Clients/GetClients');
          const contentType = response.headers.get('content-type') || '';
          let clients = [];
          if (contentType.includes('application/json')) {
            clients = await response.json();
          } else {
            const text = await response.text();
            const parser = new DOMParser();
            const xml = parser.parseFromString(text, 'application/xml');
            clients = Array.from(xml.getElementsByTagName('Client')).map(c => ({
              Name: c.getElementsByTagName('Name')[0]?.textContent.trim(),
              WebAddress: c.getElementsByTagName('WebAddress')[0]?.textContent.trim()
            }));
          }
          agencies = clients.map(c => {
            const name = c.Name?.trim();
            const webAddress = c.WebAddress?.trim();
            if (!name || !webAddress) return null;
            const url = webAddress.startsWith('http')
              ? webAddress.replace(/^http:\/\//i, 'https://')
              : `https://${webAddress}`;
            return { name, url };
          }).filter(Boolean);
          agencies.sort((a, b) => a.name.localeCompare(b.name));
          const uvaIndex = agencies.findIndex(a => a.name === 'University of Virginia');
          if (uvaIndex > -1) {
            const uva = agencies.splice(uvaIndex, 1)[0];
            agencies.unshift(uva);
          }
          const consent = localStorage.getItem('agencyConsent') === 'true';
          const storedAgency = consent ? localStorage.getItem('selectedAgency') : null;
          if (storedAgency && agencies.some(a => a.url === storedAgency)) {
            baseURL = storedAgency;
          } else {
            baseURL = agencies[0]?.url || '';
          }
          updateRouteSelector(activeRoutes, true);
        } catch (e) {
          console.error('Failed to load agencies', e);
        }
      }

      function positionRouteTab() {
        const panel = document.getElementById("routeSelector");
        const tab = document.getElementById("routeSelectorTab");
        if (!panel || !tab) return;
        const panelStyle = window.getComputedStyle(panel);
        const gap = parseFloat(panelStyle.right) || 0;
        const offset = panel.offsetWidth + gap;
        tab.style.right = panel.classList.contains("hidden") ? "0" : offset + "px";
      }

      window.addEventListener("load", positionRouteTab);
      window.addEventListener("resize", positionRouteTab);

      // Global storage for routes from GetRoutes.
      let allRoutes = {};
      // Global object to store user selections (for admin mode).
      let routeSelections = {};
      // Tracks routes that currently have at least one vehicle assigned.
      let activeRoutes = new Set();
      // Tracks which routes the API designates as public-facing.
      let routeVisibility = {};

      // Routes default to visible if they currently have vehicles unless the user
      // overrides the selection via the route selector.
      function isRouteSelected(routeID) {
        if (!canDisplayRoute(routeID)) return false;
        const id = Number(routeID);
        if (Number.isNaN(id)) return false;
        if (routeSelections.hasOwnProperty(id)) return routeSelections[id];
        return activeRoutes.has(id);
      }

      function setRouteVisibility(route) {
        if (!route || typeof route.RouteID === 'undefined') return;
        const id = Number(route.RouteID);
        if (Number.isNaN(id)) return;
        routeVisibility[id] = route.IsVisibleOnMap !== false;
      }

      function isRoutePublicById(routeID) {
        const id = Number(routeID);
        if (Number.isNaN(id) || id === 0) return false;
        if (Object.prototype.hasOwnProperty.call(routeVisibility, id)) {
          return routeVisibility[id];
        }
        return true;
      }

      function canDisplayRoute(routeID) {
        const id = Number(routeID);
        if (Number.isNaN(id)) return false;
        if (id === 0) {
          return adminKioskMode || (!kioskMode && adminMode);
        }
        if (adminKioskMode) return true;
        if (kioskMode) return isRoutePublicById(id);
        if (adminMode) return true;
        return isRoutePublicById(id);
      }

      // Toggle between displaying speed or block numbers.
      function toggleSpeedOrBlock() {
        if (showSpeed) {
          showSpeed = false;
          showBlockNumbers = true;
        } else {
          showSpeed = true;
          showBlockNumbers = false;
        }
        document.getElementById("toggleDisplayButton").innerHTML = showSpeed ? "Show Block Numbers" : "Show Speed";
        refreshMap();
      }

      // updateRouteSelector rebuilds the route selector panel.
      // The list (excluding Out of Service) is alphabetized and defaults to
      // checking only routes that currently have vehicles.
      function updateRouteSelector(activeRoutes, forceUpdate = false) {
        const container = document.getElementById("routeSelector");
        if (!container) return;
        // If the agency dropdown is currently focused (open), skip rebuilding
        // the selector to avoid closing the dropdown.
        const agencyDropdown = document.getElementById('agencySelect');
        if (!forceUpdate && agencyDropdown && document.activeElement === agencyDropdown) {
          return;
        }
        let html = "";
        html += "<label for='agencySelect'>Select System:</label>";
        html += "<select id='agencySelect' onchange='changeAgency(this.value)'>";
        agencies.forEach(a => {
          html += `<option value="${a.url}" ${a.url === baseURL ? 'selected' : ''}>${a.name}</option>`;
        });
        html += "</select><br/><br/>";
        if (adminMode) {
          // Add the speed/block toggle button in admin mode only.
          html += "<div style='margin-bottom:10px;'><button id='toggleDisplayButton' onclick='toggleSpeedOrBlock()'>" + (showSpeed ? "Show Block Numbers" : "Show Speed") + "</button></div>";
        }
        html += "<h3>Select Routes</h3>" +
          "<button onclick='selectAllRoutes()'>Select All</button>" +
          "<button onclick='deselectAllRoutes()'>Deselect All</button><br/><br/>";

        if (adminMode && canDisplayRoute(0)) {
          // Add Out of Service option (routeID 0) at the top for admin mode.
          let outChecked = routeSelections.hasOwnProperty(0) ? routeSelections[0] : activeRoutes.has(0);
          html += `<label>
            <input type="checkbox" id="route_0" value="0" ${outChecked ? "checked" : ""}>
            <span class="color-box" style="background:${outOfServiceRouteColor};"></span> Out of Service
          </label>`;
        }

        // Get an array of route IDs (excluding 0) from allRoutes.
        let routeIDs = Object.keys(allRoutes)
          .map(id => Number(id))
          .filter(id => !Number.isNaN(id) && id !== 0 && canDisplayRoute(id));
        // Sort alphabetically by route Description (case-insensitive).
        routeIDs.sort((a, b) => {
          let descA = allRoutes[a].Description.toUpperCase();
          let descB = allRoutes[b].Description.toUpperCase();
          if (descA < descB) return -1;
          if (descA > descB) return 1;
          return 0;
        });
        // Append sorted routes.
        routeIDs.forEach(routeID => {
          let route = allRoutes[routeID];
          let checked = routeSelections.hasOwnProperty(routeID) ? routeSelections[routeID] : activeRoutes.has(routeID);
          let displayName = route.Description;
          if (route.InfoText && route.InfoText.trim() !== "") {
            displayName += ` &ndash; ${route.InfoText.trim()}`;
          }
          html += `<label>
            <input type="checkbox" id="route_${routeID}" value="${routeID}" ${checked ? "checked" : ""}>
            <span class="color-box" style="background:${route.MapLineColor};"></span> ${displayName}
          </label>`;
        });
        container.innerHTML = html;
        // Attach event listeners to update routeSelections.
        let outChk = document.getElementById("route_0");
        if (outChk) {
          outChk.addEventListener("change", function() {
            routeSelections[0] = outChk.checked;
            refreshMap();
          });
        }
        routeIDs.forEach(routeID => {
          if (!canDisplayRoute(routeID) || Number(routeID) === 0) return;
          let chk = document.getElementById("route_" + routeID);
          if (chk) {
            chk.addEventListener("change", function() {
              routeSelections[routeID] = chk.checked;
              refreshMap();
            });
          }
        });
      }

      function selectAllRoutes() {
        if (adminMode && canDisplayRoute(0)) {
          let outChk = document.getElementById("route_0");
          if (outChk) outChk.checked = true;
          routeSelections[0] = true;
        }
        for (let routeID in allRoutes) {
          if (!canDisplayRoute(routeID) || Number(routeID) === 0) continue;
          let chk = document.getElementById("route_" + routeID);
          if (chk) chk.checked = true;
          routeSelections[routeID] = true;
        }
        refreshMap();
      }

      function deselectAllRoutes() {
        if (adminMode && canDisplayRoute(0)) {
          let outChk = document.getElementById("route_0");
          if (outChk) outChk.checked = false;
          routeSelections[0] = false;
        }
        for (let routeID in allRoutes) {
          if (!canDisplayRoute(routeID) || Number(routeID) === 0) continue;
          let chk = document.getElementById("route_" + routeID);
          if (chk) chk.checked = false;
          routeSelections[routeID] = false;
        }
        refreshMap();
      }

      // togglePanel toggles the route selector panel's visibility.
      function togglePanel() {
        let panel = document.getElementById("routeSelector");
        let tab = document.getElementById("routeSelectorTab");
        if (panel.classList.contains("hidden")) {
          panel.classList.remove("hidden");
          tab.innerHTML = "&#9664;"; // left arrow
        } else {
          panel.classList.add("hidden");
          tab.innerHTML = "&#9654;"; // right arrow
        }
        positionRouteTab();
      }

      function updateRouteLegend(displayedRoutes = []) {
        const legend = document.getElementById("routeLegend");
        if (!legend) return;
        const shouldShowLegend = kioskMode || adminKioskMode;
        if (!shouldShowLegend) {
          legend.style.display = "none";
          legend.innerHTML = "";
          return;
        }

        // Admin kiosk mode should surface every visible route, including those hidden from the public map.
        // Public kiosk mode must continue to hide routes flagged as non-public.
        const routesToRender = adminKioskMode
          ? displayedRoutes
          : displayedRoutes.filter(route => isRoutePublicById(route.routeId ?? route.routeID ?? route.id));

        if (routesToRender.length === 0) {
          legend.style.display = "none";
          legend.innerHTML = "";
          return;
        }

        legend.style.display = "block";
        legend.innerHTML = "";

        const title = document.createElement("div");
        title.className = "legend-title";
        title.textContent = "Routes";
        legend.appendChild(title);

        routesToRender.forEach(route => {
          const item = document.createElement("div");
          item.className = "legend-item";

          const color = document.createElement("span");
          color.className = "legend-color";
          color.style.backgroundColor = route.color || "#000000";
          item.appendChild(color);

          const textContainer = document.createElement("div");
          textContainer.className = "legend-text";

          const name = document.createElement("div");
          name.className = "legend-name";
          name.textContent = route.name;
          textContainer.appendChild(name);

          if (route.description) {
            const description = document.createElement("div");
            description.className = "legend-description";
            description.textContent = route.description;
            textContainer.appendChild(description);
          }

          item.appendChild(textContainer);
          legend.appendChild(item);
        });
      }

      // refreshMap updates route paths and bus locations.
      function refreshMap() {
        fetchBusLocations().then(fetchRoutePaths);
      }

      function clearRefreshIntervals() {
        refreshIntervals.forEach(clearInterval);
        refreshIntervals = [];
      }

      function startRefreshIntervals() {
        refreshIntervals.push(setInterval(fetchBusLocations, 4000));
        refreshIntervals.push(setInterval(fetchBusStops, 60000));
        refreshIntervals.push(setInterval(fetchBlockAssignments, 60000));
        refreshIntervals.push(setInterval(() => {
          fetchStopArrivalTimes().then(allEtas => {
            cachedEtas = allEtas;
            updateCustomPopups();
          });
        }, 15000));
        refreshIntervals.push(setInterval(fetchRoutePaths, 15000));
      }

      function showCookieBanner() {
        if (kioskMode || adminKioskMode) {
          return;
        }
        if (localStorage.getItem('agencyConsent') !== 'true') {
          const banner = document.getElementById('cookieBanner');
          banner.style.display = 'block';
          document.getElementById('cookieAccept').addEventListener('click', () => {
            localStorage.setItem('agencyConsent', 'true');
            localStorage.setItem('selectedAgency', baseURL);
            banner.style.display = 'none';
          });
        }
      }

      function changeAgency(url) {
        if (localStorage.getItem('agencyConsent') === 'true') {
          localStorage.setItem('selectedAgency', url);
        }
        clearRefreshIntervals();
        baseURL = url;
        Object.values(markers).forEach(m => map.removeLayer(m));
        markers = {};
        Object.values(nameBubbles).forEach(b => {
          if (b.speedMarker) map.removeLayer(b.speedMarker);
          if (b.nameMarker) map.removeLayer(b.nameMarker);
          if (b.blockMarker) map.removeLayer(b.blockMarker);
        });
        nameBubbles = {};
        stopMarkers.forEach(m => map.removeLayer(m));
        stopMarkers = [];
        routeLayers.forEach(l => map.removeLayer(l));
        routeLayers = [];
        if (overlapRenderer) {
          overlapRenderer.reset();
        }
        busBlocks = {};
        previousBusData = {};
        cachedEtas = {};
        customPopups.forEach(p => p.remove());
        customPopups = [];
        allRoutes = {};
        routeSelections = {};
        activeRoutes = new Set();
        routeColors = {};
        routeVisibility = {};
        allRouteBounds = null;
        mapHasFitAllRoutes = false;
        updateRouteLegend([]);
        updateRouteSelector(new Set(), true);
        fetchRouteColors().then(() => {
          fetchBusStops();
          fetchBlockAssignments();
          fetchBusLocations().then(fetchRoutePaths);
          fetchStopArrivalTimes().then(allEtas => { cachedEtas = allEtas; updateCustomPopups(); });
          startRefreshIntervals();
        });
      }

      function getRouteColor(routeID) {
        if (routeID === 0) return outOfServiceRouteColor;
        return routeColors[routeID] || '#000000';
      }

      function initMap() {
          map = L.map('map', { zoomControl: false }).setView([38.03799212281404, -78.50981502838886], 15);
          const cartoLight = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
              attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>'
          });
          cartoLight.addTo(map);

          if (enableOverlapDashRendering) {
            overlapRenderer = new OverlapRouteRenderer(map, {
              sampleStepPx: 8,
              dashLengthPx: 16,
              minDashLengthPx: 0.5,
              matchTolerancePx: 6,
              strokeWeight: 6
            });
            map.on('zoomend', () => {
              if (overlapRenderer) {
                overlapRenderer.handleZoomEnd();
              }
            });
          }

          fetchRouteColors().then(() => {
              if (kioskMode || adminKioskMode) {
                document.getElementById("routeSelector").style.display = "none";
                document.getElementById("routeSelectorTab").style.display = "none";
              }
              fetchStopArrivalTimes().then(allEtas => {
                  cachedEtas = allEtas;
                  updateCustomPopups();
              });
              fetchBusStops();
              fetchBlockAssignments();
              fetchBusLocations().then(fetchRoutePaths);
              startRefreshIntervals();
          });
          fetchStopArrivalTimes().then(allEtas => { cachedEtas = allEtas; });
          map.on('move', updatePopupPositions);
          map.on('zoom', updatePopupPositions);
      }

      function fetchBusStops() {
          const currentBaseURL = baseURL;
          const stopsApiUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetStops?APIKey=8882812681`;
          fetch(stopsApiUrl)
              .then(response => response.json())
              .then(data => {
                  if (currentBaseURL !== baseURL) return;
                  let stopsArray = data.stops || data;
                  if (stopsArray && Array.isArray(stopsArray)) {
                      stopMarkers.forEach(marker => map.removeLayer(marker));
                      stopMarkers = [];
                      const groupedStops = {};
                      stopsArray.forEach(stop => {
                          const key = `${stop.Latitude},${stop.Longitude}`;
                          if (!groupedStops[key]) groupedStops[key] = [];
                          groupedStops[key].push(stop);
                      });
                      Object.keys(groupedStops).forEach(key => {
                          const [latitude, longitude] = key.split(',').map(Number);
                          const stopPosition = [latitude, longitude];
                          const stopMarker = L.circleMarker(stopPosition, {
                              radius: 6,
                              color: "#000000",
                              fillColor: "#FFFFFF",
                              fillOpacity: 1,
                              weight: 3
                          }).addTo(map);
                          const routeStopIds = groupedStops[key].map(stop => stop.RouteStopID);
                          const unifiedStopId = groupedStops[key][0].StopID || groupedStops[key][0].StopId;
                          const etas = [];
                          routeStopIds.forEach(routeStopId => {
                              if (cachedEtas[routeStopId]) {
                                  cachedEtas[routeStopId].forEach(eta => etas.push(eta));
                              }
                          });
                          const stopNames = groupedStops[key][0].Description;
                          const etaText = etas.length > 0
                            ? etas.sort((a, b) => a.etaMinutes - b.etaMinutes || a.routeDescription.localeCompare(b.routeDescription))
                                  .map(eta => `<tr><td style="padding: 5px; text-align: center;"><div class="route-pill" style="background-color: ${getRouteColor(eta.RouteId)}; color: ${getContrastColor(getRouteColor(eta.RouteId))};">${eta.routeDescription}</div></td><td style="padding: 5px; text-align: center;">${eta.etaMinutes < 1 ? 'Arriving' : eta.etaMinutes + ' min'}</td></tr>`).join('')
                            : '<tr><td colspan="2" style="padding: 5px; text-align: center;">No upcoming arrivals</td></tr>';
                          stopMarker.on('click', () => {
                              createCustomPopup(stopPosition, stopNames, etaText, routeStopIds, unifiedStopId);
                          });
                          stopMarkers.push(stopMarker);
                      });
                      stopMarkers.forEach(marker => marker.bringToFront());
                  }
              })
              .catch(error => console.error("Error fetching bus stops:", error));
      }

      function createCustomPopup(position, stopName, etaText, routeStopIds, stopId) {
          customPopups.forEach(popup => popup.remove());
          customPopups = [];
          const popupElement = document.createElement('div');
          popupElement.className = 'custom-popup';
          const etaTable = `
            <table style="width: 100%; margin-top: 10px; border-collapse: collapse;">
              <thead>
                <tr>
                  <th style="border-bottom: 1px solid white; padding: 5px;">Route</th>
                  <th style="border-bottom: 1px solid white; padding: 5px;">ETA</th>
                </tr>
              </thead>
              <tbody>
                ${etaText}
              </tbody>
            </table>
          `;
          popupElement.innerHTML = `
            <button class="custom-popup-close">&times;</button>
            <span style="font-size: 16px; font-weight: bold;">${stopName}</span><br>
            <span>Stop ID: ${stopId}</span><br>
            ${etaTable}
            <div class="custom-popup-arrow"></div>
          `;
          document.body.appendChild(popupElement);
          popupElement.dataset.position = `${position[0]},${position[1]}`;
          popupElement.dataset.stopName = stopName.replace('Stop Name: ', '');
          popupElement.dataset.routeStopIds = JSON.stringify(routeStopIds);
          popupElement.dataset.stopId = stopId;
          updatePopupPosition(popupElement, position);
          popupElement.querySelector('.custom-popup-close').addEventListener('click', () => {
              popupElement.remove();
              customPopups = customPopups.filter(popup => popup !== popupElement);
          });
          customPopups.push(popupElement);
      }

      function updatePopupPosition(popupElement, position) {
          const mapPos = map.latLngToContainerPoint(position);
          popupElement.style.left = `${mapPos.x}px`;
          popupElement.style.top = `${mapPos.y}px`;
      }

      function updatePopupPositions() {
          customPopups.forEach(popupElement => {
              const position = popupElement.dataset.position;
              if (position) {
                  const [latitude, longitude] = position.split(',').map(Number);
                  updatePopupPosition(popupElement, [latitude, longitude]);
              }
          });
      }

      function updateCustomPopups() {
          customPopups.forEach(popupElement => {
              const position = popupElement.dataset.position;
              if (position) {
                  const routeStopIds = JSON.parse(popupElement.dataset.routeStopIds);
                  const etas = [];
                  routeStopIds.forEach(routeStopId => {
                      if (cachedEtas[routeStopId]) {
                          cachedEtas[routeStopId].forEach(eta => etas.push(eta));
                      }
                  });
                  const etaText = etas.length > 0
                    ? etas.sort((a, b) => a.etaMinutes - b.etaMinutes || a.routeDescription.localeCompare(b.routeDescription))
                          .map(eta => `<tr><td style="padding: 5px; text-align: center;"><div class="route-pill" style="background-color: ${getRouteColor(eta.RouteId)}; color: ${getContrastColor(getRouteColor(eta.RouteId))};">${eta.routeDescription}</div></td><td style="padding: 5px; text-align: center;">${eta.etaMinutes < 1 ? 'Arriving' : eta.etaMinutes + ' min'}</td></tr>`).join('')
                    : '<tr><td colspan="2" style="padding: 5px; text-align: center;">No upcoming arrivals</td></tr>';
                  const etaTable = `
                    <table style="width: 100%; margin-top: 10px; border-collapse: collapse;">
                      <thead>
                        <tr>
                          <th style="border-bottom: 1px solid white; padding: 5px;">Route</th>
                          <th style="border-bottom: 1px solid white; padding: 5px;">ETA</th>
                        </tr>
                      </thead>
                      <tbody>
                        ${etaText}
                      </tbody>
                    </table>
                  `;
                  const stopId = popupElement.dataset.stopId;
                  popupElement.innerHTML = `
                    <button class="custom-popup-close">&times;</button>
                    <span style="font-size: 16px; font-weight: bold;">${popupElement.dataset.stopName}</span><br>
                    <span>Stop ID: ${stopId}</span><br>
                    ${etaTable}
                    <div class="custom-popup-arrow"></div>
                  `;
                  popupElement.querySelector('.custom-popup-close').addEventListener('click', () => {
                      popupElement.remove();
                      customPopups = customPopups.filter(popup => popup !== popupElement);
                  });
              }
          });
      }

      function fetchStopArrivalTimes() {
          const currentBaseURL = baseURL;
          const arrivalTimesApiUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetStopArrivalTimes?APIKey=8882812681`;
          return fetch(arrivalTimesApiUrl)
              .then(response => response.json())
              .then(data => {
                  if (currentBaseURL !== baseURL) return {};
                  let allEtas = {};
                  data.forEach(arrival => {
                      if (!allEtas[arrival.RouteStopId]) {
                          allEtas[arrival.RouteStopId] = [];
                      }
                      arrival.Times.forEach(time => {
                          const etaMinutes = Math.round(time.Seconds / 60);
                          allEtas[arrival.RouteStopId].push({
                              routeDescription: (arrival.RouteDescription === 'Night Pilot' ? arrival.RouteDescription : arrival.RouteDescription.slice(0, -5)),
                              etaMinutes: etaMinutes,
                              RouteId: arrival.RouteId
                          });
                      });
                  });
                  return allEtas;
              })
              .catch(error => {
                  console.error("Error fetching stop arrival times:", error);
                  return {};
              });
      }

      class OverlapRouteRenderer {
        constructor(map, options = {}) {
          this.map = map;
          this.options = Object.assign({
            sampleStepPx: 8,
            dashLengthPx: 16,
            minDashLengthPx: 0.5,
            matchTolerancePx: 6,
            headingToleranceDeg: 20,
            simplifyTolerancePx: 0.75,
            latLngEqualityMargin: 1e-9,
            strokeWeight: 6,
            nodeKeyPrecisionPx: 1,
            minEndGapRatio: 0.25,
            confettiThresholdRatio: 0.5
          }, options);
          const defaultCorridorConfig = {
            enabled: true,
            mergeDistanceM: 8,
            tMerge: 6,
            tSplit: 10,
            windowM: 50,
            minCorridorLenM: 100,
            coverageThreshold: 0.8,
            sampleStepM: 10,
            headingToleranceDeg: 10
          };
          const userCorridorConfig = options.corridorConfig || {};
          const normalizedCorridorConfig = {};
          Object.keys(userCorridorConfig).forEach(key => {
            const value = userCorridorConfig[key];
            switch (key) {
              case 'merge_distance_m':
                normalizedCorridorConfig.mergeDistanceM = value;
                break;
              case 't_merge':
                normalizedCorridorConfig.tMerge = value;
                break;
              case 't_split':
                normalizedCorridorConfig.tSplit = value;
                break;
              case 'window_m':
                normalizedCorridorConfig.windowM = value;
                break;
              case 'min_corridor_len_m':
                normalizedCorridorConfig.minCorridorLenM = value;
                break;
              case 'coverage_threshold':
              case 'percent_coverage_threshold':
                normalizedCorridorConfig.coverageThreshold = value;
                break;
              default:
                normalizedCorridorConfig[key] = value;
                break;
            }
          });
          this.corridorConfig = Object.assign({}, defaultCorridorConfig, normalizedCorridorConfig);
          this.layers = [];
          this.routeGeometries = new Map();
          this.selectedRoutes = [];
          this.currentZoom = map.getZoom();
          this.corridorCacheKey = null;
          this.corridorData = { segments: [], routeMasks: new Map() };
        }

        reset() {
          this.clearLayers();
          this.routeGeometries.clear();
          this.selectedRoutes = [];
          this.corridorCacheKey = null;
          this.corridorData = { segments: [], routeMasks: new Map() };
        }

        clearLayers() {
          this.layers.forEach(layer => {
            if (layer && this.map.hasLayer(layer)) {
              this.map.removeLayer(layer);
            }
          });
          this.layers = [];
        }

        updateRoutes(routeGeometryMap, selectedRouteIds) {
          if (!Array.isArray(selectedRouteIds) || selectedRouteIds.length === 0) {
            this.reset();
            return this.getLayers();
          }

          const geometryEntries = routeGeometryMap instanceof Map
            ? Array.from(routeGeometryMap.entries())
            : Object.entries(routeGeometryMap || {});

          const geometries = new Map();
          const numericIds = selectedRouteIds
            .map(id => Number(id))
            .filter(id => !Number.isNaN(id));

          const idSet = new Set(numericIds);
          geometryEntries.forEach(([key, value]) => {
            const numericKey = Number(key);
            if (!Number.isNaN(numericKey) && idSet.has(numericKey) && Array.isArray(value)) {
              geometries.set(numericKey, value);
            }
          });

          this.routeGeometries = geometries;
          this.selectedRoutes = Array.from(this.routeGeometries.keys()).sort((a, b) => a - b);
          this.currentZoom = this.map.getZoom();
          this.render();
          return this.getLayers();
        }

        handleZoomEnd() {
          if (this.routeGeometries.size === 0 || this.selectedRoutes.length === 0) return;
          const zoom = this.map.getZoom();
          if (zoom === this.currentZoom) return;
          this.currentZoom = zoom;
          this.render();
        }

        getLayers() {
          return this.layers.slice();
        }

        buildCorridorCacheKey() {
          const ids = this.selectedRoutes.slice().sort((a, b) => a - b).join(',');
          const cfg = this.corridorConfig || {};
          const cfgKey = [
            cfg.mergeDistanceM,
            cfg.tMerge,
            cfg.tSplit,
            cfg.windowM,
            cfg.minCorridorLenM,
            cfg.coverageThreshold,
            cfg.sampleStepM,
            cfg.headingToleranceDeg
          ].join('|');
          return `${this.currentZoom}:${ids}:${cfgKey}`;
        }

        getCorridorData() {
          const key = this.buildCorridorCacheKey();
          if (this.corridorCacheKey === key && this.corridorData) {
            return this.corridorData;
          }
          const data = this.computeCorridorData();
          this.corridorCacheKey = key;
          this.corridorData = data;
          return data;
        }

        computeCorridorData() {
          const result = { segments: [], routeMasks: new Map() };
          if (!this.corridorConfig || this.selectedRoutes.length < 2) {
            return result;
          }

          const samplesByRoute = new Map();
          this.selectedRoutes.forEach(routeId => {
            const latlngs = this.routeGeometries.get(routeId);
            if (!latlngs || latlngs.length < 2) return;
            const samples = this.sampleRouteForCorridor(latlngs);
            if (samples.length > 1) {
              samplesByRoute.set(routeId, samples);
            }
          });

          const segments = [];
          for (let i = 0; i < this.selectedRoutes.length; i++) {
            const routeA = this.selectedRoutes[i];
            const samplesA = samplesByRoute.get(routeA);
            if (!samplesA) continue;
            for (let j = i + 1; j < this.selectedRoutes.length; j++) {
              const routeB = this.selectedRoutes[j];
              const samplesB = samplesByRoute.get(routeB);
              if (!samplesB) continue;
              const pairSegments = this.findCorridorSegmentsForPair(routeA, samplesA, routeB, samplesB);
              pairSegments.forEach(segment => {
                segment.id = `corridor_${segments.length}`;
                segments.push(segment);
                segment.memberRoutes.forEach(routeId => {
                  const interval = segment.routeIntervals.get(routeId);
                  if (!interval) return;
                  const masks = result.routeMasks.get(routeId) || [];
                  masks.push({
                    start: Math.min(interval.startMeters, interval.endMeters),
                    end: Math.max(interval.startMeters, interval.endMeters)
                  });
                  result.routeMasks.set(routeId, masks);
                });
              });
            }
          }

          result.segments = segments;
          result.routeMasks.forEach((intervals, routeId) => {
            result.routeMasks.set(routeId, this.mergeIntervals(intervals));
          });

          return result;
        }

        makeNodeKey(point) {
          const precision = Math.max(0.1, this.options.nodeKeyPrecisionPx || 1);
          const factor = 1 / precision;
          const x = Math.round((point.x || 0) * factor) / factor;
          const y = Math.round((point.y || 0) * factor) / factor;
          return `${x.toFixed(3)}:${y.toFixed(3)}`;
        }

        registerNode(nodeMap, endpoint, routes, segment, role) {
          if (!endpoint) return null;
          const point = endpoint.point || this.map.project(endpoint.latlng, this.currentZoom);
          const latlng = endpoint.latlng;
          const key = this.makeNodeKey(point);
          let node = nodeMap.get(key);
          if (!node) {
            node = {
              sumX: 0,
              sumY: 0,
              sumLat: 0,
              sumLng: 0,
              count: 0,
              routes: new Set(),
              segments: new Set()
            };
            nodeMap.set(key, node);
          }
          node.sumX += point.x;
          node.sumY += point.y;
          node.sumLat += latlng.lat;
          node.sumLng += latlng.lng;
          node.count += 1;
          if (Array.isArray(routes)) {
            routes.forEach(routeId => node.routes.add(routeId));
          }
          if (segment && segment.id != null) {
            node.segments.add(segment.id);
          }
          if (segment) {
            if (role === 'start') {
              segment.startNodeKey = key;
            } else if (role === 'end') {
              segment.endNodeKey = key;
            }
          }
          return key;
        }

        uniqueLatLngSequence(points) {
          if (!Array.isArray(points)) return [];
          const result = [];
          points.forEach(pt => {
            if (!pt) return;
            if (result.length === 0 || !this.latLngEquals(result[result.length - 1], pt)) {
              result.push(pt);
            }
          });
          return result;
        }

        routeSetsEqual(a, b) {
          if (!Array.isArray(a) || !Array.isArray(b)) return false;
          if (a.length !== b.length) return false;
          for (let i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) return false;
          }
          return true;
        }

        hasSegmentGap(a, b) {
          if (!a || !b) return true;
          const endMeters = a.end && a.end.cumulativeMeters;
          const startMeters = b.start && b.start.cumulativeMeters;
          if (endMeters != null && startMeters != null) {
            if (Math.abs(startMeters - endMeters) > 1e-3) {
              return true;
            }
          }
          const endLatLng = a.end && a.end.latlng;
          const startLatLng = b.start && b.start.latlng;
          if (endLatLng && startLatLng) {
            const distance = this.latLngDistance(endLatLng, startLatLng);
            if (distance > 0.75) {
              return true;
            }
          }
          return false;
        }

        buildJunctionNodes(resampledByRoute, segments) {
          const nodeMap = new Map();

          resampledByRoute.forEach((resampled) => {
            const routeSegments = (resampled && resampled.segments) ? resampled.segments : [];
            if (!Array.isArray(routeSegments) || routeSegments.length === 0) return;

            let previous = null;
            for (let i = 0; i < routeSegments.length; i++) {
              const segment = routeSegments[i];
              if (!segment || !Array.isArray(segment.sharedRoutes) || segment.sharedRoutes.length === 0) continue;

              const startRoutes = new Set(segment.sharedRoutes);
              if (previous && Array.isArray(previous.sharedRoutes)) {
                previous.sharedRoutes.forEach(r => startRoutes.add(r));
              }

              const needsStartNode = !previous || !this.routeSetsEqual(previous.sharedRoutes, segment.sharedRoutes) || this.hasSegmentGap(previous, segment);
              if (needsStartNode) {
                this.registerNode(nodeMap, segment.start, Array.from(startRoutes), segment, 'start');
              } else if (previous && previous.endNodeKey) {
                segment.startNodeKey = previous.endNodeKey;
              }

              const next = routeSegments[i + 1];
              const endRoutes = new Set(segment.sharedRoutes);
              if (next && Array.isArray(next.sharedRoutes)) {
                next.sharedRoutes.forEach(r => endRoutes.add(r));
              }
              const needsEndNode = !next || !this.routeSetsEqual(segment.sharedRoutes, next.sharedRoutes) || this.hasSegmentGap(segment, next);
              if (needsEndNode) {
                this.registerNode(nodeMap, segment.end, Array.from(endRoutes), segment, 'end');
              }

              previous = segment;
            }
          });

          segments.forEach(segment => {
            if (!segment) return;
            if (!segment.startNodeKey) {
              this.registerNode(nodeMap, segment.start, segment.sharedRoutes || [], segment, 'start');
            }
            if (!segment.endNodeKey) {
              this.registerNode(nodeMap, segment.end, segment.sharedRoutes || [], segment, 'end');
            }
          });

          const nodes = new Map();
          nodeMap.forEach((value, key) => {
            const count = value.count || 1;
            const point = L.point(value.sumX / count, value.sumY / count);
            const latlng = L.latLng(value.sumLat / count, value.sumLng / count);
            nodes.set(key, Object.assign(value, { key, point, latlng }));
          });

          segments.forEach(segment => {
            if (!segment) return;
            const startNode = nodes.get(segment.startNodeKey);
            if (startNode) {
              segment.start.point = startNode.point;
              segment.start.latlng = startNode.latlng;
            }
            const endNode = nodes.get(segment.endNodeKey);
            if (endNode) {
              segment.end.point = endNode.point;
              segment.end.latlng = endNode.latlng;
            }
            segment.lengthPx = this.distance(segment.start.point, segment.end.point);
            segment.lengthMeters = this.latLngDistance(segment.start.latlng, segment.end.latlng);
          });

          return { nodes };
        }

        mergeIntervals(intervals) {
          if (!Array.isArray(intervals) || intervals.length === 0) return [];
          const sorted = intervals.slice().sort((a, b) => (a.start || 0) - (b.start || 0));
          const merged = [];
          sorted.forEach(interval => {
            if (!interval) return;
            const start = interval.start != null ? interval.start : interval[0];
            const end = interval.end != null ? interval.end : interval[1];
            if (start == null || end == null) return;
            if (merged.length === 0) {
              merged.push({ start, end });
            } else {
              const last = merged[merged.length - 1];
              if (start <= last.end) {
                last.end = Math.max(last.end, end);
              } else {
                merged.push({ start, end });
              }
            }
          });
          return merged;
        }

        sampleRouteForCorridor(latlngs) {
          if (!Array.isArray(latlngs) || latlngs.length < 2) return [];
          const step = Math.max(1, this.corridorConfig.sampleStepM || 10);
          const crs = (this.map && this.map.options && this.map.options.crs) || L.CRS.EPSG3857;
          const projected = latlngs.map(latlng => ({
            latlng,
            point: crs.project(latlng)
          }));

          const samples = [];
          samples.push({
            latlng: projected[0].latlng,
            point: projected[0].point,
            cumulativeMeters: 0
          });

          let totalMeters = 0;
          let nextSample = step;

          for (let i = 1; i < projected.length; i++) {
            const prev = projected[i - 1];
            const curr = projected[i];
            const segLength = this.distance(prev.point, curr.point);
            if (segLength === 0) continue;

            while (nextSample <= totalMeters + segLength) {
              const ratio = (nextSample - totalMeters) / segLength;
              const point = this.interpolatePoint(prev.point, curr.point, ratio);
              const latlng = this.interpolateLatLng(prev.latlng, curr.latlng, ratio);
              samples.push({
                latlng,
                point,
                cumulativeMeters: nextSample
              });
              nextSample += step;
            }

            totalMeters += segLength;
          }

          const last = projected[projected.length - 1];
          const tail = samples[samples.length - 1];
          if (!this.latLngEquals(tail.latlng, last.latlng)) {
            samples.push({
              latlng: last.latlng,
              point: last.point,
              cumulativeMeters: totalMeters
            });
          } else {
            tail.cumulativeMeters = totalMeters;
          }

          for (let i = 0; i < samples.length; i++) {
            if (i < samples.length - 1) {
              const next = samples[i + 1];
              samples[i].heading = Math.atan2(next.point.y - samples[i].point.y, next.point.x - samples[i].point.x);
            } else if (samples.length > 1) {
              samples[i].heading = samples[i - 1].heading;
            } else {
              samples[i].heading = 0;
            }
          }

          return samples;
        }

        findCorridorSegmentsForPair(routeA, samplesA, routeB, samplesB) {
          const results = [];
          const toleranceRad = ((this.corridorConfig.headingToleranceDeg || 10) * Math.PI) / 180;
          const maxDistance = Math.max(this.corridorConfig.tSplit || 10, this.corridorConfig.mergeDistanceM || 8) * 2;
          const searchRadius = maxDistance;
          const items = samplesB.map((sample, index) => ({
            minX: sample.point.x - searchRadius,
            minY: sample.point.y - searchRadius,
            maxX: sample.point.x + searchRadius,
            maxY: sample.point.y + searchRadius,
            index
          }));
          const tree = new RBush();
          tree.load(items);

          const matches = new Array(samplesA.length).fill(null);

          samplesA.forEach((sampleA, idx) => {
            const bounds = {
              minX: sampleA.point.x - searchRadius,
              minY: sampleA.point.y - searchRadius,
              maxX: sampleA.point.x + searchRadius,
              maxY: sampleA.point.y + searchRadius
            };
            const candidates = tree.search(bounds) || [];
            let bestIndex = null;
            let bestDistance = Infinity;
            candidates.forEach(candidate => {
              const sampleB = samplesB[candidate.index];
              if (!sampleB) return;
              const distance = this.distance(sampleA.point, sampleB.point);
              if (!(distance <= maxDistance)) return;
              const headingDiff = this.smallestHeadingDifference(sampleA.heading || 0, sampleB.heading || 0);
              const antiParallelDiff = Math.abs(Math.PI - headingDiff);
              if (antiParallelDiff <= toleranceRad && distance < bestDistance) {
                bestDistance = distance;
                bestIndex = candidate.index;
              }
            });
            if (bestIndex != null) {
              matches[idx] = { index: bestIndex, distance: bestDistance };
            }
          });

          const coverageThreshold = this.corridorConfig.coverageThreshold || 0.8;
          const windowCount = Math.max(2, Math.round((this.corridorConfig.windowM || 50) / (this.corridorConfig.sampleStepM || 10)));
          const tMerge = this.corridorConfig.tMerge || 6;
          const tSplit = this.corridorConfig.tSplit || 10;
          const minLen = this.corridorConfig.minCorridorLenM || 100;

          const prefixMatch = new Array(samplesA.length + 1).fill(0);
          const prefixDistance = new Array(samplesA.length + 1).fill(0);
          for (let i = 0; i < samplesA.length; i++) {
            const match = matches[i];
            prefixMatch[i + 1] = prefixMatch[i] + (match ? 1 : 0);
            prefixDistance[i + 1] = prefixDistance[i] + (match ? match.distance : 0);
          }

          const classification = new Array(samplesA.length).fill('UNKNOWN');
          for (let i = 0; i < samplesA.length; i++) {
            const end = i;
            const start = Math.max(0, end - windowCount + 1);
            const total = end - start + 1;
            if (total <= 0) continue;
            const matchCount = prefixMatch[end + 1] - prefixMatch[start];
            if (matchCount === 0) continue;
            const coverage = matchCount / total;
            if (coverage < coverageThreshold) continue;
            const meanDistance = (prefixDistance[end + 1] - prefixDistance[start]) / matchCount;
            if (meanDistance <= tMerge) {
              classification[i] = 'MERGE';
            } else if (meanDistance >= tSplit) {
              classification[i] = 'SPLIT';
            } else {
              classification[i] = 'NEUTRAL';
            }
          }

          let state = 'SEPARATE';
          let mergeMeters = 0;
          let splitMeters = 0;
          let runStart = null;
          let splitStart = null;
          let current = null;

          for (let i = 0; i < samplesA.length; i++) {
            const label = classification[i];
            const stepMeters = i === 0 ? 0 : Math.max(0, samplesA[i].cumulativeMeters - samplesA[i - 1].cumulativeMeters);

            if (state === 'SEPARATE') {
              if (label === 'MERGE') {
                if (runStart == null) runStart = i > 0 ? i - 1 : 0;
                mergeMeters += stepMeters;
                if (mergeMeters >= minLen) {
                  current = {
                    memberRoutes: [routeA, routeB],
                    routeIntervals: new Map(),
                    startIndex: runStart
                  };
                  state = 'MERGED';
                  splitMeters = 0;
                  splitStart = null;
                }
              } else {
                runStart = null;
                mergeMeters = 0;
              }
            } else if (state === 'MERGED') {
              if (label === 'SPLIT') {
                if (splitStart == null) splitStart = i;
                splitMeters += stepMeters;
                if (splitMeters >= minLen && current) {
                  current.endIndex = Math.max(current.startIndex, splitStart - 1);
                  results.push(current);
                  current = null;
                  state = 'SEPARATE';
                  mergeMeters = 0;
                  splitMeters = 0;
                  runStart = null;
                  splitStart = null;
                }
              } else if (label === 'MERGE') {
                splitMeters = 0;
                splitStart = null;
              }
            }
          }

          if (state === 'MERGED' && current) {
            current.endIndex = samplesA.length - 1;
            results.push(current);
          }

          const refined = [];
          results.forEach(segment => {
            const startIdx = Math.max(0, Math.min(segment.startIndex || 0, segment.endIndex || 0));
            const endIdx = Math.max(startIdx + 1, segment.endIndex || startIdx + 1);
            const matchedPairs = [];
            for (let i = startIdx; i <= endIdx; i++) {
              const match = matches[i];
              if (match) {
                matchedPairs.push({ aIndex: i, bIndex: match.index, distance: match.distance });
              }
            }
            if (matchedPairs.length < 2) return;

            const centerline = [];
            const memberRoutes = [routeA, routeB].slice().sort((a, b) => a - b);
            const bIndices = [];
            matchedPairs.forEach(pair => {
              const sampleA = samplesA[pair.aIndex];
              const sampleB = samplesB[pair.bIndex];
              if (!sampleA || !sampleB) return;
              const point = L.point(
                (sampleA.point.x + sampleB.point.x) / 2,
                (sampleA.point.y + sampleB.point.y) / 2
              );
              const latlng = this.interpolateLatLng(sampleA.latlng, sampleB.latlng, 0.5);
              if (centerline.length === 0 || !this.latLngEquals(centerline[centerline.length - 1], latlng)) {
                centerline.push(latlng);
              }
              bIndices.push(pair.bIndex);
            });

            if (centerline.length < 2) return;

            const startMetersA = samplesA[startIdx].cumulativeMeters;
            const endMetersA = samplesA[endIdx].cumulativeMeters;
            const sortedB = bIndices.sort((a, b) => a - b);
            const startIdxB = sortedB[0];
            const endIdxB = sortedB[sortedB.length - 1];
            const startMetersB = samplesB[startIdxB].cumulativeMeters;
            const endMetersB = samplesB[endIdxB].cumulativeMeters;

            const corridorSegment = {
              id: '',
              memberRoutes,
              centerline,
              routeIntervals: new Map([
                [routeA, { startMeters: startMetersA, endMeters: endMetersA, startIndex: startIdx, endIndex: endIdx }],
                [routeB, { startMeters: startMetersB, endMeters: endMetersB, startIndex: startIdxB, endIndex: endIdxB }]
              ])
            };

            refined.push(corridorSegment);
          });

          return refined;
        }

        resampleCorridorSegments(corridorData, zoom, step) {
          const result = new Map();
          if (!corridorData || !Array.isArray(corridorData.segments)) {
            return result;
          }

          corridorData.segments.forEach(segment => {
            if (!segment || !Array.isArray(segment.centerline) || segment.centerline.length < 2) return;
            const corridorId = segment.id || `corridor_${Math.random().toString(36).slice(2)}`;
            const resampled = this.resampleRoute(corridorId, segment.centerline, zoom, step, []);
            if (!resampled || !Array.isArray(resampled.segments) || resampled.segments.length === 0) return;
            resampled.segments.forEach(seg => {
              seg.routeId = corridorId;
              seg.lockedSharedRoutes = segment.memberRoutes ? segment.memberRoutes.slice() : [];
              seg.sharedRoutes = seg.lockedSharedRoutes.slice();
              seg.key = seg.sharedRoutes.join('|');
              seg.primaryRoute = corridorId;
            });
            result.set(corridorId, resampled);
          });

          return result;
        }


        render() {
          this.clearLayers();
          if (this.selectedRoutes.length === 0) return;

          const zoom = this.currentZoom;
          const step = Math.max(2, this.options.sampleStepPx);
          const tolerance = this.options.matchTolerancePx;
          const headingToleranceRad = (this.options.headingToleranceDeg * Math.PI) / 180;

          const corridorData = this.corridorConfig.enabled
            ? this.getCorridorData()
            : { segments: [], routeMasks: new Map() };
          this.corridorData = corridorData;

          const resampledByRoute = new Map();
          const allSegments = [];
          const treeItems = [];
          let segmentCounter = 0;

          this.selectedRoutes.forEach(routeId => {
            const latlngs = this.routeGeometries.get(routeId);
            if (!latlngs || latlngs.length < 2) {
              resampledByRoute.set(routeId, { points: [], segments: [] });
              return;
            }

            const maskIntervals = corridorData.routeMasks.get(routeId) || [];
            const resampled = this.resampleRoute(routeId, latlngs, zoom, step, maskIntervals);
            resampledByRoute.set(routeId, resampled);
            if (!resampled || !Array.isArray(resampled.segments) || resampled.segments.length === 0) {
              return;
            }

            resampled.segments.forEach(segment => {
              segment.id = `seg_${segmentCounter++}`;
              allSegments.push(segment);
              treeItems.push({
                minX: segment.bounds.minX,
                minY: segment.bounds.minY,
                maxX: segment.bounds.maxX,
                maxY: segment.bounds.maxY,
                segment
              });
            });
          });

          if (allSegments.length > 0) {
            const tree = new RBush();
            tree.load(treeItems);

            allSegments.forEach(segment => {
              const searchBounds = {
                minX: segment.bounds.minX - tolerance,
                minY: segment.bounds.minY - tolerance,
                maxX: segment.bounds.maxX + tolerance,
                maxY: segment.bounds.maxY + tolerance
              };
              const candidates = tree.search(searchBounds) || [];
              const sharedRoutes = new Set([segment.routeId]);

              candidates.forEach(candidate => {
                const other = candidate.segment;
                if (!other || other === segment) return;
                if (this.segmentsOverlap(segment, other, tolerance, headingToleranceRad)) {
                  sharedRoutes.add(other.routeId);
                }
              });

              segment.sharedRoutes = Array.from(sharedRoutes).sort((a, b) => a - b);
              segment.key = segment.sharedRoutes.join('|');
              segment.primaryRoute = segment.sharedRoutes[0];
            });
          }

          const combinedSegments = allSegments.slice();
          const corridorResampled = this.resampleCorridorSegments(corridorData, zoom, step);
          corridorResampled.forEach((resampled, corridorId) => {
            if (!resampled || !Array.isArray(resampled.segments) || resampled.segments.length === 0) {
              return;
            }
            resampled.segments.forEach(segment => {
              segment.id = `seg_${segmentCounter++}`;
              if (Array.isArray(segment.lockedSharedRoutes) && segment.lockedSharedRoutes.length > 0) {
                segment.sharedRoutes = segment.lockedSharedRoutes.slice();
                segment.key = segment.sharedRoutes.join('|');
              }
              segment.primaryRoute = corridorId;
              combinedSegments.push(segment);
            });
            resampledByRoute.set(corridorId, resampled);
          });

          if (combinedSegments.length === 0) return;

          const nodeData = this.buildJunctionNodes(resampledByRoute, combinedSegments);
          const groups = this.buildGroups(resampledByRoute);
          this.drawGroups(groups);
        }

        buildGroups(resampledByRoute) {
          const groups = [];
          resampledByRoute.forEach((resampled, routeId) => {
            const routeSegments = (resampled && resampled.segments) ? resampled.segments : [];
            if (!Array.isArray(routeSegments) || routeSegments.length === 0) return;

            let currentGroup = null;
            let lastKey = null;

            routeSegments.forEach(segment => {
              if (!segment || !Array.isArray(segment.sharedRoutes) || segment.sharedRoutes.length === 0) return;
              if (segment.primaryRoute != null && segment.primaryRoute !== routeId) {
                if (currentGroup) {
                  currentGroup.points = this.uniqueLatLngSequence(currentGroup.points);
                  groups.push(currentGroup);
                  currentGroup = null;
                }
                lastKey = null;
                return;
              }

              const startNodeKey = segment.startNodeKey;
              const startLatLng = segment.start && segment.start.latlng;
              const endLatLng = segment.end && segment.end.latlng;
              if (!startLatLng || !endLatLng) return;

              const startBreak = !currentGroup || segment.key !== lastKey || startNodeKey !== currentGroup.endNodeKey;
              if (startBreak) {
                if (currentGroup) {
                  currentGroup.points = this.uniqueLatLngSequence(currentGroup.points);
                  groups.push(currentGroup);
                }
                currentGroup = {
                  key: segment.key,
                  routes: segment.sharedRoutes.slice(),
                  points: [startLatLng],
                  lengthPx: 0,
                  startNodeKey,
                  endNodeKey: segment.endNodeKey,
                  segments: [segment]
                };
              } else if (currentGroup && !this.latLngEquals(currentGroup.points[currentGroup.points.length - 1], startLatLng)) {
                currentGroup.points.push(startLatLng);
              }

              if (currentGroup) {
                if (!this.latLngEquals(currentGroup.points[currentGroup.points.length - 1], endLatLng)) {
                  currentGroup.points.push(endLatLng);
                }
                currentGroup.lengthPx += segment.lengthPx || this.distance(segment.start.point, segment.end.point);
                currentGroup.endNodeKey = segment.endNodeKey;
                currentGroup.segments.push(segment);
              }

              lastKey = segment.key;
            });

            if (currentGroup) {
              currentGroup.points = this.uniqueLatLngSequence(currentGroup.points);
              groups.push(currentGroup);
            }
          });

          return groups;
        }

        drawGroups(groups) {
          const newLayers = [];
          const dashBase = this.options.dashLengthPx;
          const minDash = this.options.minDashLengthPx;
          const weight = this.options.strokeWeight;
          const minGapRatio = this.options.minEndGapRatio || 0.25;
          const confettiRatio = this.options.confettiThresholdRatio || 0.5;

          groups.forEach(group => {
            if (!group || !Array.isArray(group.routes) || group.routes.length === 0) return;
            const basePoints = this.uniqueLatLngSequence(group.points || []);
            if (basePoints.length < 2) return;

            const totalLength = this.computePolylineLength(basePoints);
            if (!(totalLength > 0)) return;

            const trimAmount = Math.min(totalLength / 2, dashBase * minGapRatio);
            const trimmed = this.trimPolyline(basePoints, trimAmount, trimAmount);
            const trimmedPoints = trimmed.points;
            const effectiveLength = trimmed.length;
            if (!trimmedPoints || trimmedPoints.length < 2 || !(effectiveLength > 0)) return;

            const sortedRoutes = group.routes.slice().sort((a, b) => a - b);
            const shortThreshold = dashBase;
            const confettiThreshold = dashBase * confettiRatio;

            if (sortedRoutes.length === 1 || effectiveLength <= shortThreshold || effectiveLength <= confettiThreshold) {
              const dominant = sortedRoutes[0];
              const layer = L.polyline(trimmedPoints, {
                color: getRouteColor(dominant),
                weight,
                opacity: 1,
                lineCap: 'round',
                lineJoin: 'round'
              }).addTo(this.map);
              newLayers.push(layer);
              return;
            }

            const stripeCount = sortedRoutes.length;
            let dashLength = dashBase;
            if (dashLength * stripeCount > effectiveLength) {
              dashLength = effectiveLength / stripeCount;
            }
            if (!(dashLength > 0)) {
              dashLength = minDash;
            }
            const gapLength = dashLength * (stripeCount - 1);

            sortedRoutes.forEach((routeId, index) => {
              const layer = L.polyline(trimmedPoints, {
                color: getRouteColor(routeId),
                weight,
                opacity: 1,
                dashArray: `${dashLength} ${gapLength}`,
                dashOffset: `${dashLength * index}`,
                lineCap: 'round',
                lineJoin: 'round'
              }).addTo(this.map);
              newLayers.push(layer);
            });
          });

          this.layers = newLayers;
        }

        simplifyLatLngs(latlngs, zoom) {
          if (!Array.isArray(latlngs) || latlngs.length === 0) return [];
          const projected = latlngs.map(latlng => this.map.project(latlng, zoom));
          let simplified = projected;
          if (projected.length > 2 && this.options.simplifyTolerancePx > 0 && L.LineUtil && L.LineUtil.simplify) {
            simplified = L.LineUtil.simplify(projected, this.options.simplifyTolerancePx);
          }
          return simplified.map(pt => ({
            point: L.point(pt.x, pt.y),
            latlng: this.map.unproject(pt, zoom)
          }));
        }

        resampleRoute(routeId, latlngs, zoom, step, maskIntervals = []) {
          const simplified = this.simplifyLatLngs(latlngs, zoom);
          if (simplified.length < 2) {
            return { points: [], segments: [] };
          }

          const resampledPoints = [];
          const first = simplified[0];
          resampledPoints.push({
            latlng: first.latlng,
            point: first.point,
            cumulativeLength: 0,
            cumulativeMeters: 0
          });

          let totalLengthPx = 0;
          let totalLengthMeters = 0;
          let nextSample = step;

          for (let i = 1; i < simplified.length; i++) {
            const prev = simplified[i - 1];
            const curr = simplified[i];
            const segmentLengthPx = this.distance(prev.point, curr.point);
            if (segmentLengthPx === 0) continue;
            const segmentLengthMeters = this.latLngDistance(prev.latlng, curr.latlng);

            while (nextSample <= totalLengthPx + segmentLengthPx) {
              const ratio = (nextSample - totalLengthPx) / segmentLengthPx;
              const samplePoint = this.interpolatePoint(prev.point, curr.point, ratio);
              const sampleLatLng = this.interpolateLatLng(prev.latlng, curr.latlng, ratio);
              const sampleMeters = totalLengthMeters + (segmentLengthMeters * ratio);
              resampledPoints.push({
                latlng: sampleLatLng,
                point: samplePoint,
                cumulativeLength: nextSample,
                cumulativeMeters: sampleMeters
              });
              nextSample += step;
            }

            totalLengthPx += segmentLengthPx;
            totalLengthMeters += segmentLengthMeters;
          }

          const last = simplified[simplified.length - 1];
          const lastSample = resampledPoints[resampledPoints.length - 1];
          if (!this.latLngEquals(lastSample.latlng, last.latlng)) {
            resampledPoints.push({
              latlng: last.latlng,
              point: last.point,
              cumulativeLength: totalLengthPx,
              cumulativeMeters: totalLengthMeters
            });
          } else {
            lastSample.cumulativeLength = totalLengthPx;
            lastSample.cumulativeMeters = totalLengthMeters;
          }

          const segments = [];
          const sortedMasks = Array.isArray(maskIntervals)
            ? maskIntervals.slice().sort((a, b) => (a.start || 0) - (b.start || 0))
            : [];

          for (let i = 0; i < resampledPoints.length - 1; i++) {
            const start = resampledPoints[i];
            const end = resampledPoints[i + 1];
            const lengthPx = end.cumulativeLength - start.cumulativeLength;
            if (!(lengthPx > 0)) continue;
            const lengthMeters = end.cumulativeMeters - start.cumulativeMeters;
            const bounds = {
              minX: Math.min(start.point.x, end.point.x),
              minY: Math.min(start.point.y, end.point.y),
              maxX: Math.max(start.point.x, end.point.x),
              maxY: Math.max(start.point.y, end.point.y)
            };
            const midpoint = L.point((start.point.x + end.point.x) / 2, (start.point.y + end.point.y) / 2);
            const heading = Math.atan2(end.point.y - start.point.y, end.point.x - start.point.x);
            const segment = {
              routeId,
              start,
              end,
              lengthPx,
              lengthMeters,
              bounds,
              midpoint,
              heading
            };
            if (!this.segmentWithinMask(segment, sortedMasks)) {
              segments.push(segment);
            }
          }

          return {
            points: resampledPoints,
            segments
          };
        }

        interpolatePoint(a, b, t) {
          return L.point(
            a.x + (b.x - a.x) * t,
            a.y + (b.y - a.y) * t
          );
        }

        interpolateLatLng(a, b, t) {
          return L.latLng(
            (a.lat || 0) + ((b.lat || 0) - (a.lat || 0)) * t,
            (a.lng || 0) + ((b.lng || 0) - (a.lng || 0)) * t
          );
        }

        latLngDistance(a, b) {
          if (this.map && typeof this.map.distance === 'function') {
            return this.map.distance(a, b);
          }
          const dx = ((b && b.lat) || 0) - ((a && a.lat) || 0);
          const dy = ((b && b.lng) || 0) - ((a && a.lng) || 0);
          return Math.sqrt(dx * dx + dy * dy);
        }

        segmentWithinMask(segment, intervals) {
          if (!Array.isArray(intervals) || intervals.length === 0) return false;
          const startMeters = Math.min(segment.start.cumulativeMeters || 0, segment.end.cumulativeMeters || 0);
          const endMeters = Math.max(segment.start.cumulativeMeters || 0, segment.end.cumulativeMeters || 0);
          const lengthMeters = Math.max(1e-6, endMeters - startMeters);
          for (let i = 0; i < intervals.length; i++) {
            const interval = intervals[i];
            if (!interval) continue;
            const start = interval.start != null ? interval.start : interval[0];
            const end = interval.end != null ? interval.end : interval[1];
            if (start == null || end == null) continue;
            if (end <= startMeters) continue;
            if (start >= endMeters) continue;
            const overlap = Math.min(end, endMeters) - Math.max(start, startMeters);
            if (overlap / lengthMeters >= 0.8) {
              return true;
            }
          }
          return false;
        }

        computePolylineLength(latlngs) {
          if (!Array.isArray(latlngs) || latlngs.length < 2) return 0;
          const zoom = this.currentZoom;
          let length = 0;
          let prevPoint = this.map.project(latlngs[0], zoom);
          for (let i = 1; i < latlngs.length; i++) {
            const point = this.map.project(latlngs[i], zoom);
            length += this.distance(prevPoint, point);
            prevPoint = point;
          }
          return length;
        }

        trimPolyline(latlngs, trimStart, trimEnd) {
          if (!Array.isArray(latlngs) || latlngs.length < 2) {
            return { points: [], length: 0 };
          }
          const totalLength = this.computePolylineLength(latlngs);
          if (!(totalLength > 0)) {
            return { points: [], length: 0 };
          }

          const zoom = this.currentZoom;
          const projected = latlngs.map(latlng => this.map.project(latlng, zoom));
          const startCut = Math.max(0, Math.min(trimStart || 0, totalLength / 2));
          const endCut = Math.max(0, Math.min(trimEnd || 0, totalLength - startCut));
          const targetStart = startCut;
          const targetEnd = totalLength - endCut;
          if (targetEnd <= targetStart) {
            return { points: [], length: 0 };
          }

          const trimmed = [];
          let accumulated = 0;

          for (let i = 0; i < projected.length - 1; i++) {
            const p0 = projected[i];
            const p1 = projected[i + 1];
            const l0 = latlngs[i];
            const l1 = latlngs[i + 1];
            const segmentLength = this.distance(p0, p1);
            if (segmentLength === 0) continue;

            const nextAccum = accumulated + segmentLength;
            if (nextAccum <= targetStart) {
              accumulated = nextAccum;
              continue;
            }

            if (accumulated < targetStart) {
              const ratio = (targetStart - accumulated) / segmentLength;
              const point = this.interpolatePoint(p0, p1, ratio);
              const latlng = this.interpolateLatLng(l0, l1, ratio);
              trimmed.push({ point, latlng });
            } else if (trimmed.length === 0) {
              trimmed.push({ point: p0, latlng: l0 });
            }

            if (nextAccum >= targetEnd) {
              const ratio = (targetEnd - accumulated) / segmentLength;
              const point = this.interpolatePoint(p0, p1, Math.min(1, Math.max(0, ratio)));
              const latlng = this.interpolateLatLng(l0, l1, Math.min(1, Math.max(0, ratio)));
              trimmed.push({ point, latlng });
              break;
            } else {
              trimmed.push({ point: p1, latlng: l1 });
            }

            accumulated = nextAccum;
          }

          const trimmedLatLngs = this.uniqueLatLngSequence(trimmed.map(item => item.latlng));
          const trimmedLength = this.computePolylineLength(trimmedLatLngs);
          return { points: trimmedLatLngs, length: trimmedLength };
        }

        distance(a, b) {
          const dx = (b.x || 0) - (a.x || 0);
          const dy = (b.y || 0) - (a.y || 0);
          return Math.sqrt(dx * dx + dy * dy);
        }

        segmentsOverlap(a, b, tolerance, headingToleranceRad) {
          const midpointDistance = this.distance(a.midpoint, b.midpoint);
          if (midpointDistance > tolerance) return false;

          const headingDiff = this.smallestHeadingDifference(a.heading, b.heading);
          if (headingDiff > headingToleranceRad && Math.abs(Math.PI - headingDiff) > headingToleranceRad) {
            return false;
          }

          return true;
        }

        smallestHeadingDifference(a, b) {
          let diff = Math.abs(a - b);
          diff = diff % (Math.PI * 2);
          if (diff > Math.PI) diff = (Math.PI * 2) - diff;
          return diff;
        }

        latLngEquals(a, b) {
          if (!a || !b) return false;
          if (typeof a.equals === 'function') {
            return a.equals(b, this.options.latLngEqualityMargin);
          }
          return Math.abs(a.lat - b.lat) <= this.options.latLngEqualityMargin &&
            Math.abs(a.lng - b.lng) <= this.options.latLngEqualityMargin;
        }
      }

      // Fetch routes from GetRoutes.
      function fetchRouteColors() {
        console.log('Fetching route colors...');
        const routesApiUrl = `${baseURL}/Services/JSONPRelay.svc/GetRoutes?APIKey=8882812681`;
        return fetch(routesApiUrl)
          .then(response => response.json())
          .then(data => {
            if (Array.isArray(data)) {
              data.forEach(route => {
                setRouteVisibility(route);
                allRoutes[route.RouteID] = Object.assign(allRoutes[route.RouteID] || {}, route);
                if (canDisplayRoute(route.RouteID)) {
                  routeColors[route.RouteID] = route.MapLineColor;
                  console.log(`Route ID: ${route.RouteID}, Color: ${route.MapLineColor}`);
                } else {
                  delete routeColors[route.RouteID];
                  console.log(`Route ID: ${route.RouteID} hidden due to display settings`);
                }
              });
            }
          })
          .catch(error => console.error("Error fetching route colors:", error));
      }

      // Fetch route paths from GetRoutesForMapWithSchedule and center map on all routes.
      function fetchRoutePaths() {
          const currentBaseURL = baseURL;
          const routePathsApiUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetRoutesForMapWithScheduleWithEncodedLine?APIKey=8882812681`;
          fetch(routePathsApiUrl)
              .then(response => response.json())
              .then(data => {
                  if (currentBaseURL !== baseURL) return;
                  routeLayers.forEach(layer => map.removeLayer(layer));
                  routeLayers = [];
                  let bounds = null;
                  const displayedRoutes = new Map();
                  const rendererGeometries = new Map();
                  const selectedRouteIds = [];
                  const useOverlapRenderer = enableOverlapDashRendering && overlapRenderer;
                  if (Array.isArray(data)) {
                      data.forEach(route => {
                          setRouteVisibility(route);
                          allRoutes[route.RouteID] = Object.assign(allRoutes[route.RouteID] || {}, route);
                          const routeAllowed = canDisplayRoute(route.RouteID);
                          if (route.EncodedPolyline && routeAllowed) {
                              const decodedPolyline = polyline.decode(route.EncodedPolyline);
                              const latLngPath = decodedPolyline.map(coords => L.latLng(coords[0], coords[1]));
                              const polyBounds = L.latLngBounds(latLngPath);
                              bounds = bounds ? bounds.extend(polyBounds) : polyBounds;

                              if (isRouteSelected(route.RouteID)) {
                                  const numericRouteId = Number(route.RouteID);
                                  const routeColor = getRouteColor(route.RouteID);
                                  if (!Number.isNaN(numericRouteId)) {
                                      const hasUsableGeometry = Array.isArray(latLngPath) && latLngPath.length >= 2;
                                      selectedRouteIds.push(numericRouteId);
                                      if (useOverlapRenderer && hasUsableGeometry) {
                                          rendererGeometries.set(numericRouteId, latLngPath);
                                      } else if (hasUsableGeometry) {
                                          const routeLayer = L.polyline(latLngPath, {
                                              color: routeColor,
                                              weight: 6,
                                              opacity: 1
                                          }).addTo(map);
                                          routeLayers.push(routeLayer);
                                      }
                                  }
                                  const storedRoute = allRoutes[route.RouteID] || {};
                                  const legendNameCandidates = [
                                      storedRoute.Description,
                                      route.Description,
                                      storedRoute.Name,
                                      route.Name,
                                      storedRoute.RouteName,
                                      route.RouteName
                                  ];
                                  let legendName = legendNameCandidates.find(value => typeof value === 'string' && value.trim() !== '');
                                  legendName = legendName ? legendName.trim() : `Route ${route.RouteID}`;
                                  const rawDescription = storedRoute.InfoText ?? route.InfoText ?? '';
                                  const legendDescription = typeof rawDescription === 'string' ? rawDescription.trim() : '';
                                  const legendRouteId = Number.isNaN(numericRouteId) ? route.RouteID : numericRouteId;
                                  displayedRoutes.set(route.RouteID, {
                                      routeId: legendRouteId,
                                      color: routeColor,
                                      name: legendName,
                                      description: legendDescription
                                  });
                              }
                          }
                      });
                      if (useOverlapRenderer) {
                          const layers = overlapRenderer.updateRoutes(rendererGeometries, selectedRouteIds);
                          routeLayers = layers;
                      }
                      if (bounds) {
                          allRouteBounds = bounds;
                          if (!mapHasFitAllRoutes) {
                              if (!kioskMode && !adminKioskMode) {
                                  map.fitBounds(allRouteBounds, { padding: [20, 20] });
                              }
                              mapHasFitAllRoutes = true;
                          }
                      }
                      updateRouteSelector(activeRoutes);
                      stopMarkers.forEach(stopMarker => stopMarker.bringToFront());
                  }
                  updateRouteLegend(Array.from(displayedRoutes.values()));
              })
              .catch(error => {
                  console.error("Error fetching route paths:", error);
                  updateRouteLegend([]);
              });
      }

      function fetchBlockAssignments() {
          const currentBaseURL = baseURL;
          const d = new Date();
          const ds = `${d.getMonth() + 1}/${d.getDate()}/${d.getFullYear()}`;
          const schedUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetScheduleVehicleCalendarByDateAndRoute?dateString=${encodeURIComponent(ds)}`;
          fetch(schedUrl)
              .then(response => response.json())
              .then(sched => {
                  if (currentBaseURL !== baseURL) return;
                  const ids = (sched || []).map(s => s.ScheduleVehicleCalendarID).join(',');
                  if (!ids) {
                      busBlocks = {};
                      return;
                  }
                  const blockUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetDispatchBlockGroupData?scheduleVehicleCalendarIdsString=${ids}`;
                  return fetch(blockUrl).then(r => r.json());
              })
              .then(data => {
                  if (currentBaseURL !== baseURL || !data) return;
                  const groups = data?.BlockGroups || [];
                  const alias = {
                      "[01]": "[01]/[04]",
                      "[03]": "[05]/[03]",
                      "[04]": "[01]/[04]",
                      "[05]": "[05]/[03]",
                      "[06]": "[22]/[06]",
                      "[10]": "[20]/[10]",
                      "[15]": "[26]/[15]",
                      "[16] AM": "[21]/[16] AM",
                      "[17]": "[23]/[17]",
                      "[18] AM": "[24]/[18] AM",
                      "[20] AM": "[20]/[10]",
                      "[21] AM": "[21]/[16] AM",
                      "[22] AM": "[22]/[06]",
                      "[23]": "[23]/[17]",
                      "[24] AM": "[24]/[18] AM",
                      "[26] AM": "[26]/[15]"
                  };
                  let mapping = {};
                  groups.forEach(g => {
                      const block = (g.BlockGroupId || '').trim();
                      const vehicleId = g.Blocks?.[0]?.Trips?.[0]?.VehicleID ?? g.VehicleId;
                      if (block && block.includes('[') && vehicleId != null) {
                          mapping[vehicleId] = alias[block] || block;
                      }
                  });
                  busBlocks = mapping;
              })
              .catch(error => console.error("Error fetching block assignments:", error));
      }

      function fetchBusLocations() {
          const currentBaseURL = baseURL;
          const apiUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetMapVehiclePoints?APIKey=8882812681&returnVehiclesNotAssignedToRoute=true`;
          return fetch(apiUrl)
              .then(response => {
                  if (!response.ok) throw new Error("Network response was not ok: " + response.statusText);
                  return response.json();
              })
              .then(data => {
                  if (currentBaseURL !== baseURL) return;
                  if (Array.isArray(data)) {
                      let currentBusData = {};
                      let activeRoutesSet = new Set();
                      let vehicles = [];

                      // First pass: gather vehicles and determine active routes.
                      data.forEach(vehicle => {
                          const vehicleID = vehicle.VehicleID;
                          const newPosition = [vehicle.Latitude, vehicle.Longitude];
                          const isMoving = vehicle.GroundSpeed > 0;
                          const busName = vehicle.Name;
                          let routeID = vehicle.RouteID;
                          if (!routeID && adminMode) {
                              routeID = 0;
                          } else if (!routeID) {
                              return;
                          }
                          const numericRouteId = Number(routeID);
                          const effectiveRouteId = Number.isNaN(numericRouteId) ? routeID : numericRouteId;
                          if (!canDisplayRoute(effectiveRouteId)) return;
                          if (!adminMode && !routeColors.hasOwnProperty(effectiveRouteId)) return;
                          activeRoutesSet.add(effectiveRouteId);
                          vehicles.push({
                              vehicleID,
                              newPosition,
                              isMoving,
                              busName,
                              routeID: effectiveRouteId,
                              heading: vehicle.Heading,
                              groundSpeed: vehicle.GroundSpeed
                          });
                      });

                      // Update global activeRoutes and rebuild selector before rendering.
                      activeRoutes = activeRoutesSet;
                      updateRouteSelector(activeRoutesSet);

                      // Second pass: render only selected routes.
                      vehicles.forEach(v => {
                          const { vehicleID, newPosition, isMoving, busName, routeID, heading, groundSpeed } = v;
                          if (!isRouteSelected(routeID)) return;
                          currentBusData[vehicleID] = true;
                          const svgIcon = `
                              <svg width="40" height="80" viewBox="0 0 40 80" xmlns="http://www.w3.org/2000/svg">
                                <g>
                                  <circle cx="20" cy="20" r="15" fill="${getRouteColor(routeID)}" stroke="white" stroke-width="3" />
                                  ${isMoving ? `
                                    <line x1="20" y1="10" x2="20" y2="22" stroke="${getContrastColor(getRouteColor(routeID))}" stroke-width="4" stroke-linecap="round" style="transform: rotate(${heading + 180}deg); transform-origin: 20px 20px" />
                                    <polygon points="15,22 25,22 20,30" fill="${getContrastColor(getRouteColor(routeID))}" style="transform: rotate(${heading + 180}deg); transform-origin: 20px 20px" />
                                  ` : `
                                    <rect x="14" y="14" width="12" height="12" fill="${getContrastColor(getRouteColor(routeID))}" />
                                  `}
                                </g>
                              </svg>`;
                          const busIcon = L.divIcon({
                              html: svgIcon,
                              className: '',
                              iconSize: [40, 40],
                              iconAnchor: [20, 20]
                          });
                          if (markers[vehicleID]) {
                              animateMarkerTo(markers[vehicleID], newPosition);
                              markers[vehicleID].setIcon(busIcon);
                              markers[vehicleID].routeID = routeID;
                          } else {
                              markers[vehicleID] = L.marker(newPosition, { icon: busIcon });
                              markers[vehicleID].routeID = routeID;
                              markers[vehicleID].addTo(map);
                          }
                          if (adminMode && showSpeed && !kioskMode) {
                              const speedBubble = `
                                  <svg width="60" height="20" viewBox="0 0 60 20" xmlns="http://www.w3.org/2000/svg">
                                      <g>
                                          <rect x="0" y="0" width="60" height="20" rx="10" ry="10" fill="${getRouteColor(routeID)}" stroke="white" stroke-width="3" />
                                          <text x="30" y="15" font-size="12" font-weight="bold" text-anchor="middle" fill="${getContrastColor(getRouteColor(routeID))}" font-family="FGDC">${Math.round(groundSpeed)} MPH</text>
                                      </g>
                                  </svg>`;
                              const speedIcon = L.divIcon({
                                  html: speedBubble,
                                  className: '',
                                  iconSize: [60, 20],
                                  iconAnchor: [30, -15]
                              });
                              if (nameBubbles[vehicleID] && nameBubbles[vehicleID].speedMarker) {
                                  animateMarkerTo(nameBubbles[vehicleID].speedMarker, newPosition);
                                  nameBubbles[vehicleID].speedMarker.setIcon(speedIcon);
                              } else {
                                  nameBubbles[vehicleID] = nameBubbles[vehicleID] || {};
                                  nameBubbles[vehicleID].speedMarker = L.marker(newPosition, { icon: speedIcon, interactive: false }).addTo(map);
                              }
                          } else {
                              if (nameBubbles[vehicleID] && nameBubbles[vehicleID].speedMarker) {
                                  map.removeLayer(nameBubbles[vehicleID].speedMarker);
                                  delete nameBubbles[vehicleID].speedMarker;
                              }
                          }
                          if (adminMode && !kioskMode) {
                              const bubbleWidth = Math.max(40, busName.length * 10);
                              const nameBubble = `
                                  <svg width="${bubbleWidth}" height="30" viewBox="0 0 ${bubbleWidth} 30" xmlns="http://www.w3.org/2000/svg">
                                      <g>
                                          <rect x="0" y="5" width="${bubbleWidth}" height="20" rx="10" ry="10" fill="${getRouteColor(routeID)}" stroke="white" stroke-width="3" />
                                          <text x="${bubbleWidth / 2}" y="20" font-size="14" font-weight="bold" text-anchor="middle" fill="${getContrastColor(getRouteColor(routeID))}" font-family="FGDC">${busName}</text>
                                      </g>
                                  </svg>`;
                              const nameIcon = L.divIcon({
                                  html: nameBubble,
                                  className: '',
                                  iconSize: [bubbleWidth, 30],
                                  iconAnchor: [bubbleWidth / 2, 40]
                              });
                              if (nameBubbles[vehicleID] && nameBubbles[vehicleID].nameMarker) {
                                  animateMarkerTo(nameBubbles[vehicleID].nameMarker, newPosition);
                                  nameBubbles[vehicleID].nameMarker.setIcon(nameIcon);
                              } else {
                                  nameBubbles[vehicleID] = nameBubbles[vehicleID] || {};
                                  nameBubbles[vehicleID].nameMarker = L.marker(newPosition, { icon: nameIcon, interactive: false }).addTo(map);
                              }

                              const blockName = busBlocks[vehicleID];
                              if (showBlockNumbers && blockName && blockName.includes('[')) {
                                  const canvas = document.createElement('canvas');
                                  const ctx = canvas.getContext('2d');
                                  ctx.font = 'bold 14px FGDC';
                                  const textWidth = ctx.measureText(blockName).width;
                                  const blockWidth = Math.max(40, textWidth + 20);
                                  const blockBubble = `
                                      <svg width="${blockWidth}" height="30" viewBox="0 0 ${blockWidth} 30" xmlns="http://www.w3.org/2000/svg">
                                          <g>
                                              <rect x="0" y="5" width="${blockWidth}" height="20" rx="10" ry="10" fill="${getRouteColor(routeID)}" stroke="white" stroke-width="3" />
                                              <text x="${blockWidth / 2}" y="20" font-size="14" font-weight="bold" text-anchor="middle" fill="${getContrastColor(getRouteColor(routeID))}" font-family="FGDC">${blockName}</text>
                                          </g>
                                      </svg>`;
                                  const blockIcon = L.divIcon({
                                      html: blockBubble,
                                      className: '',
                                      iconSize: [blockWidth, 30],
                                      // Position the block number bubble so it touches but doesn't overlap the bus icon
                                      iconAnchor: [blockWidth / 2, -13]
                                  });
                                  if (nameBubbles[vehicleID] && nameBubbles[vehicleID].blockMarker) {
                                      animateMarkerTo(nameBubbles[vehicleID].blockMarker, newPosition);
                                      nameBubbles[vehicleID].blockMarker.setIcon(blockIcon);
                                  } else {
                                      nameBubbles[vehicleID] = nameBubbles[vehicleID] || {};
                                      nameBubbles[vehicleID].blockMarker = L.marker(newPosition, { icon: blockIcon, interactive: false }).addTo(map);
                                  }
                              } else {
                                  if (nameBubbles[vehicleID] && nameBubbles[vehicleID].blockMarker) {
                                      map.removeLayer(nameBubbles[vehicleID].blockMarker);
                                      delete nameBubbles[vehicleID].blockMarker;
                                  }
                              }
                          } else {
                              if (nameBubbles[vehicleID] && nameBubbles[vehicleID].nameMarker) {
                                  map.removeLayer(nameBubbles[vehicleID].nameMarker);
                                  delete nameBubbles[vehicleID].nameMarker;
                              }
                              if (nameBubbles[vehicleID] && nameBubbles[vehicleID].blockMarker) {
                                  map.removeLayer(nameBubbles[vehicleID].blockMarker);
                                  delete nameBubbles[vehicleID].blockMarker;
                              }
                          }
                      });

                      Object.keys(markers).forEach(vehicleID => {
                          if (!currentBusData[vehicleID] || !isRouteSelected(markers[vehicleID].routeID)) {
                              map.removeLayer(markers[vehicleID]);
                              delete markers[vehicleID];
                              if (nameBubbles[vehicleID]) {
                                  if (nameBubbles[vehicleID].speedMarker) map.removeLayer(nameBubbles[vehicleID].speedMarker);
                                  if (nameBubbles[vehicleID].nameMarker) map.removeLayer(nameBubbles[vehicleID].nameMarker);
                                  if (nameBubbles[vehicleID].blockMarker) map.removeLayer(nameBubbles[vehicleID].blockMarker);
                                  delete nameBubbles[vehicleID];
                              }
                          }
                      });
                      previousBusData = currentBusData;
                  }
              })
              .catch(error => console.error("Error fetching bus locations:", error));
      }

      function getContrastColor(hexColor) {
          hexColor = hexColor.replace('#', '');
          const r = parseInt(hexColor.substring(0, 2), 16);
          const g = parseInt(hexColor.substring(2, 4), 16);
          const b = parseInt(hexColor.substring(4, 6), 16);
          const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
          return luminance > 0.565 ? 'black' : 'white';
      }

      function animateMarkerTo(marker, newPosition) {
        const startPos = marker.getLatLng();
        const endPos = L.latLng(newPosition);
        const duration = 1000;
        const startTime = performance.now();
        function animate(time) {
          const elapsed = time - startTime;
          const t = Math.min(elapsed / duration, 1);
          const currentPos = L.latLng(
            startPos.lat + t * (endPos.lat - startPos.lat),
            startPos.lng + t * (endPos.lng - startPos.lng)
          );
          marker.setLatLng(currentPos);
          if (t < 1) requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);
      }

      document.addEventListener("DOMContentLoaded", () => {
        loadAgencies().then(() => {
          initMap();
          showCookieBanner();
        });
      });
    </script>
  </head>
  <body>
    <div id="map"></div>
    <div id="routeLegend" aria-live="polite"></div>
    <div id="routeSelector"></div>
    <div id="routeSelectorTab" onclick="togglePanel()">&#9664;</div>
    <div class="credit">proof of concept created by pat cox • phc6j@virginia.edu</div>
    <div id="cookieBanner" class="cookie-banner" style="display:none;">
      This site stores your selected transit agency on your device to remember your preference.
      <button id="cookieAccept">OK</button>
    </div>
  </body>
</html>
