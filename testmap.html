<!DOCTYPE html>
<html>
  <head>
    <title>Live Map - Headway Guard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@mapbox/polyline@1.1.1"></script>
    <script src="https://unpkg.com/rbush@3.0.1/rbush.min.js"></script>
    <style>
      .custom-popup {
        position: absolute;
        background: #232D4B;
        border: 4px solid white;
        border-radius: 15px;
        padding: 10px;
        pointer-events: auto;
        transform: translate(-50%, -100%);
        white-space: nowrap;
        z-index: 1000;
        color: white;
        text-transform: uppercase;
      }
      .custom-popup-arrow {
        position: absolute;
        left: 50%;
        bottom: -10px;
        width: 0;
        height: 0;
        border-left: 10px solid transparent;
        border-right: 10px solid transparent;
        border-top: 10px solid white;
        transform: translateX(-50%);
      }
      .custom-popup-close {
        position: absolute;
        bottom: 5px;
        right: 5px;
        cursor: pointer;
        background: #f00;
        color: #fff;
        border: none;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        line-height: 20px;
        text-align: center;
        font-size: 14px;
      }
      .route-pill {
        display: inline-block;
        padding: 5px 10px;
        border-radius: 20px;
        color: white;
        font-weight: bold;
        margin-top: 10px;
        text-align: center;
        border: 2px solid #FFFFFF;
      }
      .stop-marker-container {
        display: flex;
        align-items: center;
        justify-content: center;
        background: transparent;
        border: none;
      }
      .stop-marker-outer {
        border-radius: 50%;
        box-sizing: border-box;
      }
      .stop-entry + .stop-entry {
        margin-top: 12px;
        padding-top: 8px;
        border-top: 1px solid rgba(255, 255, 255, 0.2);
      }
      .stop-entry-title {
        display: block;
        font-weight: bold;
        margin-bottom: 4px;
      }
      .stop-entry-id {
        display: block;
        font-size: 12px;
        opacity: 0.9;
        margin-bottom: 6px;
      }
      @font-face {
        font-family: 'FGDC';
        src: url('FGDC.ttf') format('truetype');
      }
      body, .custom-popup {
        font-family: 'FGDC', sans-serif;
        font-size: 14px;
      }
      #map {
        height: 100%;
        width: 100%;
      }
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
      }
      /* Route Selector styling */
      #routeSelector {
        width: 300px;
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 1100;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px;
        border-radius: 5px;
        max-height: 90vh;
        overflow-y: auto;
        transition: transform 0.3s ease;
		font-size: 21px;
      }
      #routeSelector.hidden {
        transform: translateX(320px);
      }
      #routeSelector h3 {
        margin-top: 0;
      }
      /* Updated button styles for route selector (including speed toggle) */
      #routeSelector button {
        margin: 5px 2px;
        padding: 5px 10px;
        font-size: 24px;
        font-family: 'FGDC', sans-serif;
        background-color: #E57200;
        color: black;
        border: none;
        border-radius: 20px;
        cursor: pointer;
      }
      #routeSelector label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
      }
      #routeSelector .color-box {
        display: inline-block;
        width: 12px;
        height: 12px;
        margin-right: 5px;
        vertical-align: middle;
      }
      /* Tab styling */
      #routeSelectorTab {
        position: fixed;
        top: 50%;
        right: 0;
        width: 30px;
        height: 60px;
        background: #ccc;
        border-top-left-radius: 10px;
        border-bottom-left-radius: 10px;
        cursor: pointer;
        display: block;
        transform: translateY(-50%);
        z-index: 1150;
        text-align: center;
        line-height: 60px;
        font-size: 20px;
        user-select: none;
        transition: right 0.3s ease;
      }
      #routeLegend {
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 1100;
        background: rgba(255, 255, 255, 0.9);
        padding: 12px 16px;
        border-radius: 8px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        max-width: 320px;
        display: none;
        font-size: 20px;
      }
      #routeLegend .legend-title {
        font-weight: bold;
        margin-bottom: 8px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      #routeLegend .legend-item {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 8px;
      }
      #routeLegend .legend-item:last-child {
        margin-bottom: 0;
      }
      #routeLegend .legend-color {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 2px solid #FFFFFF;
        box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.1);
        flex-shrink: 0;
      }
      #routeLegend .legend-text {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      #routeLegend .legend-name {
        font-weight: bold;
      }
      #routeLegend .legend-description {
        font-size: 16px;
        color: #1b1b1b;
      }
      @media (max-width: 600px) {
        #routeSelector { width: 80%; right: 10%; font-size: 18px; }
        #routeSelector.hidden { transform: translateX(calc(100% + 20px)); }
        #routeSelector button { font-size: 20px; }
        #routeSelector label { font-size: 18px; }
        #routeSelectorTab { width: 40px; height: 80px; font-size: 28px; }
      }
      .credit{position:fixed;bottom:8px;right:8px;font-size:12px;color:var(--muted,#9fb0c9);}
      .cookie-banner{position:fixed;bottom:0;left:0;right:0;background:rgba(0,0,0,0.8);color:white;padding:10px;text-align:center;font-size:14px;z-index:1200;}
      .cookie-banner button{margin-left:10px;}
    </style>
    <script>
      // Manually set these variables.
      // adminMode: true for admin view (with speed/block bubbles and unit numbers).
      //            Can be disabled via URL param `adminMode=false`.
      //            In public mode (adminMode=false) the route selector is still shown
      //            but only for routes that are public-facing.
      // kioskMode: true to hide the route selector/tab and suppress vehicle overlays for a public display.
      // adminKioskMode: true to hide the route selector/tab while retaining admin overlays (previous kiosk behavior).
      // showSpeed/showBlockNumbers: only one may be true at a time.
      let adminMode = true; // shows unit numbers and speed/block bubbles
      let kioskMode = false;
      let adminKioskMode = false;
      let showSpeed = false; // default to showing block numbers
      let showBlockNumbers = true;

      const enableOverlapDashRendering = true;

      const ROUTE_LAYER_BASE_OPTIONS = Object.freeze({
        updateWhenZooming: true,
        updateWhenIdle: true,
        interactive: false
      });
      let sharedRouteRenderer = null;
      let routePaneName = 'overlayPane';

      function createSpatialIndex(options = {}) {
        if (typeof rbush === 'function') {
          try {
            return rbush(options.maxEntries);
          } catch (error) {
            console.error('Failed to create rbush index via rbush()', error);
          }
        }
        if (typeof RBush === 'function') {
          try {
            return new RBush(options.maxEntries);
          } catch (error) {
            console.error('Failed to create rbush index via new RBush()', error);
          }
        }
        console.error('RBush spatial index library is not available. Route overlap rendering will be disabled.');
        return null;
      }

      function mergeRouteLayerOptions(overrides = {}, rendererOverride = null, paneOverride = null) {
        const base = Object.assign({}, ROUTE_LAYER_BASE_OPTIONS);
        const renderer = rendererOverride || sharedRouteRenderer;
        if (renderer) {
          base.renderer = renderer;
        }
        const pane = paneOverride || routePaneName;
        if (typeof pane === 'string' && pane) {
          base.pane = pane;
        }
        return Object.assign(base, overrides || {});
      }

      const params = new URLSearchParams(window.location.search);
      const kioskParam = params.get('kioskMode');
      if (kioskParam !== null) {
        kioskMode = kioskParam.toLowerCase() === 'true';
      }
      const adminKioskParam = params.get('adminKioskMode');
      if (adminKioskParam !== null) {
        adminKioskMode = adminKioskParam.toLowerCase() === 'true';
      }
      const adminParam = params.get('adminMode');
      if (adminParam !== null) {
        adminMode = adminParam.toLowerCase() === 'true';
      }
      
      const outOfServiceRouteColor = '#000000';
      
      let map;
      let markers = {};
      let routeColors = {};
      let routeLayers = [];
      let stopMarkers = [];
      let stopDataCache = [];
      let routeStopAddressMap = {};
      let routeStopRouteMap = {};
      let nameBubbles = {};
      let busBlocks = {};
      let previousBusData = {};
      let cachedEtas = {};
      let customPopups = [];
      let allRouteBounds = null;
      let mapHasFitAllRoutes = false;
      let refreshIntervals = [];

      let overlapRenderer = null;

      const STOP_GROUPING_PIXEL_DISTANCE = 20;
      const STOP_MARKER_ICON_SIZE = 24;
      const STOP_MARKER_BORDER_COLOR = '#000000';
      const STOP_MARKER_OUTLINE_COLOR = '#FFFFFF';
      const STOP_MARKER_OUTLINE_WIDTH = 2;

      let agencies = [];
      let baseURL = '';

      let routePolylineCache = new Map();
      let lastRouteRenderState = {
        selectionKey: '',
        colorSignature: '',
        geometrySignature: '',
        useOverlapRenderer: false
      };
      let lastRouteSelectorSignature = null;

      const DEFAULT_ROUTE_STROKE_WEIGHT = 6;
      const MIN_ROUTE_STROKE_WEIGHT = 3;
      const MAX_ROUTE_STROKE_WEIGHT = 12;
      const ROUTE_WEIGHT_ZOOM_DELTA_LIMIT = 3;
      const ROUTE_WEIGHT_BASE_ZOOM = 15;
      const ROUTE_WEIGHT_STEP_PER_ZOOM = 1;

      function computeRouteStrokeWeight(zoom) {
        const baseWeight = DEFAULT_ROUTE_STROKE_WEIGHT;
        const minWeight = MIN_ROUTE_STROKE_WEIGHT;
        const maxWeight = MAX_ROUTE_STROKE_WEIGHT;
        const targetZoom = Number.isFinite(zoom)
          ? zoom
          : (map && typeof map?.getZoom === 'function' ? map.getZoom() : null);
        if (!Number.isFinite(targetZoom)) {
          return Math.max(minWeight, Math.min(maxWeight, baseWeight));
        }
        const zoomDeltaRaw = targetZoom - ROUTE_WEIGHT_BASE_ZOOM;
        const limitedDelta = Math.max(-ROUTE_WEIGHT_ZOOM_DELTA_LIMIT, Math.min(ROUTE_WEIGHT_ZOOM_DELTA_LIMIT, zoomDeltaRaw));
        const computed = baseWeight + ROUTE_WEIGHT_STEP_PER_ZOOM * limitedDelta;
        if (!Number.isFinite(computed)) {
          return Math.max(minWeight, Math.min(maxWeight, baseWeight));
        }
        return Math.max(minWeight, Math.min(maxWeight, computed));
      }

      async function loadAgencies() {
        try {
          const response = await fetch('https://admin.ridesystems.net/api/Clients/GetClients');
          const contentType = response.headers.get('content-type') || '';
          let clients = [];
          if (contentType.includes('application/json')) {
            clients = await response.json();
          } else {
            const text = await response.text();
            const parser = new DOMParser();
            const xml = parser.parseFromString(text, 'application/xml');
            clients = Array.from(xml.getElementsByTagName('Client')).map(c => ({
              Name: c.getElementsByTagName('Name')[0]?.textContent.trim(),
              WebAddress: c.getElementsByTagName('WebAddress')[0]?.textContent.trim()
            }));
          }
          agencies = clients.map(c => {
            const name = c.Name?.trim();
            const webAddress = c.WebAddress?.trim();
            if (!name || !webAddress) return null;
            const url = webAddress.startsWith('http')
              ? webAddress.replace(/^http:\/\//i, 'https://')
              : `https://${webAddress}`;
            return { name, url };
          }).filter(Boolean);
          agencies.sort((a, b) => a.name.localeCompare(b.name));
          const uvaIndex = agencies.findIndex(a => a.name === 'University of Virginia');
          if (uvaIndex > -1) {
            const uva = agencies.splice(uvaIndex, 1)[0];
            agencies.unshift(uva);
          }
          const consent = localStorage.getItem('agencyConsent') === 'true';
          const storedAgency = consent ? localStorage.getItem('selectedAgency') : null;
          if (storedAgency && agencies.some(a => a.url === storedAgency)) {
            baseURL = storedAgency;
          } else {
            baseURL = agencies[0]?.url || '';
          }
          updateRouteSelector(activeRoutes, true);
        } catch (e) {
          console.error('Failed to load agencies', e);
        }
      }

      function positionRouteTab() {
        const panel = document.getElementById("routeSelector");
        const tab = document.getElementById("routeSelectorTab");
        if (!panel || !tab) return;
        const panelStyle = window.getComputedStyle(panel);
        const gap = parseFloat(panelStyle.right) || 0;
        const offset = panel.offsetWidth + gap;
        tab.style.right = panel.classList.contains("hidden") ? "0" : offset + "px";
      }

      window.addEventListener("load", positionRouteTab);
      window.addEventListener("resize", positionRouteTab);

      // Global storage for routes from GetRoutes.
      let allRoutes = {};
      // Global object to store user selections (for admin mode).
      let routeSelections = {};
      // Tracks routes that currently have at least one vehicle assigned.
      let activeRoutes = new Set();
      // Tracks which routes the API designates as public-facing.
      let routeVisibility = {};

      // Routes default to visible if they currently have vehicles unless the user
      // overrides the selection via the route selector.
      function isRouteSelected(routeID) {
        if (!canDisplayRoute(routeID)) return false;
        const id = Number(routeID);
        if (Number.isNaN(id)) return false;
        if (routeSelections.hasOwnProperty(id)) return routeSelections[id];
        return activeRoutes.has(id);
      }

      function setRouteVisibility(route) {
        if (!route || typeof route.RouteID === 'undefined') return;
        const id = Number(route.RouteID);
        if (Number.isNaN(id)) return;
        routeVisibility[id] = route.IsVisibleOnMap !== false;
      }

      function isRoutePublicById(routeID) {
        const id = Number(routeID);
        if (Number.isNaN(id) || id === 0) return false;
        if (Object.prototype.hasOwnProperty.call(routeVisibility, id)) {
          return routeVisibility[id];
        }
        return true;
      }

      function canDisplayRoute(routeID) {
        const id = Number(routeID);
        if (Number.isNaN(id)) return false;
        if (id === 0) {
          return adminKioskMode || (!kioskMode && adminMode);
        }
        if (adminKioskMode) return true;
        if (kioskMode) return isRoutePublicById(id);
        if (adminMode) return true;
        return isRoutePublicById(id);
      }

      // Toggle between displaying speed or block numbers.
      function toggleSpeedOrBlock() {
        if (showSpeed) {
          showSpeed = false;
          showBlockNumbers = true;
        } else {
          showSpeed = true;
          showBlockNumbers = false;
        }
        document.getElementById("toggleDisplayButton").innerHTML = showSpeed ? "Show Block Numbers" : "Show Speed";
        refreshMap();
      }

      // updateRouteSelector rebuilds the route selector panel.
      // The list (excluding Out of Service) is alphabetized and defaults to
      // checking only routes that currently have vehicles.
      function updateRouteSelector(activeRoutesParam, forceUpdate = false) {
        const container = document.getElementById("routeSelector");
        if (!container) return;

        const activeRoutesSet = activeRoutesParam instanceof Set
          ? activeRoutesParam
          : new Set(Array.isArray(activeRoutesParam) ? activeRoutesParam : []);

        if (forceUpdate) {
          lastRouteSelectorSignature = null;
        }

        const agencyDropdown = document.getElementById('agencySelect');
        if (!forceUpdate && agencyDropdown && document.activeElement === agencyDropdown) {
          return;
        }

        let routeIDs = Object.keys(allRoutes)
          .map(id => Number(id))
          .filter(id => !Number.isNaN(id) && id !== 0 && canDisplayRoute(id));

        routeIDs.sort((a, b) => {
          let descA = (allRoutes[a]?.Description || '').toUpperCase();
          let descB = (allRoutes[b]?.Description || '').toUpperCase();
          if (descA < descB) return -1;
          if (descA > descB) return 1;
          return 0;
        });

        const agenciesSignature = agencies
          .map(a => `${a.url || ''}::${a.name || ''}`)
          .join('|');

        const routeSignatureParts = routeIDs.map(routeID => {
          const route = allRoutes[routeID] || {};
          const checked = Object.prototype.hasOwnProperty.call(routeSelections, routeID)
            ? routeSelections[routeID]
            : activeRoutesSet.has(routeID);
          const infoText = typeof route.InfoText === 'string' ? route.InfoText.trim() : '';
          const desc = typeof route.Description === 'string' ? route.Description.trim() : '';
          const color = route.MapLineColor || '';
          return `${routeID}:${checked ? 1 : 0}:${color}:${desc}:${infoText}`;
        });

        const outOfServiceChecked = adminMode && canDisplayRoute(0)
          ? (Object.prototype.hasOwnProperty.call(routeSelections, 0)
            ? routeSelections[0]
            : activeRoutesSet.has(0))
          : null;

        const signatureParts = [
          baseURL,
          adminMode ? '1' : '0',
          kioskMode ? '1' : '0',
          adminKioskMode ? '1' : '0',
          showSpeed ? '1' : '0',
          showBlockNumbers ? '1' : '0',
          agenciesSignature,
          outOfServiceChecked === null ? 'na' : (outOfServiceChecked ? '1' : '0'),
          routeSignatureParts.join('|')
        ];

        const signature = signatureParts.join('||');
        if (!forceUpdate && signature === lastRouteSelectorSignature) {
          positionRouteTab();
          return;
        }
        lastRouteSelectorSignature = signature;

        let html = "";
        html += "<label for='agencySelect'>Select System:</label>";
        html += "<select id='agencySelect' onchange='changeAgency(this.value)'>";
        agencies.forEach(a => {
          html += `<option value="${a.url}" ${a.url === baseURL ? 'selected' : ''}>${a.name}</option>`;
        });
        html += "</select><br/><br/>";
        if (adminMode) {
          html += "<div style='margin-bottom:10px;'><button id='toggleDisplayButton' onclick='toggleSpeedOrBlock()'>" + (showSpeed ? "Show Block Numbers" : "Show Speed") + "</button></div>";
        }
        html += "<h3>Select Routes</h3>" +
          "<button onclick='selectAllRoutes()'>Select All</button>" +
          "<button onclick='deselectAllRoutes()'>Deselect All</button><br/><br/>";

        if (adminMode && canDisplayRoute(0)) {
          let outChecked = Object.prototype.hasOwnProperty.call(routeSelections, 0) ? routeSelections[0] : activeRoutesSet.has(0);
          html += `<label>
            <input type="checkbox" id="route_0" value="0" ${outChecked ? "checked" : ""}>
            <span class="color-box" style="background:${outOfServiceRouteColor};"></span> Out of Service
          </label>`;
        }

        routeIDs.forEach(routeID => {
          const route = allRoutes[routeID] || {};
          const checked = Object.prototype.hasOwnProperty.call(routeSelections, routeID)
            ? routeSelections[routeID]
            : activeRoutesSet.has(routeID);
          let displayName = route.Description || '';
          if (route.InfoText && route.InfoText.trim() !== "") {
            displayName += ` &ndash; ${route.InfoText.trim()}`;
          }
          html += `<label>
            <input type="checkbox" id="route_${routeID}" value="${routeID}" ${checked ? "checked" : ""}>
            <span class="color-box" style="background:${route.MapLineColor};"></span> ${displayName}
          </label>`;
        });

        container.innerHTML = html;

        let outChk = document.getElementById("route_0");
        if (outChk) {
          outChk.addEventListener("change", function() {
            routeSelections[0] = outChk.checked;
            refreshMap();
          });
        }
        routeIDs.forEach(routeID => {
          if (!canDisplayRoute(routeID) || Number(routeID) === 0) return;
          let chk = document.getElementById("route_" + routeID);
          if (chk) {
            chk.addEventListener("change", function() {
              routeSelections[routeID] = chk.checked;
              refreshMap();
            });
          }
        });

        positionRouteTab();
      }

      function selectAllRoutes() {
        if (adminMode && canDisplayRoute(0)) {
          let outChk = document.getElementById("route_0");
          if (outChk) outChk.checked = true;
          routeSelections[0] = true;
        }
        for (let routeID in allRoutes) {
          if (!canDisplayRoute(routeID) || Number(routeID) === 0) continue;
          let chk = document.getElementById("route_" + routeID);
          if (chk) chk.checked = true;
          routeSelections[routeID] = true;
        }
        refreshMap();
      }

      function deselectAllRoutes() {
        if (adminMode && canDisplayRoute(0)) {
          let outChk = document.getElementById("route_0");
          if (outChk) outChk.checked = false;
          routeSelections[0] = false;
        }
        for (let routeID in allRoutes) {
          if (!canDisplayRoute(routeID) || Number(routeID) === 0) continue;
          let chk = document.getElementById("route_" + routeID);
          if (chk) chk.checked = false;
          routeSelections[routeID] = false;
        }
        refreshMap();
      }

      // togglePanel toggles the route selector panel's visibility.
      function togglePanel() {
        let panel = document.getElementById("routeSelector");
        let tab = document.getElementById("routeSelectorTab");
        if (panel.classList.contains("hidden")) {
          panel.classList.remove("hidden");
          tab.innerHTML = "&#9664;"; // left arrow
        } else {
          panel.classList.add("hidden");
          tab.innerHTML = "&#9654;"; // right arrow
        }
        positionRouteTab();
      }

      function updateRouteLegend(displayedRoutes = []) {
        const legend = document.getElementById("routeLegend");
        if (!legend) return;
        const shouldShowLegend = kioskMode || adminKioskMode;
        if (!shouldShowLegend) {
          legend.style.display = "none";
          legend.innerHTML = "";
          return;
        }

        // Admin kiosk mode should surface every visible route, including those hidden from the public map.
        // Public kiosk mode must continue to hide routes flagged as non-public.
        const routesToRender = adminKioskMode
          ? displayedRoutes
          : displayedRoutes.filter(route => isRoutePublicById(route.routeId ?? route.routeID ?? route.id));

        if (routesToRender.length === 0) {
          legend.style.display = "none";
          legend.innerHTML = "";
          return;
        }

        legend.style.display = "block";
        legend.innerHTML = "";

        const title = document.createElement("div");
        title.className = "legend-title";
        title.textContent = "Routes";
        legend.appendChild(title);

        routesToRender.forEach(route => {
          const item = document.createElement("div");
          item.className = "legend-item";

          const color = document.createElement("span");
          color.className = "legend-color";
          color.style.backgroundColor = route.color || "#000000";
          item.appendChild(color);

          const textContainer = document.createElement("div");
          textContainer.className = "legend-text";

          const name = document.createElement("div");
          name.className = "legend-name";
          name.textContent = route.name;
          textContainer.appendChild(name);

          if (route.description) {
            const description = document.createElement("div");
            description.className = "legend-description";
            description.textContent = route.description;
            textContainer.appendChild(description);
          }

          item.appendChild(textContainer);
          legend.appendChild(item);
        });
      }

      // refreshMap updates route paths and bus locations.
      function refreshMap() {
        fetchBusLocations().then(fetchRoutePaths);
        if (Array.isArray(stopDataCache) && stopDataCache.length > 0) {
          renderBusStops(stopDataCache);
        }
      }

      function clearRefreshIntervals() {
        refreshIntervals.forEach(clearInterval);
        refreshIntervals = [];
      }

      function startRefreshIntervals() {
        refreshIntervals.push(setInterval(fetchBusLocations, 4000));
        refreshIntervals.push(setInterval(fetchBusStops, 60000));
        refreshIntervals.push(setInterval(fetchBlockAssignments, 60000));
        refreshIntervals.push(setInterval(() => {
          fetchStopArrivalTimes().then(allEtas => {
            cachedEtas = allEtas;
            updateCustomPopups();
          });
        }, 15000));
        refreshIntervals.push(setInterval(fetchRoutePaths, 15000));
      }

      function showCookieBanner() {
        if (kioskMode || adminKioskMode) {
          return;
        }
        if (localStorage.getItem('agencyConsent') !== 'true') {
          const banner = document.getElementById('cookieBanner');
          banner.style.display = 'block';
          document.getElementById('cookieAccept').addEventListener('click', () => {
            localStorage.setItem('agencyConsent', 'true');
            localStorage.setItem('selectedAgency', baseURL);
            banner.style.display = 'none';
          });
        }
      }

      function changeAgency(url) {
        if (localStorage.getItem('agencyConsent') === 'true') {
          localStorage.setItem('selectedAgency', url);
        }
        clearRefreshIntervals();
        baseURL = url;
        Object.values(markers).forEach(m => map.removeLayer(m));
        markers = {};
        Object.values(nameBubbles).forEach(b => {
          if (b.speedMarker) map.removeLayer(b.speedMarker);
          if (b.nameMarker) map.removeLayer(b.nameMarker);
          if (b.blockMarker) map.removeLayer(b.blockMarker);
        });
        nameBubbles = {};
        stopMarkers.forEach(m => map.removeLayer(m));
        stopMarkers = [];
        routeLayers.forEach(l => map.removeLayer(l));
        routeLayers = [];
        routePolylineCache.clear();
        lastRouteRenderState = {
          selectionKey: '',
          colorSignature: '',
          geometrySignature: '',
          useOverlapRenderer: !!(enableOverlapDashRendering && overlapRenderer)
        };
        lastRouteSelectorSignature = null;
        if (overlapRenderer) {
          overlapRenderer.reset();
        }
        busBlocks = {};
        previousBusData = {};
        cachedEtas = {};
        customPopups.forEach(p => p.remove());
        customPopups = [];
        allRoutes = {};
        routeSelections = {};
        routeStopAddressMap = {};
        routeStopRouteMap = {};
        activeRoutes = new Set();
        routeColors = {};
        routeVisibility = {};
        allRouteBounds = null;
        mapHasFitAllRoutes = false;
        updateRouteLegend([]);
        updateRouteSelector(new Set(), true);
        fetchRouteColors().then(() => {
          fetchBusStops();
          fetchBlockAssignments();
          fetchBusLocations().then(fetchRoutePaths);
          fetchStopArrivalTimes().then(allEtas => { cachedEtas = allEtas; updateCustomPopups(); });
          startRefreshIntervals();
        });
      }

      function getRouteColor(routeID) {
        if (routeID === 0) return outOfServiceRouteColor;
        return routeColors[routeID] || '#000000';
      }

      function initMap() {
          map = L.map('map', {
              zoomControl: false,
              crs: L.CRS.EPSG3857,
              zoomAnimation: true,
              markerZoomAnimation: true
          }).setView([38.03799212281404, -78.50981502838886], 15);
          sharedRouteRenderer = L.svg({ padding: 0 });
          if (sharedRouteRenderer) {
              map.addLayer(sharedRouteRenderer);
          }
          map.createPane('stopsPane');
          const stopsPane = map.getPane('stopsPane');
          if (stopsPane) {
              stopsPane.style.zIndex = 450;
              stopsPane.style.pointerEvents = 'auto';
          }
          const cartoLight = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
              attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>'
          });
          cartoLight.addTo(map);

          if (enableOverlapDashRendering) {
            overlapRenderer = new OverlapRouteRenderer(map, {
              sampleStepPx: 8,
              dashLengthPx: 16,
              minDashLengthPx: 0.5,
              matchTolerancePx: 6,
              strokeWeight: DEFAULT_ROUTE_STROKE_WEIGHT,
              minStrokeWeight: MIN_ROUTE_STROKE_WEIGHT,
              maxStrokeWeight: MAX_ROUTE_STROKE_WEIGHT,
              renderer: sharedRouteRenderer,
              pane: routePaneName
            });
            map.on('zoomend', () => {
              if (overlapRenderer) {
                overlapRenderer.handleZoomEnd();
              }
            });
          }

          fetchRouteColors().then(() => {
              if (kioskMode || adminKioskMode) {
                document.getElementById("routeSelector").style.display = "none";
                document.getElementById("routeSelectorTab").style.display = "none";
              }
              fetchStopArrivalTimes().then(allEtas => {
                  cachedEtas = allEtas;
                  updateCustomPopups();
              });
              fetchBusStops();
              fetchBlockAssignments();
              fetchBusLocations().then(fetchRoutePaths);
              startRefreshIntervals();
          });
          fetchStopArrivalTimes().then(allEtas => { cachedEtas = allEtas; });
          map.on('zoom', () => {
              updatePopupPositions();
          });
          map.on('move', () => {
              updatePopupPositions();
          });
          map.on('zoomend', () => {
              if (stopDataCache.length > 0) {
                  renderBusStops(stopDataCache);
              }
              updatePopupPositions();
          });
      }

      function fetchBusStops() {
          const currentBaseURL = baseURL;
          const stopsApiUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetStops?APIKey=8882812681`;
          fetch(stopsApiUrl)
              .then(response => response.json())
              .then(data => {
                  if (currentBaseURL !== baseURL) return;
                  let stopsArray = data.stops || data;
                  if (stopsArray && Array.isArray(stopsArray)) {
                      stopDataCache = stopsArray;
                      renderBusStops(stopDataCache);
                  }
              })
              .catch(error => console.error("Error fetching bus stops:", error));
      }

      function groupStopsByPixelDistance(stops, thresholdPx) {
          if (!Array.isArray(stops) || stops.length === 0) {
              return [];
          }

          const validStops = stops.map(stop => {
              const latitude = parseFloat(stop.Latitude ?? stop.latitude ?? stop.lat);
              const longitude = parseFloat(stop.Longitude ?? stop.longitude ?? stop.lon);
              if (!Number.isFinite(latitude) || !Number.isFinite(longitude)) {
                  return null;
              }
              return { latitude, longitude, stop };
          }).filter(entry => entry !== null);

          if (!map) {
              return validStops.map(entry => ({
                  latitude: entry.latitude,
                  longitude: entry.longitude,
                  stops: [entry.stop]
              }));
          }

          const groups = [];
          validStops.forEach(({ latitude, longitude, stop }) => {
              const stopPoint = map.latLngToLayerPoint([latitude, longitude]);
              let targetGroup = null;
              for (const group of groups) {
                  const groupPoint = map.latLngToLayerPoint([group.latitude, group.longitude]);
                  if (stopPoint.distanceTo(groupPoint) <= thresholdPx) {
                      targetGroup = group;
                      break;
                  }
              }
              if (targetGroup) {
                  targetGroup.stops.push(stop);
                  const totalStops = targetGroup.stops.length;
                  targetGroup.latitude = (targetGroup.latitude * (totalStops - 1) + latitude) / totalStops;
                  targetGroup.longitude = (targetGroup.longitude * (totalStops - 1) + longitude) / totalStops;
              } else {
                  groups.push({
                      latitude,
                      longitude,
                      stops: [stop]
                  });
              }
          });

          return groups;
      }

      function sanitizeStopName(name) {
          if (typeof name !== 'string') {
              return '';
          }
          return name.replace(/^Stop Name:\s*/i, '').trim();
      }

      function normalizeIdentifier(value) {
          if (value === undefined || value === null) {
              return null;
          }
          const str = `${value}`.trim();
          return str === '' ? null : str;
      }

      function getSelectedRouteIdSet() {
          const selected = new Set();
          Object.keys(allRoutes).forEach(routeId => {
              const numericId = Number(routeId);
              if (!Number.isNaN(numericId) && isRouteSelected(numericId)) {
                  selected.add(numericId);
              }
          });
          return selected;
      }

      function buildStopEntriesFromStops(stops) {
          if (!Array.isArray(stops)) {
              return [];
          }

          const entriesByKey = new Map();
          stops.forEach(stop => {
              if (!stop) {
                  return;
              }

              const latitude = stop.Latitude ?? stop.latitude ?? stop.lat;
              const longitude = stop.Longitude ?? stop.longitude ?? stop.lon;
              const routeStopId = normalizeIdentifier(stop.RouteStopID ?? stop.RouteStopId);
              const addressIdFromStop = normalizeIdentifier(stop.AddressID ?? stop.AddressId);
              const addressIdFromMap = routeStopId ? normalizeIdentifier(routeStopAddressMap[routeStopId]) : null;
              const fallbackStopId = normalizeIdentifier(stop.StopID ?? stop.StopId);

              const key = addressIdFromStop
                  || addressIdFromMap
                  || (routeStopId ? `ROUTESTOP_${routeStopId}`
                      : (fallbackStopId ? `STOP_${fallbackStopId}`
                          : `LOC_${latitude}_${longitude}`));

              if (!entriesByKey.has(key)) {
                  entriesByKey.set(key, {
                      addressId: addressIdFromStop || addressIdFromMap || null,
                      routeStopIds: new Set(),
                      stopIds: new Set(),
                      names: new Set(),
                      routeIds: new Set()
                  });
              }

              const entry = entriesByKey.get(key);

              if (routeStopId) {
                  entry.routeStopIds.add(routeStopId);
              }

              if (fallbackStopId) {
                  entry.stopIds.add(fallbackStopId);
              }

              const descriptionCandidates = [
                  stop.Description,
                  stop.Name,
                  stop.StopName,
                  stop.Line1,
                  stop.SignVerbiage
              ];
              const name = descriptionCandidates.find(value => typeof value === 'string' && value.trim() !== '');
              if (name) {
                  entry.names.add(sanitizeStopName(name));
              }

              const routeIdRaw = stop.RouteID ?? stop.RouteId;
              const routeIdNumeric = Number(routeIdRaw);
              if (!Number.isNaN(routeIdNumeric)) {
                  entry.routeIds.add(routeIdNumeric);
              }

              const routesArray = Array.isArray(stop.Routes) ? stop.Routes : [];
              routesArray.forEach(routeInfo => {
                  const candidateRouteId = Number(routeInfo?.RouteID ?? routeInfo?.RouteId ?? routeInfo?.Id);
                  if (!Number.isNaN(candidateRouteId)) {
                      entry.routeIds.add(candidateRouteId);
                  }
              });

              const routeIdsList = Array.isArray(stop.RouteIDs ?? stop.RouteIds)
                  ? (stop.RouteIDs ?? stop.RouteIds)
                  : [];
              routeIdsList.forEach(routeIdValue => {
                  const numericRouteId = Number(routeIdValue);
                  if (!Number.isNaN(numericRouteId)) {
                      entry.routeIds.add(numericRouteId);
                  }
              });
          });

          return Array.from(entriesByKey.values()).map(entry => ({
              addressId: entry.addressId,
              routeStopIds: Array.from(entry.routeStopIds),
              stopIdText: Array.from(entry.stopIds).join(', '),
              displayName: entry.names.size > 0 ? Array.from(entry.names).join(' / ') : 'Stop',
              routeIds: Array.from(entry.routeIds)
          }));
      }

      function collectRouteIdsForEntry(entry) {
          const routeIds = new Set();
          if (!entry) {
              return routeIds;
          }
          if (Array.isArray(entry.routeIds)) {
              entry.routeIds.forEach(routeId => {
                  const numeric = Number(routeId);
                  if (!Number.isNaN(numeric)) {
                      routeIds.add(numeric);
                  }
              });
          }
          if (Array.isArray(entry.routeStopIds)) {
              entry.routeStopIds.forEach(routeStopId => {
                  const mapped = routeStopRouteMap[routeStopId];
                  const numeric = Number(mapped);
                  if (!Number.isNaN(numeric)) {
                      routeIds.add(numeric);
                  }
              });
          }
          return routeIds;
      }

      function collectRouteIdsForStop(stop) {
          const routeIds = new Set();
          if (!stop) {
              return routeIds;
          }

          const addRouteId = value => {
              if (value === undefined || value === null) {
                  return;
              }
              let candidate = value;
              if (typeof candidate === 'string') {
                  candidate = candidate.trim();
                  if (candidate === '') {
                      return;
                  }
              }
              const numericRouteId = Number(candidate);
              if (!Number.isNaN(numericRouteId)) {
                  routeIds.add(numericRouteId);
              }
          };

          addRouteId(stop.RouteID ?? stop.RouteId);

          const routeStopId = normalizeIdentifier(stop.RouteStopID ?? stop.RouteStopId);
          if (routeStopId) {
              addRouteId(routeStopRouteMap[routeStopId]);
          }

          const routeIdsList = Array.isArray(stop.RouteIDs ?? stop.RouteIds)
              ? (stop.RouteIDs ?? stop.RouteIds)
              : [];
          routeIdsList.forEach(routeIdValue => addRouteId(routeIdValue));

          const routesArray = Array.isArray(stop.Routes) ? stop.Routes : [];
          routesArray.forEach(routeInfo => {
              addRouteId(routeInfo?.RouteID ?? routeInfo?.RouteId ?? routeInfo?.Id ?? routeInfo);
          });

          const singleRoute = stop.Route ?? stop.route;
          if (singleRoute && typeof singleRoute === 'object') {
              addRouteId(singleRoute.RouteID ?? singleRoute.RouteId ?? singleRoute.Id);
          }

          return routeIds;
      }

      function buildStopMarkerGradient(routeIds) {
          const colors = Array.from(new Set((Array.isArray(routeIds) ? routeIds : [])
              .map(routeId => getRouteColor(routeId))
              .filter(color => typeof color === 'string' && color.trim() !== '')));

          if (colors.length === 0) {
              return '#FFFFFF';
          }
          if (colors.length === 1) {
              return colors[0];
          }

          const segmentSize = 360 / colors.length;
          const segments = colors.map((color, index) => {
              const start = segmentSize * index;
              const end = segmentSize * (index + 1);
              return `${color} ${start}deg ${end}deg`;
          });
          return `conic-gradient(${segments.join(', ')})`;
      }

      function createStopMarkerIcon(routeIds) {
          const gradient = buildStopMarkerGradient(routeIds);
          const size = STOP_MARKER_ICON_SIZE;
          const outline = Math.max(0, Number(STOP_MARKER_OUTLINE_WIDTH) || 0);
          const html = `<div class="stop-marker-outer" style="width: ${size}px; height: ${size}px; border: 2px solid ${STOP_MARKER_BORDER_COLOR}; box-shadow: 0 0 0 ${outline}px ${STOP_MARKER_OUTLINE_COLOR}; background: ${gradient};"></div>`;
          return L.divIcon({
              className: 'stop-marker-container leaflet-div-icon',
              html,
              iconSize: [size, size],
              iconAnchor: [size / 2, size / 2]
          });
      }

      function createStopGroupKey(routeStopIds, fallbackStopIdText) {
          const normalizedIds = Array.isArray(routeStopIds)
              ? Array.from(new Set(routeStopIds
                  .map(id => `${id}`)
                  .map(value => value.trim())
                  .filter(value => value !== '' && value.toLowerCase() !== 'undefined' && value.toLowerCase() !== 'null')))
                  .sort((a, b) => a.localeCompare(b, undefined, { numeric: true }))
              : [];
          return `${JSON.stringify(normalizedIds)}|${fallbackStopIdText || ''}`;
      }

      function buildEtaTableHtml(routeStopIds) {
          const normalizedRouteStopIds = Array.isArray(routeStopIds) ? routeStopIds : [];
          const etas = [];
          normalizedRouteStopIds.forEach(routeStopId => {
              if (cachedEtas[routeStopId]) {
                  cachedEtas[routeStopId].forEach(eta => etas.push(eta));
              }
          });
          const etaRows = etas.length > 0
              ? etas.sort((a, b) => a.etaMinutes - b.etaMinutes || a.routeDescription.localeCompare(b.routeDescription))
                    .map(eta => `<tr><td style="padding: 5px; text-align: center;"><div class="route-pill" style="background-color: ${getRouteColor(eta.RouteId)}; color: ${getContrastColor(getRouteColor(eta.RouteId))};">${eta.routeDescription}</div></td><td style="padding: 5px; text-align: center;">${eta.etaMinutes < 1 ? 'Arriving' : eta.etaMinutes + ' min'}</td></tr>`)
                    .join('')
              : '<tr><td colspan="2" style="padding: 5px; text-align: center;">No upcoming arrivals</td></tr>';
          return `
            <table style="width: 100%; margin-top: 10px; border-collapse: collapse;">
              <thead>
                <tr>
                  <th style="border-bottom: 1px solid white; padding: 5px;">Route</th>
                  <th style="border-bottom: 1px solid white; padding: 5px;">ETA</th>
                </tr>
              </thead>
              <tbody>
                ${etaRows}
              </tbody>
            </table>
          `;
      }

      function buildStopEntriesSectionHtml(stopEntries, multipleStops) {
          if (!Array.isArray(stopEntries) || stopEntries.length === 0) {
              return '<div style="margin-top: 10px;">No upcoming arrivals</div>';
          }

          if (!multipleStops) {
              const entry = stopEntries[0];
              return buildEtaTableHtml(entry?.routeStopIds || []);
          }

          return stopEntries.map(entry => {
              const entryTitle = entry.displayName ? `<span class="stop-entry-title">${sanitizeStopName(entry.displayName)}</span>` : '';
              const entryIdLine = entry.stopIdText ? `<span class="stop-entry-id">Stop ID: ${entry.stopIdText}</span>` : '';
              const tableHtml = buildEtaTableHtml(entry.routeStopIds || []);
              return `<div class="stop-entry">${entryTitle}${entryIdLine}${tableHtml}</div>`;
          }).join('');
      }

      function setPopupContent(popupElement, groupInfo) {
          if (!popupElement || !groupInfo) {
              return;
          }

          const stopEntries = Array.isArray(groupInfo.stopEntries) ? groupInfo.stopEntries : [];
          const aggregatedRouteStopIds = Array.isArray(groupInfo.aggregatedRouteStopIds)
              ? groupInfo.aggregatedRouteStopIds
              : [];
          const fallbackStopIdText = typeof groupInfo.fallbackStopId === 'string'
              ? groupInfo.fallbackStopId
              : normalizeIdentifier(groupInfo.fallbackStopId) || '';
          const sanitizedStopName = sanitizeStopName(groupInfo.stopName || '');
          const multipleStops = stopEntries.length > 1;
          const primaryStopIdText = !multipleStops
              ? (stopEntries[0]?.stopIdText || fallbackStopIdText)
              : '';
          const entriesHtml = buildStopEntriesSectionHtml(stopEntries, multipleStops);
          const groupKey = groupInfo.groupKey || createStopGroupKey(aggregatedRouteStopIds, fallbackStopIdText);

          popupElement.dataset.routeStopIds = JSON.stringify(aggregatedRouteStopIds);
          popupElement.dataset.stopEntries = JSON.stringify(stopEntries);
          popupElement.dataset.stopName = sanitizedStopName;
          popupElement.dataset.fallbackStopId = fallbackStopIdText;
          popupElement.dataset.stopId = primaryStopIdText || '';
          popupElement.dataset.groupKey = groupKey;

          const stopIdLine = primaryStopIdText ? `<span>Stop ID: ${primaryStopIdText}</span><br>` : '';

          popupElement.innerHTML = `
            <button class="custom-popup-close">&times;</button>
            ${stopIdLine}
            ${entriesHtml}
            <div class="custom-popup-arrow"></div>
          `;

          popupElement.querySelector('.custom-popup-close').addEventListener('click', () => {
              popupElement.remove();
              customPopups = customPopups.filter(popup => popup !== popupElement);
          });
      }

      function renderBusStops(stopsArray) {
          if (!Array.isArray(stopsArray) || !map) {
              return;
          }

          stopMarkers.forEach(marker => map.removeLayer(marker));
          stopMarkers = [];

          const selectedRouteIdsSet = getSelectedRouteIdSet();

          const stopsForSelectedRoutes = selectedRouteIdsSet.size > 0
              ? stopsArray.filter(stop => {
                  const routeIds = collectRouteIdsForStop(stop);
                  if (routeIds.size === 0) {
                      return false;
                  }
                  for (const routeId of routeIds) {
                      if (selectedRouteIdsSet.has(routeId)) {
                          return true;
                      }
                  }
                  return false;
              })
              : [];

          const groupedStops = groupStopsByPixelDistance(stopsForSelectedRoutes, STOP_GROUPING_PIXEL_DISTANCE);
          const groupedData = [];

          groupedStops.forEach(group => {
              const stopEntries = buildStopEntriesFromStops(group.stops);
              if (stopEntries.length === 0) {
                  return;
              }

              const allRouteIdsForMarker = new Set();
              stopEntries.forEach(entry => {
                  collectRouteIdsForEntry(entry).forEach(routeId => {
                      if (!Number.isNaN(routeId)) {
                          allRouteIdsForMarker.add(routeId);
                      }
                  });
              });

              if (allRouteIdsForMarker.size === 0) {
                  group.stops.forEach(stop => {
                      collectRouteIdsForStop(stop).forEach(routeId => {
                          allRouteIdsForMarker.add(routeId);
                      });
                  });
              }

              const servesSelectedRoute = selectedRouteIdsSet.size > 0
                  ? Array.from(allRouteIdsForMarker).some(routeId => selectedRouteIdsSet.has(routeId))
                  : false;

              if (!servesSelectedRoute) {
                  return;
              }

              const stopPosition = [group.latitude, group.longitude];
              const aggregatedRouteStopIds = Array.from(new Set(stopEntries.flatMap(entry => entry.routeStopIds)))
                  .map(id => `${id}`)
                  .sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
              const fallbackStopIdSet = new Set();
              stopEntries.forEach(entry => {
                  if (typeof entry.stopIdText === 'string' && entry.stopIdText.trim() !== '') {
                      entry.stopIdText.split(',').forEach(value => {
                          const trimmed = value.trim();
                          if (trimmed) {
                              fallbackStopIdSet.add(trimmed);
                          }
                      });
                  }
              });
              const fallbackStopIdText = Array.from(fallbackStopIdSet)
                  .sort((a, b) => a.localeCompare(b, undefined, { numeric: true }))
                  .join(', ');
              const displayStopName = Array.from(new Set(stopEntries
                  .map(entry => sanitizeStopName(entry.displayName))
                  .filter(Boolean)))
                  .join(' / ') || 'Stop';
              const groupKey = createStopGroupKey(aggregatedRouteStopIds, fallbackStopIdText);
              const markerRouteIds = Array.from(allRouteIdsForMarker)
                  .filter(routeId => selectedRouteIdsSet.has(routeId))
                  .sort((a, b) => a - b);
              const markerIcon = createStopMarkerIcon(markerRouteIds);

              const groupInfo = {
                  position: stopPosition,
                  stopName: displayStopName,
                  fallbackStopId: fallbackStopIdText,
                  stopEntries,
                  aggregatedRouteStopIds,
                  groupKey
              };

              const stopMarker = L.marker(stopPosition, {
                  icon: markerIcon,
                  pane: 'stopsPane'
              }).addTo(map);

              stopMarker.on('click', () => {
                  createCustomPopup(groupInfo);
              });

              stopMarkers.push(stopMarker);
              groupedData.push(groupInfo);
          });

          stopMarkers.forEach(marker => {
              if (!marker) return;
              if (typeof marker.bringToFront === 'function') {
                  marker.bringToFront();
                  return;
              }
              if (typeof marker.setZIndexOffset === 'function') {
                  marker.setZIndexOffset(1000);
              }
          });

          if (customPopups.length > 0) {
              const groupByKey = new Map();
              groupedData.forEach(groupInfo => {
                  groupByKey.set(groupInfo.groupKey, groupInfo);
              });

              customPopups = customPopups.filter(popupElement => {
                  let parsedRouteStopIds = [];
                  try {
                      parsedRouteStopIds = JSON.parse(popupElement.dataset.routeStopIds || '[]');
                  } catch (error) {
                      parsedRouteStopIds = [];
                  }
                  const fallbackId = popupElement.dataset.fallbackStopId || '';
                  const key = popupElement.dataset.groupKey || createStopGroupKey(parsedRouteStopIds, fallbackId);
                  const matchingGroup = groupByKey.get(key);
                  if (matchingGroup) {
                      popupElement.dataset.position = `${matchingGroup.position[0]},${matchingGroup.position[1]}`;
                      setPopupContent(popupElement, matchingGroup);
                      updatePopupPosition(popupElement, matchingGroup.position);
                      return true;
                  }
                  popupElement.remove();
                  return false;
              });
          }
      }

      function createCustomPopup(groupInfo) {
          if (!groupInfo || !Array.isArray(groupInfo.position) || groupInfo.position.length !== 2) {
              return;
          }
          const position = groupInfo.position;
          customPopups.forEach(popup => popup.remove());
          customPopups = [];
          const popupElement = document.createElement('div');
          popupElement.className = 'custom-popup';
          document.body.appendChild(popupElement);
          popupElement.dataset.position = `${position[0]},${position[1]}`;
          setPopupContent(popupElement, groupInfo);
          updatePopupPosition(popupElement, position);
          customPopups.push(popupElement);
      }

      function updatePopupPosition(popupElement, position) {
          if (!map || typeof map?.latLngToContainerPoint !== 'function') {
              return;
          }
          const mapPos = map.latLngToContainerPoint(position);
          popupElement.style.left = `${mapPos.x}px`;
          popupElement.style.top = `${mapPos.y}px`;
      }

      function updatePopupPositions() {
          if (!map || typeof map?.latLngToContainerPoint !== 'function') {
              return;
          }
          const zooming = !!(map?._animatingZoom || (map?._zoomAnimated && map?._zooming));
          if (zooming) {
              return;
          }
          customPopups.forEach(popupElement => {
              const position = popupElement.dataset.position;
              if (position) {
                  const [latitude, longitude] = position.split(',').map(Number);
                  updatePopupPosition(popupElement, [latitude, longitude]);
              }
          });
      }

      function updateCustomPopups() {
          customPopups.forEach(popupElement => {
              const position = popupElement.dataset.position;
              if (position) {
                  let routeStopIds = [];
                  let stopEntries = [];
                  try {
                      routeStopIds = JSON.parse(popupElement.dataset.routeStopIds || '[]');
                  } catch (error) {
                      routeStopIds = [];
                  }
                  try {
                      stopEntries = JSON.parse(popupElement.dataset.stopEntries || '[]');
                  } catch (error) {
                      stopEntries = [];
                  }
                  const fallbackStopId = popupElement.dataset.fallbackStopId || '';
                  const stopName = popupElement.dataset.stopName || '';
                  const groupKey = popupElement.dataset.groupKey || createStopGroupKey(routeStopIds, fallbackStopId);
                  const groupInfo = {
                      position: position.split(',').map(Number),
                      stopName,
                      fallbackStopId,
                      stopEntries,
                      aggregatedRouteStopIds: routeStopIds,
                      groupKey
                  };
                  setPopupContent(popupElement, groupInfo);
              }
          });
      }

      function fetchStopArrivalTimes() {
          const currentBaseURL = baseURL;
          const arrivalTimesApiUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetStopArrivalTimes?APIKey=8882812681`;
          return fetch(arrivalTimesApiUrl)
              .then(response => response.json())
              .then(data => {
                  if (currentBaseURL !== baseURL) return {};
                  let allEtas = {};
                  data.forEach(arrival => {
                      if (!allEtas[arrival.RouteStopId]) {
                          allEtas[arrival.RouteStopId] = [];
                      }
                      arrival.Times.forEach(time => {
                          const etaMinutes = Math.round(time.Seconds / 60);
                          allEtas[arrival.RouteStopId].push({
                              routeDescription: (arrival.RouteDescription === 'Night Pilot' ? arrival.RouteDescription : arrival.RouteDescription.slice(0, -5)),
                              etaMinutes: etaMinutes,
                              RouteId: arrival.RouteId
                          });
                      });
                  });
                  return allEtas;
              })
              .catch(error => {
                  console.error("Error fetching stop arrival times:", error);
                  return {};
              });
      }


      class OverlapRouteRenderer {
        constructor(map, options = {}) {
          this.map = map;
          this.options = Object.assign({
            sampleStepPx: 8,
            dashLengthPx: 16,
            minDashLengthPx: 0.5,
            matchTolerancePx: 6,
            headingToleranceDeg: 20,
            simplifyTolerancePx: 0.75,
            latLngEqualityMargin: 1e-9,
            strokeWeight: DEFAULT_ROUTE_STROKE_WEIGHT,
            minStrokeWeight: MIN_ROUTE_STROKE_WEIGHT,
            maxStrokeWeight: MAX_ROUTE_STROKE_WEIGHT
          }, options);
          this.layers = [];
          this.routeGeometries = new Map();
          this.selectedRoutes = [];
          this.currentZoom = typeof map?.getZoom === 'function' ? map.getZoom() : null;
          this.renderer = options.renderer || null;
          this.routePaneName = typeof options.pane === 'string' && options.pane ? options.pane : routePaneName;
        }

        reset() {
          this.clearLayers();
          this.routeGeometries.clear();
          this.selectedRoutes = [];
        }

        clearLayers() {
          this.layers.forEach(layer => {
            if (layer && this.map.hasLayer(layer)) {
              this.map.removeLayer(layer);
            }
          });
          this.layers = [];
        }

        updateRoutes(routeGeometryMap, selectedRouteIds) {
          if (!Array.isArray(selectedRouteIds) || selectedRouteIds.length === 0) {
            this.reset();
            return this.getLayers();
          }

          const geometryEntries = routeGeometryMap instanceof Map
            ? Array.from(routeGeometryMap.entries())
            : Object.entries(routeGeometryMap || {});

          const desiredIds = new Set(
            selectedRouteIds
              .map(id => Number(id))
              .filter(id => !Number.isNaN(id))
          );

          const nextGeometries = new Map();
          geometryEntries.forEach(([key, value]) => {
            const numericKey = Number(key);
            if (!Number.isNaN(numericKey) && desiredIds.has(numericKey) && Array.isArray(value)) {
              nextGeometries.set(numericKey, value);
            }
          });

          this.routeGeometries = nextGeometries;
          this.selectedRoutes = Array.from(this.routeGeometries.keys()).sort((a, b) => a - b);

          const mapZoom = typeof this.map?.getZoom === 'function' ? this.map.getZoom() : null;
          if (Number.isFinite(mapZoom)) {
            this.currentZoom = mapZoom;
          }

          this.render();
          return this.getLayers();
        }

        handleZoomFrame(targetZoom) {
          if (this.routeGeometries.size === 0 || this.selectedRoutes.length === 0) {
            return this.getLayers();
          }

          const zoom = Number.isFinite(targetZoom)
            ? targetZoom
            : (typeof this.map?.getZoom === 'function' ? this.map.getZoom() : null);
          if (!Number.isFinite(zoom)) {
            return this.getLayers();
          }

          this.currentZoom = zoom;
          this.render();
          return this.getLayers();
        }

        handleZoomEnd() {
          const zoom = typeof this.map?.getZoom === 'function' ? this.map.getZoom() : null;
          return this.handleZoomFrame(zoom);
        }

        getLayers() {
          return this.layers.slice();
        }

        hasPersistentPixelCache() {
          return false;
        }

        computeStrokeWeight(zoom = this.currentZoom) {
          const minWeight = Number.isFinite(this.options.minStrokeWeight)
            ? this.options.minStrokeWeight
            : MIN_ROUTE_STROKE_WEIGHT;
          const maxWeight = Number.isFinite(this.options.maxStrokeWeight)
            ? this.options.maxStrokeWeight
            : MAX_ROUTE_STROKE_WEIGHT;
          const computed = computeRouteStrokeWeight(zoom);
          if (!Number.isFinite(computed)) {
            return Math.max(minWeight, Math.min(maxWeight, DEFAULT_ROUTE_STROKE_WEIGHT));
          }
          return Math.max(minWeight, Math.min(maxWeight, computed));
        }

        render() {
          if (!this.map) return;
          if (this.routeGeometries.size === 0 || this.selectedRoutes.length === 0) {
            this.clearLayers();
            return;
          }

          const zoom = Number.isFinite(this.currentZoom)
            ? this.currentZoom
            : (typeof this.map?.getZoom === 'function' ? this.map.getZoom() : null);
          if (!Number.isFinite(zoom)) {
            this.clearLayers();
            return;
          }

          this.clearLayers();

          const step = Number.isFinite(this.options.sampleStepPx) && this.options.sampleStepPx > 0
            ? this.options.sampleStepPx
            : 8;
          const tolerance = Number.isFinite(this.options.matchTolerancePx)
            ? this.options.matchTolerancePx
            : 6;
          const headingToleranceRad = (Number.isFinite(this.options.headingToleranceDeg)
            ? this.options.headingToleranceDeg
            : 20) * Math.PI / 180;

          const segmentsByRoute = new Map();
          const spatialItems = [];

          this.routeGeometries.forEach((latlngs, routeId) => {
            if (!Array.isArray(latlngs) || latlngs.length < 2) {
              return;
            }

            const segments = this.resampleRoute(routeId, latlngs, zoom, step);
            if (!Array.isArray(segments) || segments.length === 0) {
              return;
            }

            segmentsByRoute.set(routeId, segments);

            segments.forEach(segment => {
              spatialItems.push({
                minX: segment.bounds.minX - tolerance,
                minY: segment.bounds.minY - tolerance,
                maxX: segment.bounds.maxX + tolerance,
                maxY: segment.bounds.maxY + tolerance,
                segment
              });
            });
          });

          if (spatialItems.length === 0) {
            this.clearLayers();
            return;
          }

          const tree = createSpatialIndex({ maxEntries: this.options.maxEntries });
          if (!tree || typeof tree.load !== 'function' || typeof tree.search !== 'function') {
            console.error('RBush spatial index instance is invalid; skipping overlap rendering.');
            this.clearLayers();
            return;
          }

          tree.clear?.();
          tree.load(spatialItems);
          this.populateSharedRoutes(spatialItems, tree, tolerance, headingToleranceRad);

          const groups = this.buildGroups(segmentsByRoute, zoom);
          this.drawGroups(groups);
        }

        populateSharedRoutes(spatialItems, tree, tolerance, headingToleranceRad) {
          const processedPairs = new Set();

          spatialItems.forEach(item => {
            const segment = item.segment;
            if (!segment) return;

            const candidates = tree.search(item);
            candidates.forEach(candidate => {
              const other = candidate.segment;
              if (!other || other === segment) return;
              if (other.routeId === segment.routeId) return;

              const pairKey = segment.routeId < other.routeId
                ? `${segment.routeId}:${segment.index}|${other.routeId}:${other.index}`
                : `${other.routeId}:${other.index}|${segment.routeId}:${segment.index}`;
              if (processedPairs.has(pairKey)) return;

              processedPairs.add(pairKey);
              if (!this.segmentsOverlap(segment, other, tolerance, headingToleranceRad)) return;

              segment.sharedRoutes.add(other.routeId);
              other.sharedRoutes.add(segment.routeId);

              this.applyRouteOffset(segment, other);
              this.applyRouteOffset(other, segment);
            });
          });
        }

        applyRouteOffset(target, source) {
          if (!target || !source) return;
          if (!target.routeOffsets) {
            target.routeOffsets = {};
          }

          const sourceOffset = this.extractRouteOffset(source, source.routeId);
          if (!Number.isFinite(sourceOffset)) {
            return;
          }

          const existing = target.routeOffsets[source.routeId];
          const candidate = Number.isFinite(existing?.min) ? Math.min(existing.min, sourceOffset) : sourceOffset;
          target.routeOffsets[source.routeId] = { min: candidate };
        }

        extractRouteOffset(segment, routeId) {
          if (!segment) return null;
          const offsets = segment.routeOffsets || {};
          const direct = offsets[routeId];
          if (direct && Number.isFinite(direct.min)) {
            return direct.min;
          }

          const values = [];
          const startVal = Number(segment.start?.cumulativeLength);
          if (Number.isFinite(startVal)) values.push(startVal);
          const endVal = Number(segment.end?.cumulativeLength);
          if (Number.isFinite(endVal)) values.push(endVal);
          return values.length > 0 ? Math.min(...values) : null;
        }

        buildGroups(segmentsByRoute, zoom) {
          const groups = [];

          segmentsByRoute.forEach((segments, routeId) => {
            const ordered = segments.slice().sort((a, b) => {
              const aOffset = Number(a.start?.cumulativeLength) || 0;
              const bOffset = Number(b.start?.cumulativeLength) || 0;
              return aOffset - bOffset;
            });

            let current = null;

            ordered.forEach(segment => {
              const sharedRoutes = Array.from(segment.sharedRoutes || []).sort((a, b) => a - b);
              if (sharedRoutes.length === 0) return;

              const primary = sharedRoutes[0];
              if (primary !== routeId) {
                return;
              }

              const needsNewGroup = !current
                || !this.sameRouteSet(current.routes, sharedRoutes)
                || !this.latLngsClose(current.lastLatLng, segment.start.latlng);

              if (needsNewGroup) {
                if (current) {
                  const finalized = this.finalizeGroup(current, zoom);
                  if (finalized) {
                    groups.push(finalized);
                  }
                }

                current = {
                  routes: sharedRoutes,
                  segments: [],
                  points: [],
                  offsets: new Map(),
                  lastLatLng: null
                };
              }

              current.segments.push(segment);

              if (current.points.length === 0) {
                current.points.push(segment.start.latlng);
              } else if (!this.latLngsClose(current.points[current.points.length - 1], segment.start.latlng)) {
                current.points.push(segment.start.latlng);
              }
              current.points.push(segment.end.latlng);
              current.lastLatLng = segment.end.latlng;

              const routeOffsets = segment.routeOffsets || {};
              current.routes.forEach(routeKey => {
                const candidate = Number(routeOffsets?.[routeKey]?.min ?? routeOffsets?.[routeKey]);
                if (Number.isFinite(candidate)) {
                  const existing = current.offsets.get(routeKey);
                  if (!Number.isFinite(existing) || candidate < existing) {
                    current.offsets.set(routeKey, candidate);
                  }
                }
              });
            });

            if (current) {
              const finalized = this.finalizeGroup(current, zoom);
              if (finalized) {
                groups.push(finalized);
              }
              current = null;
            }
          });

          return groups;
        }

        finalizeGroup(group, zoom) {
          const points = this.collapsePoints(group.points || []);
          if (points.length < 2) {
            return null;
          }

          const lengthPx = group.segments.reduce((sum, segment) => {
            const value = Number(segment.lengthPx);
            return sum + (Number.isFinite(value) ? value : 0);
          }, 0);

          const primaryRoute = group.routes[0];
          const offsetCandidates = group.segments
            .map(segment => Number(segment.routeOffsets?.[primaryRoute]?.min ?? segment.routeOffsets?.[primaryRoute]))
            .filter(value => Number.isFinite(value));
          const offsetPx = offsetCandidates.length > 0 ? Math.min(...offsetCandidates) : 0;

          const offsetMap = new Map();
          group.offsets.forEach((value, key) => {
            if (Number.isFinite(value)) {
              offsetMap.set(key, value);
            }
          });

          return {
            routes: group.routes.slice(),
            points,
            lengthPx,
            offsetPx,
            routeOffsets: offsetMap
          };
        }

        collapsePoints(points) {
          const collapsed = [];
          points.forEach(point => {
            if (collapsed.length === 0 || !this.latLngsClose(collapsed[collapsed.length - 1], point)) {
              collapsed.push(point);
            }
          });
          return collapsed;
        }

        sameRouteSet(a, b) {
          if (!Array.isArray(a) || !Array.isArray(b)) return false;
          if (a.length !== b.length) return false;
          for (let i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) return false;
          }
          return true;
        }

        latLngsClose(a, b) {
          if (!a || !b) return false;
          const tolerance = this.options.latLngEqualityMargin || 1e-9;
          const latA = a.lat ?? a?.latlng?.lat ?? 0;
          const lngA = a.lng ?? a?.latlng?.lng ?? 0;
          const latB = b.lat ?? b?.latlng?.lat ?? 0;
          const lngB = b.lng ?? b?.latlng?.lng ?? 0;
          return Math.abs(latA - latB) <= tolerance && Math.abs(lngA - lngB) <= tolerance;
        }

        drawGroups(groups) {
          const newLayers = [];
          const dashBase = this.options.dashLengthPx;
          const minDash = this.options.minDashLengthPx;
          const weight = this.computeStrokeWeight();

          groups.forEach(group => {
            if (!group || !Array.isArray(group.routes) || group.routes.length === 0) return;
            if (!Array.isArray(group.points) || group.points.length < 2) return;

            const coords = group.points.map(latlng => [latlng.lat, latlng.lng]);
            const sortedRoutes = group.routes.slice().sort((a, b) => a - b);
            const offsetsByRoute = new Map();

            if (group.routeOffsets instanceof Map) {
              group.routeOffsets.forEach((value, routeId) => {
                const numericRoute = Number(routeId);
                const numericValue = Number(value);
                if (Number.isFinite(numericRoute) && Number.isFinite(numericValue)) {
                  const existing = offsetsByRoute.get(numericRoute);
                  if (!Number.isFinite(existing) || numericValue < existing) {
                    offsetsByRoute.set(numericRoute, numericValue);
                  }
                }
              });
            } else if (group.routeOffsets && typeof group.routeOffsets === 'object') {
              Object.entries(group.routeOffsets).forEach(([routeKey, info]) => {
                const numericRoute = Number(routeKey);
                const numericValue = Number(info?.min ?? info);
                if (Number.isFinite(numericRoute) && Number.isFinite(numericValue)) {
                  const existing = offsetsByRoute.get(numericRoute);
                  if (!Number.isFinite(existing) || numericValue < existing) {
                    offsetsByRoute.set(numericRoute, numericValue);
                  }
                }
              });
            }

            if (sortedRoutes.length === 1) {
              const routeId = sortedRoutes[0];
              const layer = L.polyline(coords, mergeRouteLayerOptions({
                color: getRouteColor(routeId),
                weight,
                opacity: 1,
                lineCap: 'round',
                lineJoin: 'round'
              }, this.renderer, this.routePaneName)).addTo(this.map);
              newLayers.push(layer);
              return;
            }

            const groupLength = group.lengthPx || 0;
            if (!(groupLength > 0)) return;
            const stripeCount = sortedRoutes.length;
            let dashLength = dashBase;
            if (dashLength * stripeCount > groupLength) {
              dashLength = groupLength / stripeCount;
            }
            if (!(dashLength > 0)) {
              dashLength = minDash;
            }

            const gapLength = dashLength * (stripeCount - 1);
            const patternLength = dashLength + gapLength;

            let baseOffsetValue;
            const tolerance = 1e-9;
            let anchorRouteId = null;
            let anchorOffset = -Infinity;

            sortedRoutes.forEach(routeId => {
              const offsetValue = offsetsByRoute.get(routeId);
              if (Number.isFinite(offsetValue)) {
                if (
                  anchorRouteId === null ||
                  offsetValue > anchorOffset + tolerance ||
                  (Math.abs(offsetValue - anchorOffset) <= tolerance && routeId < anchorRouteId)
                ) {
                  anchorRouteId = routeId;
                  anchorOffset = offsetValue;
                }
              }
            });

            if (anchorRouteId !== null && Number.isFinite(anchorOffset)) {
              const anchorIndex = sortedRoutes.indexOf(anchorRouteId);
              baseOffsetValue = anchorOffset - dashLength * anchorIndex;
            } else {
              const rawOffset = Number(group.offsetPx);
              baseOffsetValue = Number.isFinite(rawOffset) ? rawOffset : 0;
            }

            sortedRoutes.forEach((routeId, index) => {
              let dashOffsetValue = baseOffsetValue + dashLength * index;
              if (patternLength > 0) {
                const targetOffset = offsetsByRoute.get(routeId);
                if (Number.isFinite(targetOffset)) {
                  const diff = targetOffset - dashOffsetValue;
                  const adjustment = Math.round(diff / patternLength);
                  if (Number.isFinite(adjustment) && adjustment !== 0) {
                    dashOffsetValue += adjustment * patternLength;
                  }
                }
                dashOffsetValue = ((dashOffsetValue % patternLength) + patternLength) % patternLength;
              }

              const layer = L.polyline(coords, mergeRouteLayerOptions({
                color: getRouteColor(routeId),
                weight,
                opacity: 1,
                dashArray: `${dashLength} ${gapLength}`,
                dashOffset: `${dashOffsetValue}`,
                lineCap: 'butt',
                lineJoin: 'round'
              }, this.renderer, this.routePaneName)).addTo(this.map);
              newLayers.push(layer);
            });
          });

          this.layers = newLayers;
        }

        simplifyLatLngs(latlngs, zoom) {
          if (!Array.isArray(latlngs) || latlngs.length === 0) {
            return [];
          }

          const projected = latlngs.map(latlng => this.map.project(latlng, zoom));
          let simplified = projected;
          if (projected.length > 2 && this.options.simplifyTolerancePx > 0 && L.LineUtil && L.LineUtil.simplify) {
            simplified = L.LineUtil.simplify(projected, this.options.simplifyTolerancePx);
          }

          return simplified.map(pt => ({
            point: L.point(pt.x, pt.y),
            latlng: this.map.unproject(pt, zoom)
          }));
        }

        resampleRoute(routeId, latlngs, zoom, step) {
          const simplified = this.simplifyLatLngs(latlngs, zoom);
          if (simplified.length < 2) {
            return [];
          }

          const samples = [];
          const first = simplified[0];
          samples.push({
            latlng: first.latlng,
            point: first.point,
            cumulativeLength: 0
          });

          let traversed = 0;
          let distanceSinceLast = 0;

          for (let i = 1; i < simplified.length; i++) {
            const prev = simplified[i - 1];
            const curr = simplified[i];
            const segmentLength = this.distance(prev.point, curr.point);
            if (segmentLength === 0) {
              continue;
            }

            let consumed = 0;
            while (distanceSinceLast + (segmentLength - consumed) >= step) {
              const remaining = step - distanceSinceLast;
              consumed += remaining;
              const ratio = consumed / segmentLength;
              const samplePoint = this.interpolatePoint(prev.point, curr.point, ratio);
              const sampleLatLng = this.map.unproject(samplePoint, zoom);
              traversed += remaining;
              samples.push({
                latlng: sampleLatLng,
                point: samplePoint,
                cumulativeLength: traversed
              });
              distanceSinceLast = 0;
            }

            const leftover = segmentLength - consumed;
            traversed += leftover;
            distanceSinceLast += leftover;
          }

          const last = simplified[simplified.length - 1];
          const lastSample = samples[samples.length - 1];
          if (!this.latLngsClose(lastSample.latlng, last.latlng)) {
            samples.push({
              latlng: last.latlng,
              point: last.point,
              cumulativeLength: traversed
            });
          } else {
            lastSample.cumulativeLength = traversed;
          }

          const segments = [];
          for (let i = 0; i < samples.length - 1; i++) {
            const start = samples[i];
            const end = samples[i + 1];
            const lengthPx = this.distance(start.point, end.point);
            if (!(lengthPx > 0)) {
              continue;
            }

            const bounds = {
              minX: Math.min(start.point.x, end.point.x),
              minY: Math.min(start.point.y, end.point.y),
              maxX: Math.max(start.point.x, end.point.x),
              maxY: Math.max(start.point.y, end.point.y)
            };
            const midpoint = L.point(
              (start.point.x + end.point.x) / 2,
              (start.point.y + end.point.y) / 2
            );
            const heading = Math.atan2(end.point.y - start.point.y, end.point.x - start.point.x);
            const offsetValues = [];
            const startOffset = Number(start.cumulativeLength);
            if (Number.isFinite(startOffset)) offsetValues.push(startOffset);
            const endOffset = Number(end.cumulativeLength);
            if (Number.isFinite(endOffset)) offsetValues.push(endOffset);

            const routeOffsets = {};
            if (offsetValues.length > 0) {
              routeOffsets[routeId] = { min: Math.min(...offsetValues) };
            }

            segments.push({
              routeId,
              index: segments.length,
              start,
              end,
              lengthPx,
              bounds,
              midpoint,
              heading,
              routeOffsets,
              sharedRoutes: new Set([routeId])
            });
          }

          return segments;
        }

        interpolatePoint(a, b, t) {
          return L.point(
            a.x + (b.x - a.x) * t,
            a.y + (b.y - a.y) * t
          );
        }

        distance(a, b) {
          const ax = a?.x ?? 0;
          const ay = a?.y ?? 0;
          const bx = b?.x ?? 0;
          const by = b?.y ?? 0;
          const dx = bx - ax;
          const dy = by - ay;
          return Math.sqrt(dx * dx + dy * dy);
        }

        segmentsOverlap(a, b, tolerance, headingToleranceRad) {
          const midpointDistance = this.distance(a.midpoint, b.midpoint);
          if (midpointDistance > tolerance) {
            return false;
          }

          const headingDiff = this.smallestHeadingDifference(a.heading, b.heading);
          if (headingDiff > headingToleranceRad && Math.abs(Math.PI - headingDiff) > headingToleranceRad) {
            return false;
          }

          const startDistance = this.distance(a.start.point, b.start.point);
          const endDistance = this.distance(a.end.point, b.end.point);
          const crossStart = this.distance(a.start.point, b.end.point);
          const crossEnd = this.distance(a.end.point, b.start.point);
          const closeEnough = Math.min(startDistance, endDistance, crossStart, crossEnd) <= tolerance * 2;

          return closeEnough;
        }

        smallestHeadingDifference(a, b) {
          let diff = Math.abs(a - b);
          diff = diff % (Math.PI * 2);
          if (diff > Math.PI) diff = (Math.PI * 2) - diff;
          return diff;
        }
      }
      // Fetch routes from GetRoutes.
      function fetchRouteColors() {
        console.log('Fetching route colors...');
        const routesApiUrl = `${baseURL}/Services/JSONPRelay.svc/GetRoutes?APIKey=8882812681`;
        return fetch(routesApiUrl)
          .then(response => response.json())
          .then(data => {
            if (Array.isArray(data)) {
              data.forEach(route => {
                setRouteVisibility(route);
                allRoutes[route.RouteID] = Object.assign(allRoutes[route.RouteID] || {}, route);
                if (canDisplayRoute(route.RouteID)) {
                  routeColors[route.RouteID] = route.MapLineColor;
                  console.log(`Route ID: ${route.RouteID}, Color: ${route.MapLineColor}`);
                } else {
                  delete routeColors[route.RouteID];
                  console.log(`Route ID: ${route.RouteID} hidden due to display settings`);
                }
              });
            }
          })
          .catch(error => console.error("Error fetching route colors:", error));
      }

      // Fetch route paths from GetRoutesForMapWithSchedule and center map on all routes.
      function fetchRoutePaths() {
          const currentBaseURL = baseURL;
          const routePathsApiUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetRoutesForMapWithScheduleWithEncodedLine?APIKey=8882812681`;
          fetch(routePathsApiUrl)
              .then(response => response.json())
              .then(data => {
                  if (currentBaseURL !== baseURL) return;
                  let bounds = null;
                  const displayedRoutes = new Map();
                  const rendererGeometries = new Map();
                  const simpleGeometries = [];
                  const selectedRouteIds = [];
                  const updatedRouteStopAddressMap = {};
                  const updatedRouteStopRouteMap = {};
                  const useOverlapRenderer = enableOverlapDashRendering && overlapRenderer;
                  const seenRouteIds = new Set();
                  let geometryChanged = false;

                  if (Array.isArray(data)) {
                      data.forEach(route => {
                          setRouteVisibility(route);
                          allRoutes[route.RouteID] = Object.assign(allRoutes[route.RouteID] || {}, route);
                  const numericRouteId = Number(route.RouteID);
                  const isNumericRoute = !Number.isNaN(numericRouteId);

                  if (Array.isArray(route.Stops)) {
                      route.Stops.forEach(stop => {
                          const routeStopId = Number(stop.RouteStopID ?? stop.RouteStopId);
                          const addressId = stop.AddressID ?? stop.AddressId;
                          if (!Number.isNaN(routeStopId)) {
                              if (isNumericRoute) {
                                  updatedRouteStopRouteMap[routeStopId] = numericRouteId;
                              }
                              if (addressId !== undefined && addressId !== null && `${addressId}`.trim() !== '') {
                                  updatedRouteStopAddressMap[routeStopId] = `${addressId}`;
                              }
                          }
                      });
                  }

                  const routeAllowed = canDisplayRoute(route.RouteID);
                          if (isNumericRoute && route.EncodedPolyline) {
                              seenRouteIds.add(numericRouteId);
                          }

                          if (!routeAllowed) {
                              return;
                          }

                          const isSelected = isRouteSelected(route.RouteID);
                          if (route.EncodedPolyline && isNumericRoute) {
                              let cacheEntry = routePolylineCache.get(numericRouteId);
                              let latLngPath;
                              let polyBounds = null;

                              if (!cacheEntry || cacheEntry.encoded !== route.EncodedPolyline) {
                                  const decodedPolyline = polyline.decode(route.EncodedPolyline);
                                  latLngPath = decodedPolyline.map(coords => L.latLng(coords[0], coords[1]));
                                  if (Array.isArray(latLngPath) && latLngPath.length >= 2) {
                                      polyBounds = L.latLngBounds(latLngPath);
                                  }
                                  routePolylineCache.set(numericRouteId, {
                                      encoded: route.EncodedPolyline,
                                      latLngPath,
                                      bounds: polyBounds
                                  });
                                  if (isSelected) {
                                      geometryChanged = true;
                                  }
                              } else {
                                  latLngPath = cacheEntry.latLngPath;
                                  polyBounds = cacheEntry.bounds || null;
                                  if (!polyBounds && Array.isArray(latLngPath) && latLngPath.length >= 2) {
                                      polyBounds = L.latLngBounds(latLngPath);
                                      cacheEntry.bounds = polyBounds;
                                  }
                              }

                              if (polyBounds) {
                                  bounds = bounds ? bounds.extend(polyBounds) : L.latLngBounds(polyBounds);
                              } else if (Array.isArray(latLngPath) && latLngPath.length >= 2) {
                                  const computedBounds = L.latLngBounds(latLngPath);
                                  bounds = bounds ? bounds.extend(computedBounds) : computedBounds;
                                  const existing = routePolylineCache.get(numericRouteId);
                                  if (existing) {
                                      existing.bounds = computedBounds;
                                  }
                              }

                              if (isSelected && Array.isArray(latLngPath) && latLngPath.length >= 2) {
                                  const routeColor = getRouteColor(route.RouteID);
                                  selectedRouteIds.push(numericRouteId);
                                  if (useOverlapRenderer) {
                                      rendererGeometries.set(numericRouteId, latLngPath);
                                  } else {
                                      simpleGeometries.push({ routeId: numericRouteId, latLngPath, routeColor });
                                  }

                                  const storedRoute = allRoutes[route.RouteID] || {};
                                  const legendNameCandidates = [
                                      storedRoute.Description,
                                      route.Description,
                                      storedRoute.Name,
                                      route.Name,
                                      storedRoute.RouteName,
                                      route.RouteName
                                  ];
                                  let legendName = legendNameCandidates.find(value => typeof value === 'string' && value.trim() !== '');
                                  legendName = legendName ? legendName.trim() : `Route ${route.RouteID}`;
                                  const rawDescription = storedRoute.InfoText ?? route.InfoText ?? '';
                                  const legendDescription = typeof rawDescription === 'string' ? rawDescription.trim() : '';
                                  const legendRouteId = isNumericRoute ? numericRouteId : route.RouteID;
                                  displayedRoutes.set(route.RouteID, {
                                      routeId: legendRouteId,
                                      color: routeColor,
                                      name: legendName,
                                      description: legendDescription
                                  });
                              }
                          } else if (isSelected && isNumericRoute) {
                              if (routePolylineCache.has(numericRouteId)) {
                                  routePolylineCache.delete(numericRouteId);
                              }
                              geometryChanged = true;
                          }
                      });

                      const previousSelectedIds = new Set(lastRouteRenderState.selectionKey
                          ? lastRouteRenderState.selectionKey.split('|').filter(Boolean).map(id => Number(id))
                          : []);
                      Array.from(routePolylineCache.keys()).forEach(routeId => {
                          if (!seenRouteIds.has(routeId)) {
                              if (previousSelectedIds.has(routeId)) {
                                  geometryChanged = true;
                              }
                              routePolylineCache.delete(routeId);
                          }
                      });

                      const selectedRouteIdsSorted = selectedRouteIds.slice().sort((a, b) => a - b);
                      const selectionKey = selectedRouteIdsSorted.join('|');
                      const colorSignature = selectedRouteIdsSorted.map(id => `${id}:${getRouteColor(id)}`).join('|');
                      const geometrySignature = selectedRouteIdsSorted
                          .map(id => `${id}:${routePolylineCache.get(id)?.encoded || ''}`)
                          .join('|');
                      const rendererFlag = !!useOverlapRenderer;

                      let shouldRender = routeLayers.length === 0 ||
                        rendererFlag !== lastRouteRenderState.useOverlapRenderer ||
                        selectionKey !== lastRouteRenderState.selectionKey ||
                        colorSignature !== lastRouteRenderState.colorSignature ||
                        geometrySignature !== lastRouteRenderState.geometrySignature ||
                        geometryChanged;

                      if (shouldRender) {
                          routeLayers.forEach(layer => map.removeLayer(layer));
                          routeLayers = [];
                          if (useOverlapRenderer) {
                              const layers = overlapRenderer.updateRoutes(rendererGeometries, selectedRouteIdsSorted);
                              routeLayers = layers;
                          } else {
                              const currentStrokeWeight = computeRouteStrokeWeight(typeof map?.getZoom === 'function' ? map.getZoom() : null);
                              simpleGeometries.forEach(({ routeId, latLngPath, routeColor }) => {
                              const routeLayer = L.polyline(latLngPath, mergeRouteLayerOptions({
                                      color: routeColor,
                                      weight: currentStrokeWeight,
                                      opacity: 1,
                                      lineCap: 'round',
                                      lineJoin: 'round'
                                  })).addTo(map);
                                  routeLayers.push(routeLayer);
                              });
                          }
                      }

                      lastRouteRenderState = {
                          selectionKey,
                          colorSignature,
                          geometrySignature,
                          useOverlapRenderer: rendererFlag
                      };

                      routeStopAddressMap = updatedRouteStopAddressMap;
                      routeStopRouteMap = updatedRouteStopRouteMap;
                      updateCustomPopups();
                      if (Array.isArray(stopDataCache) && stopDataCache.length > 0) {
                          renderBusStops(stopDataCache);
                      }
                      if (bounds) {
                          allRouteBounds = bounds;
                          if (!mapHasFitAllRoutes) {
                              if (!kioskMode && !adminKioskMode) {
                                  map.fitBounds(allRouteBounds, { padding: [20, 20] });
                              }
                              mapHasFitAllRoutes = true;
                          }
                      }
                      updateRouteSelector(activeRoutes);
                      stopMarkers.forEach(stopMarker => stopMarker.bringToFront());
                  }
                  updateRouteLegend(Array.from(displayedRoutes.values()));
              })
              .catch(error => {
                  console.error("Error fetching route paths:", error);
                  updateRouteLegend([]);
              });
      }

      function fetchBlockAssignments() {
          const currentBaseURL = baseURL;
          const d = new Date();
          const ds = `${d.getMonth() + 1}/${d.getDate()}/${d.getFullYear()}`;
          const schedUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetScheduleVehicleCalendarByDateAndRoute?dateString=${encodeURIComponent(ds)}`;
          fetch(schedUrl)
              .then(response => response.json())
              .then(sched => {
                  if (currentBaseURL !== baseURL) return;
                  const ids = (sched || []).map(s => s.ScheduleVehicleCalendarID).join(',');
                  if (!ids) {
                      busBlocks = {};
                      return;
                  }
                  const blockUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetDispatchBlockGroupData?scheduleVehicleCalendarIdsString=${ids}`;
                  return fetch(blockUrl).then(r => r.json());
              })
              .then(data => {
                  if (currentBaseURL !== baseURL || !data) return;
                  const groups = data?.BlockGroups || [];
                  const alias = {
                      "[01]": "[01]/[04]",
                      "[03]": "[05]/[03]",
                      "[04]": "[01]/[04]",
                      "[05]": "[05]/[03]",
                      "[06]": "[22]/[06]",
                      "[10]": "[20]/[10]",
                      "[15]": "[26]/[15]",
                      "[16] AM": "[21]/[16] AM",
                      "[17]": "[23]/[17]",
                      "[18] AM": "[24]/[18] AM",
                      "[20] AM": "[20]/[10]",
                      "[21] AM": "[21]/[16] AM",
                      "[22] AM": "[22]/[06]",
                      "[23]": "[23]/[17]",
                      "[24] AM": "[24]/[18] AM",
                      "[26] AM": "[26]/[15]"
                  };
                  let mapping = {};
                  groups.forEach(g => {
                      const block = (g.BlockGroupId || '').trim();
                      const vehicleId = g.Blocks?.[0]?.Trips?.[0]?.VehicleID ?? g.VehicleId;
                      if (block && block.includes('[') && vehicleId != null) {
                          mapping[vehicleId] = alias[block] || block;
                      }
                  });
                  busBlocks = mapping;
              })
              .catch(error => console.error("Error fetching block assignments:", error));
      }

      function fetchBusLocations() {
          const currentBaseURL = baseURL;
          const apiUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetMapVehiclePoints?APIKey=8882812681&returnVehiclesNotAssignedToRoute=true`;
          return fetch(apiUrl)
              .then(response => {
                  if (!response.ok) throw new Error("Network response was not ok: " + response.statusText);
                  return response.json();
              })
              .then(data => {
                  if (currentBaseURL !== baseURL) return;
                  if (Array.isArray(data)) {
                      let currentBusData = {};
                      let activeRoutesSet = new Set();
                      let vehicles = [];

                      // First pass: gather vehicles and determine active routes.
                      data.forEach(vehicle => {
                          const vehicleID = vehicle.VehicleID;
                          const newPosition = [vehicle.Latitude, vehicle.Longitude];
                          const isMoving = vehicle.GroundSpeed > 0;
                          const busName = vehicle.Name;
                          let routeID = vehicle.RouteID;
                          if (!routeID && adminMode) {
                              routeID = 0;
                          } else if (!routeID) {
                              return;
                          }
                          const numericRouteId = Number(routeID);
                          const effectiveRouteId = Number.isNaN(numericRouteId) ? routeID : numericRouteId;
                          if (!canDisplayRoute(effectiveRouteId)) return;
                          if (!adminMode && !routeColors.hasOwnProperty(effectiveRouteId)) return;
                          activeRoutesSet.add(effectiveRouteId);
                          vehicles.push({
                              vehicleID,
                              newPosition,
                              isMoving,
                              busName,
                              routeID: effectiveRouteId,
                              heading: vehicle.Heading,
                              groundSpeed: vehicle.GroundSpeed
                          });
                      });

                      // Update global activeRoutes and rebuild selector before rendering.
                      activeRoutes = activeRoutesSet;
                      updateRouteSelector(activeRoutesSet);

                      // Second pass: render only selected routes.
                      vehicles.forEach(v => {
                          const { vehicleID, newPosition, isMoving, busName, routeID, heading, groundSpeed } = v;
                          if (!isRouteSelected(routeID)) return;
                          currentBusData[vehicleID] = true;
                          const svgIcon = `
                              <svg width="40" height="80" viewBox="0 0 40 80" xmlns="http://www.w3.org/2000/svg">
                                <g>
                                  <circle cx="20" cy="20" r="15" fill="${getRouteColor(routeID)}" stroke="white" stroke-width="3" />
                                  ${isMoving ? `
                                    <line x1="20" y1="10" x2="20" y2="22" stroke="${getContrastColor(getRouteColor(routeID))}" stroke-width="4" stroke-linecap="round" style="transform: rotate(${heading + 180}deg); transform-origin: 20px 20px" />
                                    <polygon points="15,22 25,22 20,30" fill="${getContrastColor(getRouteColor(routeID))}" style="transform: rotate(${heading + 180}deg); transform-origin: 20px 20px" />
                                  ` : `
                                    <rect x="14" y="14" width="12" height="12" fill="${getContrastColor(getRouteColor(routeID))}" />
                                  `}
                                </g>
                              </svg>`;
                          const busIcon = L.divIcon({
                              html: svgIcon,
                              className: '',
                              iconSize: [40, 40],
                              iconAnchor: [20, 20]
                          });
                          if (markers[vehicleID]) {
                              animateMarkerTo(markers[vehicleID], newPosition);
                              markers[vehicleID].setIcon(busIcon);
                              markers[vehicleID].routeID = routeID;
                          } else {
                              markers[vehicleID] = L.marker(newPosition, { icon: busIcon });
                              markers[vehicleID].routeID = routeID;
                              markers[vehicleID].addTo(map);
                          }
                          if (adminMode && showSpeed && !kioskMode) {
                              const speedBubble = `
                                  <svg width="60" height="20" viewBox="0 0 60 20" xmlns="http://www.w3.org/2000/svg">
                                      <g>
                                          <rect x="0" y="0" width="60" height="20" rx="10" ry="10" fill="${getRouteColor(routeID)}" stroke="white" stroke-width="3" />
                                          <text x="30" y="15" font-size="12" font-weight="bold" text-anchor="middle" fill="${getContrastColor(getRouteColor(routeID))}" font-family="FGDC">${Math.round(groundSpeed)} MPH</text>
                                      </g>
                                  </svg>`;
                              const speedIcon = L.divIcon({
                                  html: speedBubble,
                                  className: '',
                                  iconSize: [60, 20],
                                  iconAnchor: [30, -15]
                              });
                              if (nameBubbles[vehicleID] && nameBubbles[vehicleID].speedMarker) {
                                  animateMarkerTo(nameBubbles[vehicleID].speedMarker, newPosition);
                                  nameBubbles[vehicleID].speedMarker.setIcon(speedIcon);
                              } else {
                                  nameBubbles[vehicleID] = nameBubbles[vehicleID] || {};
                                  nameBubbles[vehicleID].speedMarker = L.marker(newPosition, { icon: speedIcon, interactive: false }).addTo(map);
                              }
                          } else {
                              if (nameBubbles[vehicleID] && nameBubbles[vehicleID].speedMarker) {
                                  map.removeLayer(nameBubbles[vehicleID].speedMarker);
                                  delete nameBubbles[vehicleID].speedMarker;
                              }
                          }
                          if (adminMode && !kioskMode) {
                              const bubbleWidth = Math.max(40, busName.length * 10);
                              const nameBubble = `
                                  <svg width="${bubbleWidth}" height="30" viewBox="0 0 ${bubbleWidth} 30" xmlns="http://www.w3.org/2000/svg">
                                      <g>
                                          <rect x="0" y="5" width="${bubbleWidth}" height="20" rx="10" ry="10" fill="${getRouteColor(routeID)}" stroke="white" stroke-width="3" />
                                          <text x="${bubbleWidth / 2}" y="20" font-size="14" font-weight="bold" text-anchor="middle" fill="${getContrastColor(getRouteColor(routeID))}" font-family="FGDC">${busName}</text>
                                      </g>
                                  </svg>`;
                              const nameIcon = L.divIcon({
                                  html: nameBubble,
                                  className: '',
                                  iconSize: [bubbleWidth, 30],
                                  iconAnchor: [bubbleWidth / 2, 40]
                              });
                              if (nameBubbles[vehicleID] && nameBubbles[vehicleID].nameMarker) {
                                  animateMarkerTo(nameBubbles[vehicleID].nameMarker, newPosition);
                                  nameBubbles[vehicleID].nameMarker.setIcon(nameIcon);
                              } else {
                                  nameBubbles[vehicleID] = nameBubbles[vehicleID] || {};
                                  nameBubbles[vehicleID].nameMarker = L.marker(newPosition, { icon: nameIcon, interactive: false }).addTo(map);
                              }

                              const blockName = busBlocks[vehicleID];
                              if (showBlockNumbers && blockName && blockName.includes('[')) {
                                  const canvas = document.createElement('canvas');
                                  const ctx = canvas.getContext('2d');
                                  ctx.font = 'bold 14px FGDC';
                                  const textWidth = ctx.measureText(blockName).width;
                                  const blockWidth = Math.max(40, textWidth + 20);
                                  const blockBubble = `
                                      <svg width="${blockWidth}" height="30" viewBox="0 0 ${blockWidth} 30" xmlns="http://www.w3.org/2000/svg">
                                          <g>
                                              <rect x="0" y="5" width="${blockWidth}" height="20" rx="10" ry="10" fill="${getRouteColor(routeID)}" stroke="white" stroke-width="3" />
                                              <text x="${blockWidth / 2}" y="20" font-size="14" font-weight="bold" text-anchor="middle" fill="${getContrastColor(getRouteColor(routeID))}" font-family="FGDC">${blockName}</text>
                                          </g>
                                      </svg>`;
                                  const blockIcon = L.divIcon({
                                      html: blockBubble,
                                      className: '',
                                      iconSize: [blockWidth, 30],
                                      // Position the block number bubble so it touches but doesn't overlap the bus icon
                                      iconAnchor: [blockWidth / 2, -13]
                                  });
                                  if (nameBubbles[vehicleID] && nameBubbles[vehicleID].blockMarker) {
                                      animateMarkerTo(nameBubbles[vehicleID].blockMarker, newPosition);
                                      nameBubbles[vehicleID].blockMarker.setIcon(blockIcon);
                                  } else {
                                      nameBubbles[vehicleID] = nameBubbles[vehicleID] || {};
                                      nameBubbles[vehicleID].blockMarker = L.marker(newPosition, { icon: blockIcon, interactive: false }).addTo(map);
                                  }
                              } else {
                                  if (nameBubbles[vehicleID] && nameBubbles[vehicleID].blockMarker) {
                                      map.removeLayer(nameBubbles[vehicleID].blockMarker);
                                      delete nameBubbles[vehicleID].blockMarker;
                                  }
                              }
                          } else {
                              if (nameBubbles[vehicleID] && nameBubbles[vehicleID].nameMarker) {
                                  map.removeLayer(nameBubbles[vehicleID].nameMarker);
                                  delete nameBubbles[vehicleID].nameMarker;
                              }
                              if (nameBubbles[vehicleID] && nameBubbles[vehicleID].blockMarker) {
                                  map.removeLayer(nameBubbles[vehicleID].blockMarker);
                                  delete nameBubbles[vehicleID].blockMarker;
                              }
                          }
                      });

                      Object.keys(markers).forEach(vehicleID => {
                          if (!currentBusData[vehicleID] || !isRouteSelected(markers[vehicleID].routeID)) {
                              map.removeLayer(markers[vehicleID]);
                              delete markers[vehicleID];
                              if (nameBubbles[vehicleID]) {
                                  if (nameBubbles[vehicleID].speedMarker) map.removeLayer(nameBubbles[vehicleID].speedMarker);
                                  if (nameBubbles[vehicleID].nameMarker) map.removeLayer(nameBubbles[vehicleID].nameMarker);
                                  if (nameBubbles[vehicleID].blockMarker) map.removeLayer(nameBubbles[vehicleID].blockMarker);
                                  delete nameBubbles[vehicleID];
                              }
                          }
                      });
                      previousBusData = currentBusData;
                  }
              })
              .catch(error => console.error("Error fetching bus locations:", error));
      }

      function getContrastColor(hexColor) {
          hexColor = hexColor.replace('#', '');
          const r = parseInt(hexColor.substring(0, 2), 16);
          const g = parseInt(hexColor.substring(2, 4), 16);
          const b = parseInt(hexColor.substring(4, 6), 16);
          const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
          return luminance > 0.565 ? 'black' : 'white';
      }

      function animateMarkerTo(marker, newPosition) {
        if (!marker || !newPosition) return;
        const hasArrayPosition = Array.isArray(newPosition) && newPosition.length >= 2;
        const endPos = hasArrayPosition ? L.latLng(newPosition) : L.latLng(newPosition?.lat, newPosition?.lng);
        if (!endPos || Number.isNaN(endPos.lat) || Number.isNaN(endPos.lng)) return;

        const startPos = marker.getLatLng();
        if (!startPos) {
          marker.setLatLng(endPos);
          return;
        }

        const positionsMatch = typeof startPos.equals === 'function'
          ? startPos.equals(endPos, 1e-7)
          : (Math.abs(startPos.lat - endPos.lat) < 1e-7 && Math.abs(startPos.lng - endPos.lng) < 1e-7);

        if (positionsMatch) {
          marker.setLatLng(endPos);
          return;
        }

        const duration = 1000;
        const startTime = performance.now();
        function animate(time) {
          const elapsed = time - startTime;
          const t = Math.min(elapsed / duration, 1);
          const currentPos = L.latLng(
            startPos.lat + t * (endPos.lat - startPos.lat),
            startPos.lng + t * (endPos.lng - startPos.lng)
          );
          marker.setLatLng(currentPos);
          if (t < 1) requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);
      }

      document.addEventListener("DOMContentLoaded", () => {
        loadAgencies().then(() => {
          initMap();
          showCookieBanner();
        });
      });
    </script>
  </head>
  <body>
    <div id="map"></div>
    <div id="routeLegend" aria-live="polite"></div>
    <div id="routeSelector"></div>
    <div id="routeSelectorTab" onclick="togglePanel()">&#9664;</div>
    <div class="credit">proof of concept created by pat cox • phc6j@virginia.edu</div>
    <div id="cookieBanner" class="cookie-banner" style="display:none;">
      This site stores your selected transit agency on your device to remember your preference.
      <button id="cookieAccept">OK</button>
    </div>
  </body>
</html>
