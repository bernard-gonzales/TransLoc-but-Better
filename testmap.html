<!DOCTYPE html>
<html>
  <head>
    <title>Live Map - Headway Guard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@mapbox/polyline@1.1.1"></script>
    <style>
      .custom-popup {
        position: absolute;
        background: #232D4B;
        border: 4px solid white;
        border-radius: 15px;
        padding: 10px;
        pointer-events: auto;
        transform: translate(-50%, -100%);
        white-space: nowrap;
        z-index: 1000;
        color: white;
        text-transform: uppercase;
      }
      .custom-popup-arrow {
        position: absolute;
        left: 50%;
        bottom: -10px;
        width: 0;
        height: 0;
        border-left: 10px solid transparent;
        border-right: 10px solid transparent;
        border-top: 10px solid white;
        transform: translateX(-50%);
      }
      .custom-popup-close {
        position: absolute;
        bottom: 5px;
        right: 5px;
        cursor: pointer;
        background: #f00;
        color: #fff;
        border: none;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        line-height: 20px;
        text-align: center;
        font-size: 14px;
      }
      .route-pill {
        display: inline-block;
        padding: 5px 10px;
        border-radius: 20px;
        color: white;
        font-weight: bold;
        margin-top: 10px;
        text-align: center;
        border: 2px solid #FFFFFF;
      }
      @font-face {
        font-family: 'FGDC';
        src: url('FGDC.ttf') format('truetype');
      }
      body, .custom-popup {
        font-family: 'FGDC', sans-serif;
        font-size: 14px;
      }
      #map {
        height: 100%;
        width: 100%;
      }
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
      }
      /* Route Selector styling */
      #routeSelector {
        width: 300px;
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 1100;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px;
        border-radius: 5px;
        max-height: 90vh;
        overflow-y: auto;
        transition: transform 0.3s ease;
		font-size: 21px;
      }
      #routeSelector.hidden {
        transform: translateX(320px);
      }
      #routeSelector h3 {
        margin-top: 0;
      }
      /* Updated button styles for route selector (including speed toggle) */
      #routeSelector button {
        margin: 5px 2px;
        padding: 5px 10px;
        font-size: 24px;
        font-family: 'FGDC', sans-serif;
        background-color: #E57200;
        color: black;
        border: none;
        border-radius: 20px;
        cursor: pointer;
      }
      #routeSelector label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
      }
      #routeSelector .color-box {
        display: inline-block;
        width: 12px;
        height: 12px;
        margin-right: 5px;
        vertical-align: middle;
      }
      /* Tab styling */
      #routeSelectorTab {
        position: fixed;
        top: 50%;
        right: 0;
        width: 30px;
        height: 60px;
        background: #ccc;
        border-top-left-radius: 10px;
        border-bottom-left-radius: 10px;
        cursor: pointer;
        display: block;
        transform: translateY(-50%);
        z-index: 1150;
        text-align: center;
        line-height: 60px;
        font-size: 20px;
        user-select: none;
        transition: right 0.3s ease;
      }
      #routeLegend {
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 1100;
        background: rgba(255, 255, 255, 0.9);
        padding: 12px 16px;
        border-radius: 8px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        max-width: 320px;
        display: none;
        font-size: 20px;
      }
      #routeLegend .legend-title {
        font-weight: bold;
        margin-bottom: 8px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      #routeLegend .legend-item {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 8px;
      }
      #routeLegend .legend-item:last-child {
        margin-bottom: 0;
      }
      #routeLegend .legend-color {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 2px solid #FFFFFF;
        box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.1);
        flex-shrink: 0;
      }
      #routeLegend .legend-text {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      #routeLegend .legend-name {
        font-weight: bold;
      }
      #routeLegend .legend-description {
        font-size: 16px;
        color: #1b1b1b;
      }
      @media (max-width: 600px) {
        #routeSelector { width: 80%; right: 10%; font-size: 18px; }
        #routeSelector.hidden { transform: translateX(calc(100% + 20px)); }
        #routeSelector button { font-size: 20px; }
        #routeSelector label { font-size: 18px; }
        #routeSelectorTab { width: 40px; height: 80px; font-size: 28px; }
      }
      .credit{position:fixed;bottom:8px;right:8px;font-size:12px;color:var(--muted,#9fb0c9);}
      .cookie-banner{position:fixed;bottom:0;left:0;right:0;background:rgba(0,0,0,0.8);color:white;padding:10px;text-align:center;font-size:14px;z-index:1200;}
      .cookie-banner button{margin-left:10px;}
    </style>
    <script>
      // Manually set these variables.
      // adminMode: true for admin view (with speed/block bubbles and unit numbers).
      //            Can be disabled via URL param `adminMode=false`.
      //            In public mode (adminMode=false) the route selector is still shown
      //            but only for routes that are public-facing.
      // kioskMode: true to hide the route selector/tab and suppress vehicle overlays for a public display.
      // adminKioskMode: true to hide the route selector/tab while retaining admin overlays (previous kiosk behavior).
      // showSpeed/showBlockNumbers: only one may be true at a time.
      let adminMode = true; // shows unit numbers and speed/block bubbles
      let kioskMode = false;
      let adminKioskMode = false;
      let showSpeed = false; // default to showing block numbers
      let showBlockNumbers = true;

      const params = new URLSearchParams(window.location.search);
      const kioskParam = params.get('kioskMode');
      if (kioskParam !== null) {
        kioskMode = kioskParam.toLowerCase() === 'true';
      }
      const adminKioskParam = params.get('adminKioskMode');
      if (adminKioskParam !== null) {
        adminKioskMode = adminKioskParam.toLowerCase() === 'true';
      }
      const adminParam = params.get('adminMode');
      if (adminParam !== null) {
        adminMode = adminParam.toLowerCase() === 'true';
      }
      
      const outOfServiceRouteColor = '#000000';
      
      let map;
      let markers = {};
      let routeColors = {};
      let routeLayers = [];
      let stopMarkers = [];
      let nameBubbles = {};
      let busBlocks = {};
      let previousBusData = {};
      let cachedEtas = {};
      let customPopups = [];
      let allRouteBounds = null;
      let mapHasFitAllRoutes = false;
      let refreshIntervals = [];
      let cachedRouteVisualization = null;

      let agencies = [];
      let baseURL = '';

      async function loadAgencies() {
        try {
          const response = await fetch('https://admin.ridesystems.net/api/Clients/GetClients');
          const contentType = response.headers.get('content-type') || '';
          let clients = [];
          if (contentType.includes('application/json')) {
            clients = await response.json();
          } else {
            const text = await response.text();
            const parser = new DOMParser();
            const xml = parser.parseFromString(text, 'application/xml');
            clients = Array.from(xml.getElementsByTagName('Client')).map(c => ({
              Name: c.getElementsByTagName('Name')[0]?.textContent.trim(),
              WebAddress: c.getElementsByTagName('WebAddress')[0]?.textContent.trim()
            }));
          }
          agencies = clients.map(c => {
            const name = c.Name?.trim();
            const webAddress = c.WebAddress?.trim();
            if (!name || !webAddress) return null;
            const url = webAddress.startsWith('http')
              ? webAddress.replace(/^http:\/\//i, 'https://')
              : `https://${webAddress}`;
            return { name, url };
          }).filter(Boolean);
          agencies.sort((a, b) => a.name.localeCompare(b.name));
          const uvaIndex = agencies.findIndex(a => a.name === 'University of Virginia');
          if (uvaIndex > -1) {
            const uva = agencies.splice(uvaIndex, 1)[0];
            agencies.unshift(uva);
          }
          const consent = localStorage.getItem('agencyConsent') === 'true';
          const storedAgency = consent ? localStorage.getItem('selectedAgency') : null;
          if (storedAgency && agencies.some(a => a.url === storedAgency)) {
            baseURL = storedAgency;
          } else {
            baseURL = agencies[0]?.url || '';
          }
          updateRouteSelector(activeRoutes, true);
        } catch (e) {
          console.error('Failed to load agencies', e);
        }
      }

      function positionRouteTab() {
        const panel = document.getElementById("routeSelector");
        const tab = document.getElementById("routeSelectorTab");
        if (!panel || !tab) return;
        const panelStyle = window.getComputedStyle(panel);
        const gap = parseFloat(panelStyle.right) || 0;
        const offset = panel.offsetWidth + gap;
        tab.style.right = panel.classList.contains("hidden") ? "0" : offset + "px";
      }

      window.addEventListener("load", positionRouteTab);
      window.addEventListener("resize", positionRouteTab);

      // Global storage for routes from GetRoutes.
      let allRoutes = {};
      // Global object to store user selections (for admin mode).
      let routeSelections = {};
      // Tracks routes that currently have at least one vehicle assigned.
      let activeRoutes = new Set();
      // Tracks which routes the API designates as public-facing.
      let routeVisibility = {};

      const OVERLAP_DISTANCE_TOLERANCE_METERS = 15;
      const SEGMENT_SAMPLING_DISTANCE_METERS = 12;
      const ANGLE_TOLERANCE_DEGREES = 18;
      const LAT_LNG_BUCKET_SIZE = 0.00018;
      const MIN_SEGMENT_LENGTH_METERS = 0.5;
      const TARGET_STRIPE_LENGTH_METERS = 30;
      const TARGET_STRIPE_SCREEN_LENGTH_PX = 18;
      const MIN_STRIPE_LENGTH_METERS = 20;
      const MAX_STRIPE_LENGTH_METERS = 500000;

      // Routes default to visible if they currently have vehicles unless the user
      // overrides the selection via the route selector.
      function isRouteSelected(routeID) {
        if (!canDisplayRoute(routeID)) return false;
        const id = Number(routeID);
        if (Number.isNaN(id)) return false;
        if (routeSelections.hasOwnProperty(id)) return routeSelections[id];
        return activeRoutes.has(id);
      }

      function setRouteVisibility(route) {
        if (!route || typeof route.RouteID === 'undefined') return;
        const id = Number(route.RouteID);
        if (Number.isNaN(id)) return;
        routeVisibility[id] = route.IsVisibleOnMap !== false;
      }

      function isRoutePublicById(routeID) {
        const id = Number(routeID);
        if (Number.isNaN(id) || id === 0) return false;
        if (Object.prototype.hasOwnProperty.call(routeVisibility, id)) {
          return routeVisibility[id];
        }
        return true;
      }

      function canDisplayRoute(routeID) {
        const id = Number(routeID);
        if (Number.isNaN(id)) return false;
        if (id === 0) {
          return adminKioskMode || (!kioskMode && adminMode);
        }
        if (adminKioskMode) return true;
        if (kioskMode) return isRoutePublicById(id);
        if (adminMode) return true;
        return isRoutePublicById(id);
      }

      // Toggle between displaying speed or block numbers.
      function toggleSpeedOrBlock() {
        if (showSpeed) {
          showSpeed = false;
          showBlockNumbers = true;
        } else {
          showSpeed = true;
          showBlockNumbers = false;
        }
        document.getElementById("toggleDisplayButton").innerHTML = showSpeed ? "Show Block Numbers" : "Show Speed";
        refreshMap();
      }

      // updateRouteSelector rebuilds the route selector panel.
      // The list (excluding Out of Service) is alphabetized and defaults to
      // checking only routes that currently have vehicles.
      function updateRouteSelector(activeRoutes, forceUpdate = false) {
        const container = document.getElementById("routeSelector");
        if (!container) return;
        // If the agency dropdown is currently focused (open), skip rebuilding
        // the selector to avoid closing the dropdown.
        const agencyDropdown = document.getElementById('agencySelect');
        if (!forceUpdate && agencyDropdown && document.activeElement === agencyDropdown) {
          return;
        }
        let html = "";
        html += "<label for='agencySelect'>Select System:</label>";
        html += "<select id='agencySelect' onchange='changeAgency(this.value)'>";
        agencies.forEach(a => {
          html += `<option value="${a.url}" ${a.url === baseURL ? 'selected' : ''}>${a.name}</option>`;
        });
        html += "</select><br/><br/>";
        if (adminMode) {
          // Add the speed/block toggle button in admin mode only.
          html += "<div style='margin-bottom:10px;'><button id='toggleDisplayButton' onclick='toggleSpeedOrBlock()'>" + (showSpeed ? "Show Block Numbers" : "Show Speed") + "</button></div>";
        }
        html += "<h3>Select Routes</h3>" +
          "<button onclick='selectAllRoutes()'>Select All</button>" +
          "<button onclick='deselectAllRoutes()'>Deselect All</button><br/><br/>";

        if (adminMode && canDisplayRoute(0)) {
          // Add Out of Service option (routeID 0) at the top for admin mode.
          let outChecked = routeSelections.hasOwnProperty(0) ? routeSelections[0] : activeRoutes.has(0);
          html += `<label>
            <input type="checkbox" id="route_0" value="0" ${outChecked ? "checked" : ""}>
            <span class="color-box" style="background:${outOfServiceRouteColor};"></span> Out of Service
          </label>`;
        }

        // Get an array of route IDs (excluding 0) from allRoutes.
        let routeIDs = Object.keys(allRoutes)
          .map(id => Number(id))
          .filter(id => !Number.isNaN(id) && id !== 0 && canDisplayRoute(id));
        // Sort alphabetically by route Description (case-insensitive).
        routeIDs.sort((a, b) => {
          let descA = allRoutes[a].Description.toUpperCase();
          let descB = allRoutes[b].Description.toUpperCase();
          if (descA < descB) return -1;
          if (descA > descB) return 1;
          return 0;
        });
        // Append sorted routes.
        routeIDs.forEach(routeID => {
          let route = allRoutes[routeID];
          let checked = routeSelections.hasOwnProperty(routeID) ? routeSelections[routeID] : activeRoutes.has(routeID);
          let displayName = route.Description;
          if (route.InfoText && route.InfoText.trim() !== "") {
            displayName += ` &ndash; ${route.InfoText.trim()}`;
          }
          html += `<label>
            <input type="checkbox" id="route_${routeID}" value="${routeID}" ${checked ? "checked" : ""}>
            <span class="color-box" style="background:${route.MapLineColor};"></span> ${displayName}
          </label>`;
        });
        container.innerHTML = html;
        // Attach event listeners to update routeSelections.
        let outChk = document.getElementById("route_0");
        if (outChk) {
          outChk.addEventListener("change", function() {
            routeSelections[0] = outChk.checked;
            refreshMap();
          });
        }
        routeIDs.forEach(routeID => {
          if (!canDisplayRoute(routeID) || Number(routeID) === 0) return;
          let chk = document.getElementById("route_" + routeID);
          if (chk) {
            chk.addEventListener("change", function() {
              routeSelections[routeID] = chk.checked;
              refreshMap();
            });
          }
        });
      }

      function selectAllRoutes() {
        if (adminMode && canDisplayRoute(0)) {
          let outChk = document.getElementById("route_0");
          if (outChk) outChk.checked = true;
          routeSelections[0] = true;
        }
        for (let routeID in allRoutes) {
          if (!canDisplayRoute(routeID) || Number(routeID) === 0) continue;
          let chk = document.getElementById("route_" + routeID);
          if (chk) chk.checked = true;
          routeSelections[routeID] = true;
        }
        refreshMap();
      }

      function deselectAllRoutes() {
        if (adminMode && canDisplayRoute(0)) {
          let outChk = document.getElementById("route_0");
          if (outChk) outChk.checked = false;
          routeSelections[0] = false;
        }
        for (let routeID in allRoutes) {
          if (!canDisplayRoute(routeID) || Number(routeID) === 0) continue;
          let chk = document.getElementById("route_" + routeID);
          if (chk) chk.checked = false;
          routeSelections[routeID] = false;
        }
        refreshMap();
      }

      // togglePanel toggles the route selector panel's visibility.
      function togglePanel() {
        let panel = document.getElementById("routeSelector");
        let tab = document.getElementById("routeSelectorTab");
        if (panel.classList.contains("hidden")) {
          panel.classList.remove("hidden");
          tab.innerHTML = "&#9664;"; // left arrow
        } else {
          panel.classList.add("hidden");
          tab.innerHTML = "&#9654;"; // right arrow
        }
        positionRouteTab();
      }

      function updateRouteLegend(displayedRoutes = []) {
        const legend = document.getElementById("routeLegend");
        if (!legend) return;
        const shouldShowLegend = kioskMode || adminKioskMode;
        if (!shouldShowLegend) {
          legend.style.display = "none";
          legend.innerHTML = "";
          return;
        }

        // Admin kiosk mode should surface every visible route, including those hidden from the public map.
        // Public kiosk mode must continue to hide routes flagged as non-public.
        const routesToRender = adminKioskMode
          ? displayedRoutes
          : displayedRoutes.filter(route => isRoutePublicById(route.routeId ?? route.routeID ?? route.id));

        if (routesToRender.length === 0) {
          legend.style.display = "none";
          legend.innerHTML = "";
          return;
        }

        legend.style.display = "block";
        legend.innerHTML = "";

        const title = document.createElement("div");
        title.className = "legend-title";
        title.textContent = "Routes";
        legend.appendChild(title);

        routesToRender.forEach(route => {
          const item = document.createElement("div");
          item.className = "legend-item";

          const color = document.createElement("span");
          color.className = "legend-color";
          color.style.backgroundColor = route.color || "#000000";
          item.appendChild(color);

          const textContainer = document.createElement("div");
          textContainer.className = "legend-text";

          const name = document.createElement("div");
          name.className = "legend-name";
          name.textContent = route.name;
          textContainer.appendChild(name);

          if (route.description) {
            const description = document.createElement("div");
            description.className = "legend-description";
            description.textContent = route.description;
            textContainer.appendChild(description);
          }

          item.appendChild(textContainer);
          legend.appendChild(item);
        });
      }

      // refreshMap updates route paths and bus locations.
      function refreshMap() {
        fetchBusLocations().then(fetchRoutePaths);
      }

      function clearRefreshIntervals() {
        refreshIntervals.forEach(clearInterval);
        refreshIntervals = [];
      }

      function startRefreshIntervals() {
        refreshIntervals.push(setInterval(fetchBusLocations, 4000));
        refreshIntervals.push(setInterval(fetchBusStops, 60000));
        refreshIntervals.push(setInterval(fetchBlockAssignments, 60000));
        refreshIntervals.push(setInterval(() => {
          fetchStopArrivalTimes().then(allEtas => {
            cachedEtas = allEtas;
            updateCustomPopups();
          });
        }, 15000));
        refreshIntervals.push(setInterval(fetchRoutePaths, 15000));
      }

      function showCookieBanner() {
        if (kioskMode || adminKioskMode) {
          return;
        }
        if (localStorage.getItem('agencyConsent') !== 'true') {
          const banner = document.getElementById('cookieBanner');
          banner.style.display = 'block';
          document.getElementById('cookieAccept').addEventListener('click', () => {
            localStorage.setItem('agencyConsent', 'true');
            localStorage.setItem('selectedAgency', baseURL);
            banner.style.display = 'none';
          });
        }
      }

      function changeAgency(url) {
        if (localStorage.getItem('agencyConsent') === 'true') {
          localStorage.setItem('selectedAgency', url);
        }
        clearRefreshIntervals();
        baseURL = url;
        Object.values(markers).forEach(m => map.removeLayer(m));
        markers = {};
        Object.values(nameBubbles).forEach(b => {
          if (b.speedMarker) map.removeLayer(b.speedMarker);
          if (b.nameMarker) map.removeLayer(b.nameMarker);
          if (b.blockMarker) map.removeLayer(b.blockMarker);
        });
        nameBubbles = {};
        stopMarkers.forEach(m => map.removeLayer(m));
        stopMarkers = [];
        routeLayers.forEach(l => map.removeLayer(l));
        routeLayers = [];
        cachedRouteVisualization = null;
        busBlocks = {};
        previousBusData = {};
        cachedEtas = {};
        customPopups.forEach(p => p.remove());
        customPopups = [];
        allRoutes = {};
        routeSelections = {};
        activeRoutes = new Set();
        routeColors = {};
        routeVisibility = {};
        allRouteBounds = null;
        mapHasFitAllRoutes = false;
        updateRouteLegend([]);
        updateRouteSelector(new Set(), true);
        fetchRouteColors().then(() => {
          fetchBusStops();
          fetchBlockAssignments();
          fetchBusLocations().then(fetchRoutePaths);
          fetchStopArrivalTimes().then(allEtas => { cachedEtas = allEtas; updateCustomPopups(); });
          startRefreshIntervals();
        });
      }

      function getRouteColor(routeID) {
        if (routeID === 0) return outOfServiceRouteColor;
        return routeColors[routeID] || '#000000';
      }

      function initMap() {
          map = L.map('map', { zoomControl: false }).setView([38.03799212281404, -78.50981502838886], 15);
          const cartoLight = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
              attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>'
          });
          cartoLight.addTo(map);
          
          fetchRouteColors().then(() => {
              if (kioskMode || adminKioskMode) {
                document.getElementById("routeSelector").style.display = "none";
                document.getElementById("routeSelectorTab").style.display = "none";
              }
              fetchStopArrivalTimes().then(allEtas => {
                  cachedEtas = allEtas;
                  updateCustomPopups();
              });
              fetchBusStops();
              fetchBlockAssignments();
              fetchBusLocations().then(fetchRoutePaths);
              startRefreshIntervals();
          });
          fetchStopArrivalTimes().then(allEtas => { cachedEtas = allEtas; });
          map.on('move', updatePopupPositions);
          map.on('zoom', updatePopupPositions);
          map.on('zoomend', () => {
              if (cachedRouteVisualization) {
                  renderRouteVisualization(cachedRouteVisualization);
              }
          });
      }

      function fetchBusStops() {
          const currentBaseURL = baseURL;
          const stopsApiUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetStops?APIKey=8882812681`;
          fetch(stopsApiUrl)
              .then(response => response.json())
              .then(data => {
                  if (currentBaseURL !== baseURL) return;
                  let stopsArray = data.stops || data;
                  if (stopsArray && Array.isArray(stopsArray)) {
                      stopMarkers.forEach(marker => map.removeLayer(marker));
                      stopMarkers = [];
                      const groupedStops = {};
                      stopsArray.forEach(stop => {
                          const key = `${stop.Latitude},${stop.Longitude}`;
                          if (!groupedStops[key]) groupedStops[key] = [];
                          groupedStops[key].push(stop);
                      });
                      Object.keys(groupedStops).forEach(key => {
                          const [latitude, longitude] = key.split(',').map(Number);
                          const stopPosition = [latitude, longitude];
                          const stopMarker = L.circleMarker(stopPosition, {
                              radius: 6,
                              color: "#000000",
                              fillColor: "#FFFFFF",
                              fillOpacity: 1,
                              weight: 3
                          }).addTo(map);
                          const routeStopIds = groupedStops[key].map(stop => stop.RouteStopID);
                          const unifiedStopId = groupedStops[key][0].StopID || groupedStops[key][0].StopId;
                          const etas = [];
                          routeStopIds.forEach(routeStopId => {
                              if (cachedEtas[routeStopId]) {
                                  cachedEtas[routeStopId].forEach(eta => etas.push(eta));
                              }
                          });
                          const stopNames = groupedStops[key][0].Description;
                          const etaText = etas.length > 0
                            ? etas.sort((a, b) => a.etaMinutes - b.etaMinutes || a.routeDescription.localeCompare(b.routeDescription))
                                  .map(eta => `<tr><td style="padding: 5px; text-align: center;"><div class="route-pill" style="background-color: ${getRouteColor(eta.RouteId)}; color: ${getContrastColor(getRouteColor(eta.RouteId))};">${eta.routeDescription}</div></td><td style="padding: 5px; text-align: center;">${eta.etaMinutes < 1 ? 'Arriving' : eta.etaMinutes + ' min'}</td></tr>`).join('')
                            : '<tr><td colspan="2" style="padding: 5px; text-align: center;">No upcoming arrivals</td></tr>';
                          stopMarker.on('click', () => {
                              createCustomPopup(stopPosition, stopNames, etaText, routeStopIds, unifiedStopId);
                          });
                          stopMarkers.push(stopMarker);
                      });
                      stopMarkers.forEach(marker => marker.bringToFront());
                  }
              })
              .catch(error => console.error("Error fetching bus stops:", error));
      }

      function createCustomPopup(position, stopName, etaText, routeStopIds, stopId) {
          customPopups.forEach(popup => popup.remove());
          customPopups = [];
          const popupElement = document.createElement('div');
          popupElement.className = 'custom-popup';
          const etaTable = `
            <table style="width: 100%; margin-top: 10px; border-collapse: collapse;">
              <thead>
                <tr>
                  <th style="border-bottom: 1px solid white; padding: 5px;">Route</th>
                  <th style="border-bottom: 1px solid white; padding: 5px;">ETA</th>
                </tr>
              </thead>
              <tbody>
                ${etaText}
              </tbody>
            </table>
          `;
          popupElement.innerHTML = `
            <button class="custom-popup-close">&times;</button>
            <span style="font-size: 16px; font-weight: bold;">${stopName}</span><br>
            <span>Stop ID: ${stopId}</span><br>
            ${etaTable}
            <div class="custom-popup-arrow"></div>
          `;
          document.body.appendChild(popupElement);
          popupElement.dataset.position = `${position[0]},${position[1]}`;
          popupElement.dataset.stopName = stopName.replace('Stop Name: ', '');
          popupElement.dataset.routeStopIds = JSON.stringify(routeStopIds);
          popupElement.dataset.stopId = stopId;
          updatePopupPosition(popupElement, position);
          popupElement.querySelector('.custom-popup-close').addEventListener('click', () => {
              popupElement.remove();
              customPopups = customPopups.filter(popup => popup !== popupElement);
          });
          customPopups.push(popupElement);
      }

      function updatePopupPosition(popupElement, position) {
          const mapPos = map.latLngToContainerPoint(position);
          popupElement.style.left = `${mapPos.x}px`;
          popupElement.style.top = `${mapPos.y}px`;
      }

      function updatePopupPositions() {
          customPopups.forEach(popupElement => {
              const position = popupElement.dataset.position;
              if (position) {
                  const [latitude, longitude] = position.split(',').map(Number);
                  updatePopupPosition(popupElement, [latitude, longitude]);
              }
          });
      }

      function updateCustomPopups() {
          customPopups.forEach(popupElement => {
              const position = popupElement.dataset.position;
              if (position) {
                  const routeStopIds = JSON.parse(popupElement.dataset.routeStopIds);
                  const etas = [];
                  routeStopIds.forEach(routeStopId => {
                      if (cachedEtas[routeStopId]) {
                          cachedEtas[routeStopId].forEach(eta => etas.push(eta));
                      }
                  });
                  const etaText = etas.length > 0
                    ? etas.sort((a, b) => a.etaMinutes - b.etaMinutes || a.routeDescription.localeCompare(b.routeDescription))
                          .map(eta => `<tr><td style="padding: 5px; text-align: center;"><div class="route-pill" style="background-color: ${getRouteColor(eta.RouteId)}; color: ${getContrastColor(getRouteColor(eta.RouteId))};">${eta.routeDescription}</div></td><td style="padding: 5px; text-align: center;">${eta.etaMinutes < 1 ? 'Arriving' : eta.etaMinutes + ' min'}</td></tr>`).join('')
                    : '<tr><td colspan="2" style="padding: 5px; text-align: center;">No upcoming arrivals</td></tr>';
                  const etaTable = `
                    <table style="width: 100%; margin-top: 10px; border-collapse: collapse;">
                      <thead>
                        <tr>
                          <th style="border-bottom: 1px solid white; padding: 5px;">Route</th>
                          <th style="border-bottom: 1px solid white; padding: 5px;">ETA</th>
                        </tr>
                      </thead>
                      <tbody>
                        ${etaText}
                      </tbody>
                    </table>
                  `;
                  const stopId = popupElement.dataset.stopId;
                  popupElement.innerHTML = `
                    <button class="custom-popup-close">&times;</button>
                    <span style="font-size: 16px; font-weight: bold;">${popupElement.dataset.stopName}</span><br>
                    <span>Stop ID: ${stopId}</span><br>
                    ${etaTable}
                    <div class="custom-popup-arrow"></div>
                  `;
                  popupElement.querySelector('.custom-popup-close').addEventListener('click', () => {
                      popupElement.remove();
                      customPopups = customPopups.filter(popup => popup !== popupElement);
                  });
              }
          });
      }

      function fetchStopArrivalTimes() {
          const currentBaseURL = baseURL;
          const arrivalTimesApiUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetStopArrivalTimes?APIKey=8882812681`;
          return fetch(arrivalTimesApiUrl)
              .then(response => response.json())
              .then(data => {
                  if (currentBaseURL !== baseURL) return {};
                  let allEtas = {};
                  data.forEach(arrival => {
                      if (!allEtas[arrival.RouteStopId]) {
                          allEtas[arrival.RouteStopId] = [];
                      }
                      arrival.Times.forEach(time => {
                          const etaMinutes = Math.round(time.Seconds / 60);
                          allEtas[arrival.RouteStopId].push({
                              routeDescription: (arrival.RouteDescription === 'Night Pilot' ? arrival.RouteDescription : arrival.RouteDescription.slice(0, -5)),
                              etaMinutes: etaMinutes,
                              RouteId: arrival.RouteId
                          });
                      });
                  });
                  return allEtas;
              })
              .catch(error => {
                  console.error("Error fetching stop arrival times:", error);
                  return {};
              });
      }

      // Fetch routes from GetRoutes.
      function fetchRouteColors() {
        console.log('Fetching route colors...');
        const routesApiUrl = `${baseURL}/Services/JSONPRelay.svc/GetRoutes?APIKey=8882812681`;
        return fetch(routesApiUrl)
          .then(response => response.json())
          .then(data => {
            if (Array.isArray(data)) {
              data.forEach(route => {
                setRouteVisibility(route);
                allRoutes[route.RouteID] = Object.assign(allRoutes[route.RouteID] || {}, route);
                if (canDisplayRoute(route.RouteID)) {
                  routeColors[route.RouteID] = route.MapLineColor;
                  console.log(`Route ID: ${route.RouteID}, Color: ${route.MapLineColor}`);
                } else {
                  delete routeColors[route.RouteID];
                  console.log(`Route ID: ${route.RouteID} hidden due to display settings`);
                }
              });
            }
          })
          .catch(error => console.error("Error fetching route colors:", error));
      }

      function toRadians(degrees) {
        return degrees * Math.PI / 180;
      }

      function distanceMeters(a, b) {
        if (!a || !b || a.length < 2 || b.length < 2) return Infinity;
        const lat1 = toRadians(a[0]);
        const lat2 = toRadians(b[0]);
        const dLat = lat2 - lat1;
        const dLng = toRadians(b[1] - a[1]);
        const sinDLat = Math.sin(dLat / 2);
        const sinDLng = Math.sin(dLng / 2);
        const aa = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLng * sinDLng;
        const c = 2 * Math.atan2(Math.sqrt(aa), Math.sqrt(Math.max(0, 1 - aa)));
        return 6371000 * c;
      }

      function bearingDegrees(a, b) {
        if (!a || !b || a.length < 2 || b.length < 2) return 0;
        const lat1 = toRadians(a[0]);
        const lat2 = toRadians(b[0]);
        const dLng = toRadians(b[1] - a[1]);
        const y = Math.sin(dLng) * Math.cos(lat2);
        const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLng);
        const raw = Math.atan2(y, x);
        const degrees = (raw * 180 / Math.PI + 360) % 360;
        return degrees;
      }

      function normalizeBearing(angle) {
        if (!Number.isFinite(angle)) return 0;
        const normalized = ((angle % 360) + 360) % 360;
        return normalized >= 180 ? normalized - 180 : normalized;
      }

      function angleDifference(a, b) {
        if (!Number.isFinite(a) || !Number.isFinite(b)) return 180;
        const diff = Math.abs(a - b);
        return Math.min(diff, 180 - diff);
      }

      function densifyPolyline(points, maxSegmentLengthMeters) {
        if (!Array.isArray(points) || points.length === 0) return [];
        const result = [];
        const maxSegment = Math.max(1, maxSegmentLengthMeters || SEGMENT_SAMPLING_DISTANCE_METERS);
        result.push(points[0]);
        for (let i = 1; i < points.length; i++) {
          const start = points[i - 1];
          const end = points[i];
          if (!start || !end) continue;
          const dist = distanceMeters(start, end);
          if (!Number.isFinite(dist) || dist === 0) {
            const lastPoint = result[result.length - 1];
            if (!lastPoint || lastPoint[0] !== end[0] || lastPoint[1] !== end[1]) {
              result.push(end);
            }
            continue;
          }
          const segments = Math.max(1, Math.ceil(dist / maxSegment));
          for (let step = 1; step <= segments; step++) {
            const fraction = step / segments;
            const lat = start[0] + (end[0] - start[0]) * fraction;
            const lng = start[1] + (end[1] - start[1]) * fraction;
            const lastPoint = result[result.length - 1];
            if (!lastPoint || Math.abs(lastPoint[0] - lat) > 1e-12 || Math.abs(lastPoint[1] - lng) > 1e-12) {
              result.push([lat, lng]);
            }
          }
        }
        return result;
      }

      function computePolylineLength(points) {
        if (!Array.isArray(points) || points.length < 2) return 0;
        let total = 0;
        for (let i = 1; i < points.length; i++) {
          const dist = distanceMeters(points[i - 1], points[i]);
          if (Number.isFinite(dist)) {
            total += dist;
          }
        }
        return total;
      }

      function computeCumulativeDistances(points) {
        if (!Array.isArray(points) || points.length === 0) return [];
        const cumulative = [0];
        for (let i = 1; i < points.length; i++) {
          const prevTotal = cumulative[i - 1];
          const segmentLength = distanceMeters(points[i - 1], points[i]);
          cumulative.push(prevTotal + (Number.isFinite(segmentLength) && segmentLength > 0 ? segmentLength : 0));
        }
        return cumulative;
      }

      function getPointAtDistanceOnPath(points, targetDistance, cumulativeDistances = null) {
        if (!Array.isArray(points) || points.length === 0) return null;
        const cumulative = Array.isArray(cumulativeDistances) && cumulativeDistances.length === points.length
          ? cumulativeDistances
          : computeCumulativeDistances(points);
        if (cumulative.length === 0) return points[0];
        const totalLength = cumulative[cumulative.length - 1];
        if (!Number.isFinite(totalLength) || totalLength <= 0) {
          const first = points[0];
          return [first[0], first[1]];
        }
        const target = Math.max(0, Math.min(totalLength, Number.isFinite(targetDistance) ? targetDistance : 0));
        let index = 0;
        while (index < cumulative.length && cumulative[index] < target) {
          index++;
        }
        if (index <= 0) {
          const first = points[0];
          return [first[0], first[1]];
        }
        if (index >= cumulative.length) {
          const last = points[points.length - 1];
          return [last[0], last[1]];
        }
        if (Math.abs(cumulative[index] - target) <= 1e-9) {
          const exact = points[index];
          return [exact[0], exact[1]];
        }
        const prevIndex = index - 1;
        const prevDistance = cumulative[prevIndex];
        const segmentLength = cumulative[index] - prevDistance;
        if (!Number.isFinite(segmentLength) || segmentLength <= 0) {
          const point = points[index];
          return [point[0], point[1]];
        }
        const t = (target - prevDistance) / segmentLength;
        const start = points[prevIndex];
        const end = points[index];
        const lat = start[0] + (end[0] - start[0]) * t;
        const lng = start[1] + (end[1] - start[1]) * t;
        return [lat, lng];
      }

      function buildAveragedPath(referencePoints, referenceDistances, shapeInfos) {
        if (!Array.isArray(referencePoints) || referencePoints.length < 2) {
          return Array.isArray(referencePoints)
            ? referencePoints.map(pt => [pt[0], pt[1]])
            : [];
        }
        const sanitizedDistances = Array.isArray(referenceDistances) && referenceDistances.length === referencePoints.length
          ? referenceDistances
          : computeCumulativeDistances(referencePoints);
        if (sanitizedDistances.length !== referencePoints.length) {
          return referencePoints.map(pt => [pt[0], pt[1]]);
        }
        const totalReferenceLength = sanitizedDistances[sanitizedDistances.length - 1];
        if (!Number.isFinite(totalReferenceLength) || totalReferenceLength <= 0) {
          return referencePoints.map(pt => [pt[0], pt[1]]);
        }
        return referencePoints.map((refPoint, idx) => {
          const distanceAlong = sanitizedDistances[idx];
          const ratio = totalReferenceLength > 0 ? distanceAlong / totalReferenceLength : 0;
          const contributions = [];
          shapeInfos.forEach(info => {
            if (!info || !Array.isArray(info.pathPoints) || info.pathPoints.length === 0) return;
            const totalLength = Number.isFinite(info.totalLength) ? info.totalLength : 0;
            if (totalLength <= 0) {
              const first = info.pathPoints[0];
              contributions.push([first[0], first[1]]);
              return;
            }
            const targetDistance = ratio * totalLength;
            const point = getPointAtDistanceOnPath(info.pathPoints, targetDistance, info.cumulativeDistances);
            if (Array.isArray(point) && point.length === 2 && Number.isFinite(point[0]) && Number.isFinite(point[1])) {
              contributions.push(point);
            }
          });
          if (!contributions.length) {
            return [refPoint[0], refPoint[1]];
          }
          const summed = contributions.reduce((acc, coord) => {
            acc[0] += coord[0];
            acc[1] += coord[1];
            return acc;
          }, [0, 0]);
          return [
            summed[0] / contributions.length,
            summed[1] / contributions.length
          ];
        });
      }

      function mergeReplacementPoint(replacements, index, point) {
        if (!(replacements instanceof Map)) return;
        if (!Number.isFinite(index)) return;
        if (!Array.isArray(point) || point.length < 2) return;
        const sanitized = [point[0], point[1]];
        if (replacements.has(index)) {
          const existing = replacements.get(index);
          if (Array.isArray(existing) && existing.length === 2) {
            replacements.set(index, [
              (existing[0] + sanitized[0]) / 2,
              (existing[1] + sanitized[1]) / 2
            ]);
            return;
          }
        }
        replacements.set(index, sanitized);
      }

      function getAdjustedPointForIndex(replacements, index, originalPoint) {
        if (!Array.isArray(originalPoint) || originalPoint.length < 2) return originalPoint;
        if (!(replacements instanceof Map) || !Number.isFinite(index)) {
          return [originalPoint[0], originalPoint[1]];
        }
        const replacement = replacements.get(index);
        if (!replacement || !Array.isArray(replacement) || replacement.length < 2) {
          return [originalPoint[0], originalPoint[1]];
        }
        return [replacement[0], replacement[1]];
      }

      function interpolatePoint(a, b, fraction) {
        if (!Array.isArray(a) || !Array.isArray(b)) return a;
        const t = Math.min(1, Math.max(0, Number.isFinite(fraction) ? fraction : 0));
        const lat = a[0] + (b[0] - a[0]) * t;
        const lng = a[1] + (b[1] - a[1]) * t;
        return [lat, lng];
      }

      function splitPolylineByLength(points, segmentLengthMeters) {
        if (!Array.isArray(points) || points.length < 2 || !Number.isFinite(segmentLengthMeters) || segmentLengthMeters <= 0) {
          return [];
        }

        const EPSILON = 1e-9;
        const segments = [];
        let currentSegment = [points[0]];
        let distanceIntoSegment = 0;
        let previousPoint = points[0];

        for (let i = 1; i < points.length; i++) {
          const nextPoint = points[i];
          if (!nextPoint) continue;

          let remainingDistance = distanceMeters(previousPoint, nextPoint);
          if (!Number.isFinite(remainingDistance) || remainingDistance <= EPSILON) {
            const lastPoint = currentSegment[currentSegment.length - 1];
            if (!lastPoint || Math.abs(lastPoint[0] - nextPoint[0]) > EPSILON || Math.abs(lastPoint[1] - nextPoint[1]) > EPSILON) {
              currentSegment.push(nextPoint);
            }
            previousPoint = nextPoint;
            continue;
          }

          let startPoint = previousPoint;
          while (distanceIntoSegment + remainingDistance >= segmentLengthMeters - EPSILON) {
            const distanceNeeded = segmentLengthMeters - distanceIntoSegment;
            const fraction = Math.min(1, distanceNeeded / remainingDistance);
            const interpolatedPoint = interpolatePoint(startPoint, nextPoint, fraction);
            currentSegment.push(interpolatedPoint);
            segments.push(currentSegment);
            currentSegment = [interpolatedPoint];
            startPoint = interpolatedPoint;
            remainingDistance = Math.max(0, remainingDistance - distanceNeeded);
            distanceIntoSegment = 0;
          }

          if (remainingDistance > EPSILON) {
            distanceIntoSegment += remainingDistance;
            const lastPoint = currentSegment[currentSegment.length - 1];
            if (!lastPoint || Math.abs(lastPoint[0] - nextPoint[0]) > EPSILON || Math.abs(lastPoint[1] - nextPoint[1]) > EPSILON) {
              currentSegment.push(nextPoint);
            }
          } else {
            currentSegment = [nextPoint];
            distanceIntoSegment = 0;
          }

          previousPoint = nextPoint;
        }

        if (currentSegment.length > 1) {
          segments.push(currentSegment);
        }

        return segments;
      }

      function createStripeSegments(points, stripeLengthMeters, totalColors, startColorIndex = 0, startOffsetMeters = 0) {
        const sanitizedColors = Number.isFinite(totalColors) && totalColors > 0 ? Math.floor(totalColors) : 0;
        if (!Array.isArray(points) || points.length < 2 || !Number.isFinite(stripeLengthMeters) || stripeLengthMeters <= 0 || sanitizedColors === 0) {
          return { segments: [], endColorIndex: 0, endOffset: 0 };
        }

        const EPSILON = 1e-6;
        const normalizedStripeLength = Math.max(EPSILON, stripeLengthMeters);
        const normalizedStartColor = ((Math.floor(startColorIndex) % sanitizedColors) + sanitizedColors) % sanitizedColors;
        const initialOffset = Math.min(
          Math.max(Number.isFinite(startOffsetMeters) ? startOffsetMeters : 0, 0),
          normalizedStripeLength - EPSILON
        );

        const segments = [];
        let currentColorIndex = normalizedStartColor;
        let consumedInColor = initialOffset;
        let currentPoints = [points[0]];

        for (let i = 1; i < points.length; i++) {
          let prevPoint = points[i - 1];
          const nextPoint = points[i];
          if (!prevPoint || !nextPoint) continue;

          let remainingDistance = distanceMeters(prevPoint, nextPoint);
          if (!Number.isFinite(remainingDistance) || remainingDistance <= EPSILON) {
            const lastPoint = currentPoints[currentPoints.length - 1];
            if (!lastPoint || Math.abs(lastPoint[0] - nextPoint[0]) > EPSILON || Math.abs(lastPoint[1] - nextPoint[1]) > EPSILON) {
              currentPoints.push(nextPoint);
            }
            continue;
          }

          while (remainingDistance > EPSILON) {
            const remainingForColor = normalizedStripeLength - consumedInColor;
            if (remainingForColor <= EPSILON) {
              if (currentPoints.length > 1) {
                segments.push({ colorIndex: currentColorIndex, points: currentPoints });
              }
              currentColorIndex = (currentColorIndex + 1) % sanitizedColors;
              consumedInColor = 0;
              currentPoints = [prevPoint];
              continue;
            }

            if (remainingDistance <= remainingForColor + EPSILON) {
              currentPoints.push(nextPoint);
              consumedInColor += remainingDistance;
              remainingDistance = 0;
              prevPoint = nextPoint;
              if (consumedInColor >= normalizedStripeLength - EPSILON) {
                segments.push({ colorIndex: currentColorIndex, points: currentPoints });
                currentColorIndex = (currentColorIndex + 1) % sanitizedColors;
                consumedInColor = 0;
                currentPoints = [nextPoint];
              }
            } else {
              const distanceNeeded = Math.max(remainingForColor, EPSILON);
              const fraction = distanceNeeded / remainingDistance;
              const interpolatedPoint = interpolatePoint(prevPoint, nextPoint, fraction);
              currentPoints.push(interpolatedPoint);
              segments.push({ colorIndex: currentColorIndex, points: currentPoints });
              currentColorIndex = (currentColorIndex + 1) % sanitizedColors;
              consumedInColor = 0;
              currentPoints = [interpolatedPoint];
              prevPoint = interpolatedPoint;
              remainingDistance = Math.max(0, remainingDistance - distanceNeeded);
            }
          }
        }

        if (currentPoints.length > 1) {
          segments.push({ colorIndex: currentColorIndex, points: currentPoints });
        }

        const endOffset = consumedInColor >= normalizedStripeLength - EPSILON ? 0 : consumedInColor;
        const endColorIndex = consumedInColor >= normalizedStripeLength - EPSILON
          ? (currentColorIndex + 1) % sanitizedColors
          : currentColorIndex;

        return { segments, endColorIndex, endOffset };
      }

      function createSegmentBucketKey(segment) {
        const latIdx = Math.round(segment.mid[0] / LAT_LNG_BUCKET_SIZE);
        const lngIdx = Math.round(segment.mid[1] / LAT_LNG_BUCKET_SIZE);
        const angleIdx = Math.round(segment.bearing / ANGLE_TOLERANCE_DEGREES);
        return `${latIdx}|${lngIdx}|${angleIdx}`;
      }

      function clusterSegments(segments) {
        if (!Array.isArray(segments) || segments.length === 0) return [];
        const parents = segments.map((_, idx) => idx);

        function find(idx) {
          if (parents[idx] !== idx) {
            parents[idx] = find(parents[idx]);
          }
          return parents[idx];
        }

        function union(a, b) {
          const rootA = find(a);
          const rootB = find(b);
          if (rootA === rootB) return;
          parents[rootB] = rootA;
        }

        for (let i = 0; i < segments.length; i++) {
          for (let j = i + 1; j < segments.length; j++) {
            const segA = segments[i];
            const segB = segments[j];
            if (!segA || !segB) continue;
            if (segA.routeId === segB.routeId) continue;
            const angleDiff = angleDifference(segA.bearing, segB.bearing);
            if (angleDiff > ANGLE_TOLERANCE_DEGREES) continue;
            const midDist = distanceMeters(segA.mid, segB.mid);
            if (midDist > OVERLAP_DISTANCE_TOLERANCE_METERS) continue;
            union(i, j);
          }
        }

        const indicesByShape = new Map();
        segments.forEach((seg, idx) => {
          if (!seg || !seg.shapeId) return;
          const key = seg.shapeId;
          if (!indicesByShape.has(key)) indicesByShape.set(key, []);
          indicesByShape.get(key).push(idx);
        });
        indicesByShape.forEach(indexList => {
          indexList.sort((a, b) => segments[a].index - segments[b].index);
          for (let k = 1; k < indexList.length; k++) {
            const prevSeg = segments[indexList[k - 1]];
            const currSeg = segments[indexList[k]];
            if (prevSeg && currSeg && Math.abs(currSeg.index - prevSeg.index) === 1) {
              union(indexList[k - 1], indexList[k]);
            }
          }
        });

        const groupsMap = new Map();
        segments.forEach((seg, idx) => {
          if (!seg) return;
          const root = find(idx);
          if (!groupsMap.has(root)) groupsMap.set(root, []);
          groupsMap.get(root).push(seg);
        });
        return Array.from(groupsMap.values());
      }

      function normalizeColorInfos(colorInfos) {
        if (!Array.isArray(colorInfos)) return [];
        const unique = [];
        const seen = new Set();
        colorInfos.forEach(info => {
          if (!info) return;
          const color = typeof info.color === 'string' && info.color ? info.color : '#000000';
          const routeId = info.routeId;
          const key = routeId != null ? `id:${routeId}` : `color:${color}`;
          if (seen.has(key)) return;
          seen.add(key);
          unique.push({ routeId, color });
        });
        unique.sort((a, b) => {
          const idA = a.routeId;
          const idB = b.routeId;
          if (typeof idA === 'number' && typeof idB === 'number') {
            return idA - idB;
          }
          return String(idA).localeCompare(String(idB));
        });
        return unique;
      }

      function colorInfoKeyFromNormalizedInfos(normalizedInfos) {
        if (!Array.isArray(normalizedInfos) || !normalizedInfos.length) return '';
        return normalizedInfos.map(info => {
          const id = info.routeId != null ? info.routeId : 'null';
          const color = info.color || '#000000';
          return `${id}:${color}`;
        }).join('|');
      }

      function computeAdaptiveStripeBaseLengthMeters() {
        if (!map || typeof map.getCenter !== 'function') {
          return TARGET_STRIPE_LENGTH_METERS;
        }
        try {
          const center = map.getCenter();
          if (!center) return TARGET_STRIPE_LENGTH_METERS;
          const centerPoint = map.latLngToContainerPoint(center);
          if (!centerPoint || !Number.isFinite(centerPoint.x) || !Number.isFinite(centerPoint.y)) {
            return TARGET_STRIPE_LENGTH_METERS;
          }
          const samplePoint = L.point(centerPoint.x + TARGET_STRIPE_SCREEN_LENGTH_PX, centerPoint.y);
          const sampleLatLng = map.containerPointToLatLng(samplePoint);
          if (!sampleLatLng) return TARGET_STRIPE_LENGTH_METERS;
          const distance = map.distance(center, sampleLatLng);
          if (!Number.isFinite(distance) || distance <= 0) {
            return TARGET_STRIPE_LENGTH_METERS;
          }
          const clamped = Math.max(
            MIN_STRIPE_LENGTH_METERS,
            Math.min(MAX_STRIPE_LENGTH_METERS, distance)
          );
          return clamped;
        } catch (err) {
          return TARGET_STRIPE_LENGTH_METERS;
        }
      }

      function computeRouteOverlapGraphics(routes) {
        if (!Array.isArray(routes) || routes.length === 0) {
          return { overlaps: [], nonOverlap: [] };
        }

        const colorByRoute = new Map();
        const densifiedByShape = new Map();
        const segmentFlagsByShape = new Map();
        const shapeToRoute = new Map();
        const shapeMetadata = [];
        const bucketMap = new Map();
        const boundaryReplacementsByShape = new Map();

        routes.forEach((route, idx) => {
          const routeId = route.routeId;
          colorByRoute.set(routeId, route.color);
          const shapeId = `${String(routeId)}__${idx}`;
          shapeToRoute.set(shapeId, routeId);
          shapeMetadata.push({ shapeId, routeId });
          const pathPoints = densifyPolyline(route.points, SEGMENT_SAMPLING_DISTANCE_METERS);
          densifiedByShape.set(shapeId, pathPoints);
          const segmentFlags = new Array(Math.max(0, pathPoints.length - 1)).fill(false);
          segmentFlagsByShape.set(shapeId, segmentFlags);
          for (let i = 0; i < pathPoints.length - 1; i++) {
            const start = pathPoints[i];
            const end = pathPoints[i + 1];
            const length = distanceMeters(start, end);
            if (!Number.isFinite(length) || length < MIN_SEGMENT_LENGTH_METERS) continue;
            const mid = [(start[0] + end[0]) / 2, (start[1] + end[1]) / 2];
            const bearing = normalizeBearing(bearingDegrees(start, end));
            const segment = { routeId, shapeId, index: i, start, end, mid, length, bearing };
            const bucketKey = createSegmentBucketKey(segment);
            if (!bucketMap.has(bucketKey)) bucketMap.set(bucketKey, []);
            bucketMap.get(bucketKey).push(segment);
          }
        });

        const overlaps = [];
        bucketMap.forEach(segmentList => {
          const clusters = clusterSegments(segmentList);
          clusters.forEach(cluster => {
            const routesInCluster = new Set(cluster.map(seg => seg.routeId));
            if (routesInCluster.size < 2) return;

            const segmentsGroupedByShape = new Map();
            cluster.forEach(seg => {
              if (!segmentsGroupedByShape.has(seg.shapeId)) segmentsGroupedByShape.set(seg.shapeId, []);
              segmentsGroupedByShape.get(seg.shapeId).push(seg);
            });

            let baseShapeId = null;
            let maxSegmentCount = -1;
            segmentsGroupedByShape.forEach((list, shapeId) => {
              if (list.length > maxSegmentCount) {
                maxSegmentCount = list.length;
                baseShapeId = shapeId;
              }
            });
            if (baseShapeId === null) return;

            const baseSegments = segmentsGroupedByShape.get(baseShapeId).slice().sort((a, b) => a.index - b.index);
            if (!baseSegments.length) return;

            let currentRun = [baseSegments[0]];
            const runs = [];
            for (let i = 1; i < baseSegments.length; i++) {
              const prev = baseSegments[i - 1];
              const curr = baseSegments[i];
              if (curr.index === prev.index + 1) {
                currentRun.push(curr);
              } else {
                runs.push(currentRun);
                currentRun = [curr];
              }
            }
            if (currentRun.length) runs.push(currentRun);

            const otherSegments = cluster.filter(seg => seg.shapeId !== baseShapeId);
            runs.forEach(runSegments => {
              const matchingByShape = new Map();
              const baseMatchInfo = new Map();
              runSegments.forEach(seg => {
                baseMatchInfo.set(seg.index, {
                  segment: seg,
                  matchShapes: new Set(),
                  matchSegments: new Map()
                });
              });

              otherSegments.forEach(seg => {
                for (const baseSeg of runSegments) {
                  if (angleDifference(baseSeg.bearing, seg.bearing) <= ANGLE_TOLERANCE_DEGREES &&
                      distanceMeters(baseSeg.mid, seg.mid) <= OVERLAP_DISTANCE_TOLERANCE_METERS) {
                    if (!matchingByShape.has(seg.shapeId)) matchingByShape.set(seg.shapeId, []);
                    matchingByShape.get(seg.shapeId).push(seg);
                    const info = baseMatchInfo.get(baseSeg.index);
                    if (info) {
                      info.matchShapes.add(seg.shapeId);
                      if (!info.matchSegments.has(seg.shapeId)) {
                        info.matchSegments.set(seg.shapeId, new Set());
                      }
                      info.matchSegments.get(seg.shapeId).add(seg.index);
                    }
                    break;
                  }
                }
              });

              const matchedBaseSegments = runSegments.filter(seg => {
                const info = baseMatchInfo.get(seg.index);
                return info && info.matchShapes.size > 0;
              });
              if (!matchedBaseSegments.length) return;

              matchingByShape.set(baseShapeId, matchedBaseSegments.slice());
              if (matchingByShape.size <= 1) return;

              const densifiedPath = densifiedByShape.get(baseShapeId);
              if (!densifiedPath || densifiedPath.length < 2) return;

              matchingByShape.forEach((segmentsForShape, shapeId) => {
                const flags = segmentFlagsByShape.get(shapeId);
                if (!flags) return;
                segmentsForShape.sort((a, b) => a.index - b.index);
                segmentsForShape.forEach(seg => {
                  if (seg.index >= 0 && seg.index < flags.length) {
                    flags[seg.index] = true;
                  }
                });
              });

              const sortedMatched = matchedBaseSegments.slice().sort((a, b) => a.index - b.index);
              const matchedRuns = [];
              let currentMatched = [];
              sortedMatched.forEach(seg => {
                if (!currentMatched.length) {
                  currentMatched.push(seg);
                  return;
                }
                const prev = currentMatched[currentMatched.length - 1];
                if (seg.index === prev.index + 1) {
                  currentMatched.push(seg);
                } else {
                  matchedRuns.push(currentMatched);
                  currentMatched = [seg];
                }
              });
              if (currentMatched.length) matchedRuns.push(currentMatched);

              matchedRuns.forEach(matchedRunSegments => {
                const startIndex = matchedRunSegments[0].index;
                const endIndex = matchedRunSegments[matchedRunSegments.length - 1].index + 1;
                const path = densifiedPath.slice(startIndex, Math.min(endIndex + 1, densifiedPath.length));
                if (path.length < 2) return;

                const relevantShapeIds = new Set([baseShapeId]);
                matchedRunSegments.forEach(seg => {
                  const info = baseMatchInfo.get(seg.index);
                  if (!info) return;
                  info.matchShapes.forEach(shapeId => relevantShapeIds.add(shapeId));
                });

                const colorInfos = [];
                const seenRoutes = new Set();
                relevantShapeIds.forEach(shapeId => {
                  const routeId = shapeToRoute.get(shapeId);
                  if (routeId == null) return;
                  if (seenRoutes.has(routeId)) return;
                  seenRoutes.add(routeId);
                  colorInfos.push({ routeId, color: colorByRoute.get(routeId) || '#000000' });
                });

                if (colorInfos.length <= 1) return;

                const shapeSegmentIndices = new Map();
                shapeSegmentIndices.set(baseShapeId, new Set(matchedRunSegments.map(seg => seg.index)));
                matchedRunSegments.forEach(seg => {
                  const info = baseMatchInfo.get(seg.index);
                  if (!info || !info.matchSegments) return;
                  info.matchSegments.forEach((indexSet, shapeId) => {
                    if (!relevantShapeIds.has(shapeId)) return;
                    if (!shapeSegmentIndices.has(shapeId)) shapeSegmentIndices.set(shapeId, new Set());
                    indexSet.forEach(idx => {
                      if (Number.isFinite(idx)) {
                        shapeSegmentIndices.get(shapeId).add(Math.floor(idx));
                      }
                    });
                  });
                });

                const shapeInfos = [];
                shapeSegmentIndices.forEach((indexSet, shapeId) => {
                  if (!relevantShapeIds.has(shapeId)) return;
                  const routeId = shapeToRoute.get(shapeId);
                  if (routeId == null) return;
                  const densifiedPoints = densifiedByShape.get(shapeId);
                  if (!densifiedPoints || densifiedPoints.length < 2) return;

                  const sortedIndices = Array.from(indexSet).filter(idx => Number.isFinite(idx)).sort((a, b) => a - b);
                  if (!sortedIndices.length) return;

                  const maxSegmentIndex = Math.max(0, densifiedPoints.length - 2);
                  const firstSegmentIndex = Math.max(0, Math.min(maxSegmentIndex, sortedIndices[0]));
                  const lastSegmentIndex = Math.max(0, Math.min(maxSegmentIndex, sortedIndices[sortedIndices.length - 1]));
                  const startPointIndex = Math.max(0, Math.min(densifiedPoints.length - 1, firstSegmentIndex));
                  const endPointIndex = Math.max(0, Math.min(densifiedPoints.length - 1, lastSegmentIndex + 1));

                  let pathPoints = [];
                  sortedIndices.forEach(segIndex => {
                    const clampedIndex = Math.max(0, Math.min(maxSegmentIndex, segIndex));
                    const start = densifiedPoints[clampedIndex];
                    const end = densifiedPoints[clampedIndex + 1];
                    if (!start || !end) return;
                    if (!pathPoints.length) {
                      pathPoints.push([start[0], start[1]]);
                    } else {
                      const last = pathPoints[pathPoints.length - 1];
                      if (Math.abs(last[0] - start[0]) > 1e-12 || Math.abs(last[1] - start[1]) > 1e-12) {
                        pathPoints.push([start[0], start[1]]);
                      }
                    }
                    pathPoints.push([end[0], end[1]]);
                  });

                  if (pathPoints.length < 2) {
                    const fallback = densifiedPoints.slice(startPointIndex, endPointIndex + 1);
                    if (fallback.length < 2) return;
                    pathPoints = fallback.map(pt => [pt[0], pt[1]]);
                  }

                  const forwardScore = distanceMeters(pathPoints[0], path[0]) + distanceMeters(pathPoints[pathPoints.length - 1], path[path.length - 1]);
                  const reverseScore = distanceMeters(pathPoints[pathPoints.length - 1], path[0]) + distanceMeters(pathPoints[0], path[path.length - 1]);
                  const orientedPath = Number.isFinite(forwardScore) && Number.isFinite(reverseScore) && reverseScore + 1e-6 < forwardScore
                    ? pathPoints.slice().reverse()
                    : pathPoints.slice();

                  const cumulativeDistances = computeCumulativeDistances(orientedPath);
                  const totalLength = cumulativeDistances.length ? cumulativeDistances[cumulativeDistances.length - 1] : 0;

                  shapeInfos.push({
                    shapeId,
                    routeId,
                    startPointIndex,
                    endPointIndex,
                    pathPoints: orientedPath,
                    cumulativeDistances,
                    totalLength
                  });
                });

                if (!shapeInfos.length) {
                  overlaps.push({ path, colorInfos });
                  return;
                }

                const baseInfo = shapeInfos.find(info => info.shapeId === baseShapeId);
                const referencePath = baseInfo ? baseInfo.pathPoints : path.map(pt => [pt[0], pt[1]]);
                const referenceDistances = baseInfo ? baseInfo.cumulativeDistances : computeCumulativeDistances(referencePath);
                const averagedPath = buildAveragedPath(referencePath, referenceDistances, shapeInfos);
                const sanitizedPath = Array.isArray(averagedPath) && averagedPath.length >= 2
                  ? averagedPath.map(pt => [pt[0], pt[1]])
                  : referencePath.map(pt => [pt[0], pt[1]]);

                shapeInfos.forEach(info => {
                  let replacements = boundaryReplacementsByShape.get(info.shapeId);
                  if (!replacements) {
                    replacements = new Map();
                    boundaryReplacementsByShape.set(info.shapeId, replacements);
                  }
                  mergeReplacementPoint(replacements, info.startPointIndex, sanitizedPath[0]);
                  mergeReplacementPoint(replacements, info.endPointIndex, sanitizedPath[sanitizedPath.length - 1]);
                });

                overlaps.push({ path: sanitizedPath, colorInfos });
              });
            });
          });
        });

        const nonOverlap = [];
        shapeMetadata.forEach(({ shapeId, routeId }) => {
          const pathPoints = densifiedByShape.get(shapeId);
          if (!pathPoints || pathPoints.length < 2) return;
          const flags = segmentFlagsByShape.get(shapeId) || [];
          const replacements = boundaryReplacementsByShape.get(shapeId) || null;
          let currentPath = [];
          for (let i = 0; i < pathPoints.length - 1; i++) {
            if (!flags[i]) {
              if (currentPath.length === 0) {
                currentPath.push(getAdjustedPointForIndex(replacements, i, pathPoints[i]));
              }
              currentPath.push(getAdjustedPointForIndex(replacements, i + 1, pathPoints[i + 1]));
            } else {
              if (currentPath.length >= 2) {
                nonOverlap.push({ routeId, color: colorByRoute.get(routeId), path: currentPath });
              }
              currentPath = [];
            }
          }
          if (currentPath.length >= 2) {
            nonOverlap.push({ routeId, color: colorByRoute.get(routeId), path: currentPath });
          }
        });

        return { overlaps, nonOverlap };
      }

      function drawStripedPolyline(points, colorInfos, weight = 6, config = null, precomputedColors = null) {
        if (!Array.isArray(points) || points.length < 2) return;

        const normalizedColors = Array.isArray(precomputedColors) ? precomputedColors : normalizeColorInfos(colorInfos);
        if (!normalizedColors.length) return;

        const totalColors = normalizedColors.length;
        const baseOptions = {
          weight,
          opacity: 1,
          lineCap: 'butt',
          lineJoin: 'miter',
          smoothFactor: 0
        };

        if (totalColors === 1) {
          const single = normalizedColors[0];
          const layer = L.polyline(points, Object.assign({}, baseOptions, {
            color: single.color || '#000000'
          })).addTo(map);
          routeLayers.push(layer);
          if (config) {
            config.colorCount = totalColors;
            config.nextColorIndex = 0;
            const existingLength = Number.isFinite(config.segmentLength) && config.segmentLength > 0
              ? config.segmentLength
              : TARGET_STRIPE_LENGTH_METERS;
            config.segmentLength = Math.max(MIN_STRIPE_LENGTH_METERS, Math.min(MAX_STRIPE_LENGTH_METERS, existingLength));
            config.previousSegmentLength = config.segmentLength;
            config.partialMeters = 0;
          }
          return;
        }

        const totalLength = computePolylineLength(points);
        if (!Number.isFinite(totalLength) || totalLength <= 0) {
          normalizedColors.forEach(info => {
            const layer = L.polyline(points, Object.assign({}, baseOptions, {
              color: info.color || '#000000'
            })).addTo(map);
            routeLayers.push(layer);
          });
          if (config) {
            config.colorCount = totalColors;
            config.nextColorIndex = 0;
            config.segmentLength = Math.max(MIN_STRIPE_LENGTH_METERS, TARGET_STRIPE_LENGTH_METERS);
            config.previousSegmentLength = config.segmentLength;
            config.partialMeters = 0;
          }
          return;
        }

        let stripeLengthHint = config && Number.isFinite(config.segmentLength) && config.segmentLength > 0
          ? config.segmentLength
          : computeAdaptiveStripeBaseLengthMeters();

        if (!Number.isFinite(stripeLengthHint) || stripeLengthHint <= 0) {
          stripeLengthHint = TARGET_STRIPE_LENGTH_METERS;
        }

        stripeLengthHint = Math.max(
          MIN_STRIPE_LENGTH_METERS,
          Math.min(MAX_STRIPE_LENGTH_METERS, stripeLengthHint)
        );

        let previousStripeLength = stripeLengthHint;
        if (config && Number.isFinite(config.previousSegmentLength) && config.previousSegmentLength > 0) {
          previousStripeLength = config.previousSegmentLength;
        }

        let startColorIndex = 0;
        if (config && Number.isFinite(config.nextColorIndex)) {
          const rawIndex = Math.floor(config.nextColorIndex);
          startColorIndex = ((rawIndex % totalColors) + totalColors) % totalColors;
        }

        let partialMeters = 0;
        if (config && Number.isFinite(config.partialMeters) && config.partialMeters > 0) {
          const clampedPrevious = Math.max(1e-6, previousStripeLength);
          const ratio = Math.min(1, Math.max(0, config.partialMeters / clampedPrevious));
          partialMeters = ratio * stripeLengthHint;
        }

        if (config && config.colorCount !== totalColors) {
          startColorIndex = 0;
          partialMeters = 0;
          previousStripeLength = stripeLengthHint;
        }

        const { segments, endColorIndex, endOffset } = createStripeSegments(
          points,
          stripeLengthHint,
          totalColors,
          startColorIndex,
          partialMeters
        );

        if (!segments.length) {
          normalizedColors.forEach(info => {
            const layer = L.polyline(points, Object.assign({}, baseOptions, {
              color: info.color || '#000000'
            })).addTo(map);
            routeLayers.push(layer);
          });
          if (config) {
            config.colorCount = totalColors;
            config.segmentLength = stripeLengthHint;
            config.previousSegmentLength = stripeLengthHint;
            config.nextColorIndex = startColorIndex;
            config.partialMeters = partialMeters;
          }
          return;
        }

        segments.forEach(segment => {
          if (!segment || !Array.isArray(segment.points) || segment.points.length < 2) return;
          const info = normalizedColors[segment.colorIndex % totalColors];
          const layer = L.polyline(segment.points, Object.assign({}, baseOptions, {
            color: info.color || '#000000'
          })).addTo(map);
          routeLayers.push(layer);
        });

        if (config) {
          config.colorCount = totalColors;
          config.segmentLength = stripeLengthHint;
          config.nextColorIndex = endColorIndex;
          const sanitizedOffset = Number.isFinite(endOffset) ? Math.max(0, Math.min(stripeLengthHint, endOffset)) : 0;
          config.partialMeters = sanitizedOffset;
          config.previousSegmentLength = stripeLengthHint;
        }
      }

      function renderRouteVisualization(visualization) {
        routeLayers.forEach(layer => map.removeLayer(layer));
        routeLayers = [];

        if (!visualization) {
          stopMarkers.forEach(marker => marker.bringToFront());
          return;
        }

        const { overlaps, nonOverlap } = visualization;

        if (Array.isArray(nonOverlap)) {
          nonOverlap.forEach(segment => {
            if (!segment || !Array.isArray(segment.path) || segment.path.length < 2) return;
            const layer = L.polyline(segment.path, {
              color: segment.color || '#000000',
              weight: 6,
              opacity: 1,
              lineCap: 'butt',
              lineJoin: 'miter',
              smoothFactor: 0
            }).addTo(map);
            routeLayers.push(layer);
          });
        }

        const adaptiveBase = computeAdaptiveStripeBaseLengthMeters();
        const baseSegmentLength = Math.max(
          MIN_SEGMENT_LENGTH_METERS,
          Number.isFinite(adaptiveBase) && adaptiveBase > 0 ? adaptiveBase : TARGET_STRIPE_LENGTH_METERS
        );

        if (Array.isArray(overlaps) && overlaps.length > 0) {
          const stripeConfigs = new Map();
          overlaps.forEach(section => {
            if (!section || !Array.isArray(section.path) || section.path.length < 2) return;
            const normalized = section.normalizedColorInfos || normalizeColorInfos(section.colorInfos);
            if (!normalized.length) return;
            section.normalizedColorInfos = normalized;
            const key = colorInfoKeyFromNormalizedInfos(normalized);
            let config = stripeConfigs.get(key);
            if (!config) {
              config = {
                segmentLength: baseSegmentLength,
                previousSegmentLength: baseSegmentLength,
                nextColorIndex: 0,
                colorCount: normalized.length,
                partialMeters: 0
              };
              stripeConfigs.set(key, config);
            } else {
              config.previousSegmentLength = config.segmentLength;
              config.segmentLength = baseSegmentLength;
              if (config.colorCount !== normalized.length) {
                config.nextColorIndex = 0;
                config.partialMeters = 0;
              }
              config.colorCount = normalized.length;
            }
            drawStripedPolyline(section.path, section.colorInfos, 6, config, normalized);
          });
        }

        stopMarkers.forEach(marker => marker.bringToFront());
      }

      // Fetch route paths from GetRoutesForMapWithSchedule and center map on all routes.
      function fetchRoutePaths() {
          const currentBaseURL = baseURL;
          const routePathsApiUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetRoutesForMapWithScheduleWithEncodedLine?APIKey=8882812681`;
          fetch(routePathsApiUrl)
              .then(response => response.json())
              .then(data => {
                  if (currentBaseURL !== baseURL) return;
                  let bounds = null;
                  const displayedRoutes = new Map();
                  let visualization = null;
                  if (Array.isArray(data)) {
                      const selectedRoutesForDrawing = [];
                      data.forEach(route => {
                          setRouteVisibility(route);
                          allRoutes[route.RouteID] = Object.assign(allRoutes[route.RouteID] || {}, route);
                          const routeAllowed = canDisplayRoute(route.RouteID);
                          if (route.EncodedPolyline && routeAllowed) {
                              const decodedPolyline = polyline.decode(route.EncodedPolyline);
                              const polyBounds = L.latLngBounds(decodedPolyline);
                              bounds = bounds ? bounds.extend(polyBounds) : polyBounds;

                              const storedRoute = allRoutes[route.RouteID] || {};
                              const legendNameCandidates = [
                                  storedRoute.Description,
                                  route.Description,
                                  storedRoute.Name,
                                  route.Name,
                                  storedRoute.RouteName,
                                  route.RouteName
                              ];
                              let legendName = legendNameCandidates.find(value => typeof value === 'string' && value.trim() !== '');
                              legendName = legendName ? legendName.trim() : `Route ${route.RouteID}`;
                              const rawDescription = storedRoute.InfoText ?? route.InfoText ?? '';
                              const legendDescription = typeof rawDescription === 'string' ? rawDescription.trim() : '';
                              const numericRouteId = Number(route.RouteID);
                              const effectiveRouteId = Number.isNaN(numericRouteId) ? route.RouteID : numericRouteId;
                              const legendRouteId = Number.isNaN(numericRouteId) ? route.RouteID : numericRouteId;

                              if (isRouteSelected(route.RouteID)) {
                                  const routeColor = getRouteColor(route.RouteID);
                                  selectedRoutesForDrawing.push({
                                      routeId: effectiveRouteId,
                                      color: routeColor,
                                      points: decodedPolyline
                                  });
                                  displayedRoutes.set(route.RouteID, {
                                      routeId: legendRouteId,
                                      color: routeColor,
                                      name: legendName,
                                      description: legendDescription
                                  });
                              }
                          }
                      });

                      if (selectedRoutesForDrawing.length > 0) {
                          visualization = computeRouteOverlapGraphics(selectedRoutesForDrawing);
                      }
                  }
                  cachedRouteVisualization = visualization;
                  renderRouteVisualization(cachedRouteVisualization);
                  if (bounds) {
                      allRouteBounds = bounds;
                      if (!mapHasFitAllRoutes) {
                          if (!kioskMode && !adminKioskMode) {
                              map.fitBounds(allRouteBounds, { padding: [20, 20] });
                          }
                          mapHasFitAllRoutes = true;
                      }
                  }
                  updateRouteSelector(activeRoutes);
                  updateRouteLegend(Array.from(displayedRoutes.values()));
              })
              .catch(error => {
                  console.error("Error fetching route paths:", error);
                  cachedRouteVisualization = null;
                  renderRouteVisualization(null);
                  updateRouteLegend([]);
              });
      }

      function fetchBlockAssignments() {
          const currentBaseURL = baseURL;
          const d = new Date();
          const ds = `${d.getMonth() + 1}/${d.getDate()}/${d.getFullYear()}`;
          const schedUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetScheduleVehicleCalendarByDateAndRoute?dateString=${encodeURIComponent(ds)}`;
          fetch(schedUrl)
              .then(response => response.json())
              .then(sched => {
                  if (currentBaseURL !== baseURL) return;
                  const ids = (sched || []).map(s => s.ScheduleVehicleCalendarID).join(',');
                  if (!ids) {
                      busBlocks = {};
                      return;
                  }
                  const blockUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetDispatchBlockGroupData?scheduleVehicleCalendarIdsString=${ids}`;
                  return fetch(blockUrl).then(r => r.json());
              })
              .then(data => {
                  if (currentBaseURL !== baseURL || !data) return;
                  const groups = data?.BlockGroups || [];
                  const alias = {
                      "[01]": "[01]/[04]",
                      "[03]": "[05]/[03]",
                      "[04]": "[01]/[04]",
                      "[05]": "[05]/[03]",
                      "[06]": "[22]/[06]",
                      "[10]": "[20]/[10]",
                      "[15]": "[26]/[15]",
                      "[16] AM": "[21]/[16] AM",
                      "[17]": "[23]/[17]",
                      "[18] AM": "[24]/[18] AM",
                      "[20] AM": "[20]/[10]",
                      "[21] AM": "[21]/[16] AM",
                      "[22] AM": "[22]/[06]",
                      "[23]": "[23]/[17]",
                      "[24] AM": "[24]/[18] AM",
                      "[26] AM": "[26]/[15]"
                  };
                  let mapping = {};
                  groups.forEach(g => {
                      const block = (g.BlockGroupId || '').trim();
                      const vehicleId = g.Blocks?.[0]?.Trips?.[0]?.VehicleID ?? g.VehicleId;
                      if (block && block.includes('[') && vehicleId != null) {
                          mapping[vehicleId] = alias[block] || block;
                      }
                  });
                  busBlocks = mapping;
              })
              .catch(error => console.error("Error fetching block assignments:", error));
      }

      function fetchBusLocations() {
          const currentBaseURL = baseURL;
          const apiUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetMapVehiclePoints?APIKey=8882812681&returnVehiclesNotAssignedToRoute=true`;
          return fetch(apiUrl)
              .then(response => {
                  if (!response.ok) throw new Error("Network response was not ok: " + response.statusText);
                  return response.json();
              })
              .then(data => {
                  if (currentBaseURL !== baseURL) return;
                  if (Array.isArray(data)) {
                      let currentBusData = {};
                      let activeRoutesSet = new Set();
                      let vehicles = [];

                      // First pass: gather vehicles and determine active routes.
                      data.forEach(vehicle => {
                          const vehicleID = vehicle.VehicleID;
                          const newPosition = [vehicle.Latitude, vehicle.Longitude];
                          const isMoving = vehicle.GroundSpeed > 0;
                          const busName = vehicle.Name;
                          let routeID = vehicle.RouteID;
                          if (!routeID && adminMode) {
                              routeID = 0;
                          } else if (!routeID) {
                              return;
                          }
                          const numericRouteId = Number(routeID);
                          const effectiveRouteId = Number.isNaN(numericRouteId) ? routeID : numericRouteId;
                          if (!canDisplayRoute(effectiveRouteId)) return;
                          if (!adminMode && !routeColors.hasOwnProperty(effectiveRouteId)) return;
                          activeRoutesSet.add(effectiveRouteId);
                          vehicles.push({
                              vehicleID,
                              newPosition,
                              isMoving,
                              busName,
                              routeID: effectiveRouteId,
                              heading: vehicle.Heading,
                              groundSpeed: vehicle.GroundSpeed
                          });
                      });

                      // Update global activeRoutes and rebuild selector before rendering.
                      activeRoutes = activeRoutesSet;
                      updateRouteSelector(activeRoutesSet);

                      // Second pass: render only selected routes.
                      vehicles.forEach(v => {
                          const { vehicleID, newPosition, isMoving, busName, routeID, heading, groundSpeed } = v;
                          if (!isRouteSelected(routeID)) return;
                          currentBusData[vehicleID] = true;
                          const svgIcon = `
                              <svg width="40" height="80" viewBox="0 0 40 80" xmlns="http://www.w3.org/2000/svg">
                                <g>
                                  <circle cx="20" cy="20" r="15" fill="${getRouteColor(routeID)}" stroke="white" stroke-width="3" />
                                  ${isMoving ? `
                                    <line x1="20" y1="10" x2="20" y2="22" stroke="${getContrastColor(getRouteColor(routeID))}" stroke-width="4" stroke-linecap="round" style="transform: rotate(${heading + 180}deg); transform-origin: 20px 20px" />
                                    <polygon points="15,22 25,22 20,30" fill="${getContrastColor(getRouteColor(routeID))}" style="transform: rotate(${heading + 180}deg); transform-origin: 20px 20px" />
                                  ` : `
                                    <rect x="14" y="14" width="12" height="12" fill="${getContrastColor(getRouteColor(routeID))}" />
                                  `}
                                </g>
                              </svg>`;
                          const busIcon = L.divIcon({
                              html: svgIcon,
                              className: '',
                              iconSize: [40, 40],
                              iconAnchor: [20, 20]
                          });
                          if (markers[vehicleID]) {
                              animateMarkerTo(markers[vehicleID], newPosition);
                              markers[vehicleID].setIcon(busIcon);
                              markers[vehicleID].routeID = routeID;
                          } else {
                              markers[vehicleID] = L.marker(newPosition, { icon: busIcon });
                              markers[vehicleID].routeID = routeID;
                              markers[vehicleID].addTo(map);
                          }
                          if (adminMode && showSpeed && !kioskMode) {
                              const speedBubble = `
                                  <svg width="60" height="20" viewBox="0 0 60 20" xmlns="http://www.w3.org/2000/svg">
                                      <g>
                                          <rect x="0" y="0" width="60" height="20" rx="10" ry="10" fill="${getRouteColor(routeID)}" stroke="white" stroke-width="3" />
                                          <text x="30" y="15" font-size="12" font-weight="bold" text-anchor="middle" fill="${getContrastColor(getRouteColor(routeID))}" font-family="FGDC">${Math.round(groundSpeed)} MPH</text>
                                      </g>
                                  </svg>`;
                              const speedIcon = L.divIcon({
                                  html: speedBubble,
                                  className: '',
                                  iconSize: [60, 20],
                                  iconAnchor: [30, -15]
                              });
                              if (nameBubbles[vehicleID] && nameBubbles[vehicleID].speedMarker) {
                                  animateMarkerTo(nameBubbles[vehicleID].speedMarker, newPosition);
                                  nameBubbles[vehicleID].speedMarker.setIcon(speedIcon);
                              } else {
                                  nameBubbles[vehicleID] = nameBubbles[vehicleID] || {};
                                  nameBubbles[vehicleID].speedMarker = L.marker(newPosition, { icon: speedIcon, interactive: false }).addTo(map);
                              }
                          } else {
                              if (nameBubbles[vehicleID] && nameBubbles[vehicleID].speedMarker) {
                                  map.removeLayer(nameBubbles[vehicleID].speedMarker);
                                  delete nameBubbles[vehicleID].speedMarker;
                              }
                          }
                          if (adminMode && !kioskMode) {
                              const bubbleWidth = Math.max(40, busName.length * 10);
                              const nameBubble = `
                                  <svg width="${bubbleWidth}" height="30" viewBox="0 0 ${bubbleWidth} 30" xmlns="http://www.w3.org/2000/svg">
                                      <g>
                                          <rect x="0" y="5" width="${bubbleWidth}" height="20" rx="10" ry="10" fill="${getRouteColor(routeID)}" stroke="white" stroke-width="3" />
                                          <text x="${bubbleWidth / 2}" y="20" font-size="14" font-weight="bold" text-anchor="middle" fill="${getContrastColor(getRouteColor(routeID))}" font-family="FGDC">${busName}</text>
                                      </g>
                                  </svg>`;
                              const nameIcon = L.divIcon({
                                  html: nameBubble,
                                  className: '',
                                  iconSize: [bubbleWidth, 30],
                                  iconAnchor: [bubbleWidth / 2, 40]
                              });
                              if (nameBubbles[vehicleID] && nameBubbles[vehicleID].nameMarker) {
                                  animateMarkerTo(nameBubbles[vehicleID].nameMarker, newPosition);
                                  nameBubbles[vehicleID].nameMarker.setIcon(nameIcon);
                              } else {
                                  nameBubbles[vehicleID] = nameBubbles[vehicleID] || {};
                                  nameBubbles[vehicleID].nameMarker = L.marker(newPosition, { icon: nameIcon, interactive: false }).addTo(map);
                              }

                              const blockName = busBlocks[vehicleID];
                              if (showBlockNumbers && blockName && blockName.includes('[')) {
                                  const canvas = document.createElement('canvas');
                                  const ctx = canvas.getContext('2d');
                                  ctx.font = 'bold 14px FGDC';
                                  const textWidth = ctx.measureText(blockName).width;
                                  const blockWidth = Math.max(40, textWidth + 20);
                                  const blockBubble = `
                                      <svg width="${blockWidth}" height="30" viewBox="0 0 ${blockWidth} 30" xmlns="http://www.w3.org/2000/svg">
                                          <g>
                                              <rect x="0" y="5" width="${blockWidth}" height="20" rx="10" ry="10" fill="${getRouteColor(routeID)}" stroke="white" stroke-width="3" />
                                              <text x="${blockWidth / 2}" y="20" font-size="14" font-weight="bold" text-anchor="middle" fill="${getContrastColor(getRouteColor(routeID))}" font-family="FGDC">${blockName}</text>
                                          </g>
                                      </svg>`;
                                  const blockIcon = L.divIcon({
                                      html: blockBubble,
                                      className: '',
                                      iconSize: [blockWidth, 30],
                                      // Position the block number bubble so it touches but doesn't overlap the bus icon
                                      iconAnchor: [blockWidth / 2, -13]
                                  });
                                  if (nameBubbles[vehicleID] && nameBubbles[vehicleID].blockMarker) {
                                      animateMarkerTo(nameBubbles[vehicleID].blockMarker, newPosition);
                                      nameBubbles[vehicleID].blockMarker.setIcon(blockIcon);
                                  } else {
                                      nameBubbles[vehicleID] = nameBubbles[vehicleID] || {};
                                      nameBubbles[vehicleID].blockMarker = L.marker(newPosition, { icon: blockIcon, interactive: false }).addTo(map);
                                  }
                              } else {
                                  if (nameBubbles[vehicleID] && nameBubbles[vehicleID].blockMarker) {
                                      map.removeLayer(nameBubbles[vehicleID].blockMarker);
                                      delete nameBubbles[vehicleID].blockMarker;
                                  }
                              }
                          } else {
                              if (nameBubbles[vehicleID] && nameBubbles[vehicleID].nameMarker) {
                                  map.removeLayer(nameBubbles[vehicleID].nameMarker);
                                  delete nameBubbles[vehicleID].nameMarker;
                              }
                              if (nameBubbles[vehicleID] && nameBubbles[vehicleID].blockMarker) {
                                  map.removeLayer(nameBubbles[vehicleID].blockMarker);
                                  delete nameBubbles[vehicleID].blockMarker;
                              }
                          }
                      });

                      Object.keys(markers).forEach(vehicleID => {
                          if (!currentBusData[vehicleID] || !isRouteSelected(markers[vehicleID].routeID)) {
                              map.removeLayer(markers[vehicleID]);
                              delete markers[vehicleID];
                              if (nameBubbles[vehicleID]) {
                                  if (nameBubbles[vehicleID].speedMarker) map.removeLayer(nameBubbles[vehicleID].speedMarker);
                                  if (nameBubbles[vehicleID].nameMarker) map.removeLayer(nameBubbles[vehicleID].nameMarker);
                                  if (nameBubbles[vehicleID].blockMarker) map.removeLayer(nameBubbles[vehicleID].blockMarker);
                                  delete nameBubbles[vehicleID];
                              }
                          }
                      });
                      previousBusData = currentBusData;
                  }
              })
              .catch(error => console.error("Error fetching bus locations:", error));
      }

      function getContrastColor(hexColor) {
          hexColor = hexColor.replace('#', '');
          const r = parseInt(hexColor.substring(0, 2), 16);
          const g = parseInt(hexColor.substring(2, 4), 16);
          const b = parseInt(hexColor.substring(4, 6), 16);
          const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
          return luminance > 0.565 ? 'black' : 'white';
      }

      function animateMarkerTo(marker, newPosition) {
        const startPos = marker.getLatLng();
        const endPos = L.latLng(newPosition);
        const duration = 1000;
        const startTime = performance.now();
        function animate(time) {
          const elapsed = time - startTime;
          const t = Math.min(elapsed / duration, 1);
          const currentPos = L.latLng(
            startPos.lat + t * (endPos.lat - startPos.lat),
            startPos.lng + t * (endPos.lng - startPos.lng)
          );
          marker.setLatLng(currentPos);
          if (t < 1) requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);
      }

      document.addEventListener("DOMContentLoaded", () => {
        loadAgencies().then(() => {
          initMap();
          showCookieBanner();
        });
      });
    </script>
  </head>
  <body>
    <div id="map"></div>
    <div id="routeLegend" aria-live="polite"></div>
    <div id="routeSelector"></div>
    <div id="routeSelectorTab" onclick="togglePanel()">&#9664;</div>
    <div class="credit">proof of concept created by pat cox • phc6j@virginia.edu</div>
    <div id="cookieBanner" class="cookie-banner" style="display:none;">
      This site stores your selected transit agency on your device to remember your preference.
      <button id="cookieAccept">OK</button>
    </div>
  </body>
</html>
