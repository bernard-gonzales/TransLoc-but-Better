<!DOCTYPE html>
<html>
  <head>
    <title>Live Map - Headway Guard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@mapbox/polyline@1.1.1"></script>
    <style>
      .custom-popup {
        position: absolute;
        background: #232D4B;
        border: 4px solid white;
        border-radius: 15px;
        padding: 10px;
        pointer-events: auto;
        transform: translate(-50%, -100%);
        white-space: nowrap;
        z-index: 1000;
        color: white;
        text-transform: uppercase;
      }
      .custom-popup-arrow {
        position: absolute;
        left: 50%;
        bottom: -10px;
        width: 0;
        height: 0;
        border-left: 10px solid transparent;
        border-right: 10px solid transparent;
        border-top: 10px solid white;
        transform: translateX(-50%);
      }
      .custom-popup-close {
        position: absolute;
        bottom: 5px;
        right: 5px;
        cursor: pointer;
        background: #f00;
        color: #fff;
        border: none;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        line-height: 20px;
        text-align: center;
        font-size: 14px;
      }
      .route-pill {
        display: inline-block;
        padding: 5px 10px;
        border-radius: 20px;
        color: white;
        font-weight: bold;
        margin-top: 10px;
        text-align: center;
        border: 2px solid #FFFFFF;
      }
      @font-face {
        font-family: 'FGDC';
        src: url('FGDC.ttf') format('truetype');
      }
      body, .custom-popup {
        font-family: 'FGDC', sans-serif;
        font-size: 14px;
      }
      #map {
        height: 100%;
        width: 100%;
      }
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
      }
      /* Route Selector styling */
      #routeSelector {
        width: 300px;
        position: fixed;
        top: 10px;
        right: 10px;
        z-index: 1100;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px;
        border-radius: 5px;
        max-height: 90vh;
        overflow-y: auto;
        transition: transform 0.3s ease;
		font-size: 21px;
      }
      #routeSelector.hidden {
        transform: translateX(320px);
      }
      #routeSelector h3 {
        margin-top: 0;
      }
      /* Updated button styles for route selector (including speed toggle) */
      #routeSelector button {
        margin: 5px 2px;
        padding: 5px 10px;
        font-size: 24px;
        font-family: 'FGDC', sans-serif;
        background-color: #E57200;
        color: black;
        border: none;
        border-radius: 20px;
        cursor: pointer;
      }
      #routeSelector label {
        display: block;
        margin-bottom: 5px;
        cursor: pointer;
      }
      #routeSelector .color-box {
        display: inline-block;
        width: 12px;
        height: 12px;
        margin-right: 5px;
        vertical-align: middle;
      }
      /* Tab styling */
      #routeSelectorTab {
        position: fixed;
        top: 50%;
        right: 0;
        width: 30px;
        height: 60px;
        background: #ccc;
        border-top-left-radius: 10px;
        border-bottom-left-radius: 10px;
        cursor: pointer;
        display: block;
        transform: translateY(-50%);
        z-index: 1150;
        text-align: center;
        line-height: 60px;
        font-size: 20px;
        user-select: none;
        transition: right 0.3s ease;
      }
      #routeLegend {
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 1100;
        background: rgba(255, 255, 255, 0.9);
        padding: 12px 16px;
        border-radius: 8px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        max-width: 320px;
        display: none;
        font-size: 20px;
      }
      #routeLegend .legend-title {
        font-weight: bold;
        margin-bottom: 8px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      #routeLegend .legend-item {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 8px;
      }
      #routeLegend .legend-item:last-child {
        margin-bottom: 0;
      }
      #routeLegend .legend-color {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 2px solid #FFFFFF;
        box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.1);
        flex-shrink: 0;
      }
      #routeLegend .legend-text {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      #routeLegend .legend-name {
        font-weight: bold;
      }
      #routeLegend .legend-description {
        font-size: 16px;
        color: #1b1b1b;
      }
      @media (max-width: 600px) {
        #routeSelector { width: 80%; right: 10%; font-size: 18px; }
        #routeSelector.hidden { transform: translateX(calc(100% + 20px)); }
        #routeSelector button { font-size: 20px; }
        #routeSelector label { font-size: 18px; }
        #routeSelectorTab { width: 40px; height: 80px; font-size: 28px; }
      }
      .credit{position:fixed;bottom:8px;right:8px;font-size:12px;color:var(--muted,#9fb0c9);}
      .cookie-banner{position:fixed;bottom:0;left:0;right:0;background:rgba(0,0,0,0.8);color:white;padding:10px;text-align:center;font-size:14px;z-index:1200;}
      .cookie-banner button{margin-left:10px;}
    </style>
    <script>
      // Manually set these variables.
      // adminMode: true for admin view (with speed/block bubbles and unit numbers).
      //            Can be disabled via URL param `adminMode=false`.
      //            In public mode (adminMode=false) the route selector is still shown
      //            but only for routes that are public-facing.
      // kioskMode: true to hide the route selector/tab and suppress vehicle overlays for a public display.
      // adminKioskMode: true to hide the route selector/tab while retaining admin overlays (previous kiosk behavior).
      // showSpeed/showBlockNumbers: only one may be true at a time.
      let adminMode = true; // shows unit numbers and speed/block bubbles
      let kioskMode = false;
      let adminKioskMode = false;
      let showSpeed = false; // default to showing block numbers
      let showBlockNumbers = true;

      const params = new URLSearchParams(window.location.search);
      const kioskParam = params.get('kioskMode');
      if (kioskParam !== null) {
        kioskMode = kioskParam.toLowerCase() === 'true';
      }
      const adminKioskParam = params.get('adminKioskMode');
      if (adminKioskParam !== null) {
        adminKioskMode = adminKioskParam.toLowerCase() === 'true';
      }
      const adminParam = params.get('adminMode');
      if (adminParam !== null) {
        adminMode = adminParam.toLowerCase() === 'true';
      }
      
      const outOfServiceRouteColor = '#000000';
      
      let map;
      let markers = {};
      let routeColors = {};
      let routeLayers = [];
      let stopMarkers = [];
      let nameBubbles = {};
      let busBlocks = {};
      let previousBusData = {};
      let cachedEtas = {};
      let customPopups = [];
      let allRouteBounds = null;
      let mapHasFitAllRoutes = false;
      let refreshIntervals = [];
      let cachedRouteVisualization = null;

      let agencies = [];
      let baseURL = '';

      // ===== Stripe Engine (Leaflet) =====

      // Earth constants for Web Mercator scale
      const R_EARTH_M = 6378137;
      function metersPerPixelAtLat(map, lat) {
        const zoom = map.getZoom();
        // 2Ï€R * cos(lat) / (256 * 2^zoom)
        return (2 * Math.PI * R_EARTH_M * Math.cos(lat * Math.PI/180)) / (256 * Math.pow(2, zoom));
      }

      // Simple stable hash for a string -> 32-bit int
      function hash32(s) {
        let h = 2166136261 >>> 0;
        for (let i = 0; i < s.length; i++) {
          h ^= s.charCodeAt(i);
          h = Math.imul(h, 16777619);
        }
        return h >>> 0;
      }

      // Haversine distance (meters)
      function dist(a, b) {
        const toRad = x => x * Math.PI/180;
        const dLat = toRad(b.lat - a.lat);
        const dLng = toRad(b.lng - a.lng);
        const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
        const sinDLat = Math.sin(dLat/2), sinDLng = Math.sin(dLng/2);
        const x = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLng * sinDLng;
        return 2 * R_EARTH_M * Math.asin(Math.min(1, Math.sqrt(x)));
      }

      // Linear interpolate along a segment by fraction t in [0,1]
      function lerpLatLng(a, b, t) {
        return L.latLng(a.lat + (b.lat - a.lat) * t, a.lng + (b.lng - a.lng) * t);
      }

      // Densify polyline to <= step meters between vertices
      function densify(latlngs, stepMeters = 12) {
        if (latlngs.length < 2) return latlngs.slice();
        const out = [latlngs[0]];
        for (let i = 0; i < latlngs.length - 1; i++) {
          const A = latlngs[i], B = latlngs[i + 1];
          const d = dist(A, B);
          if (d <= stepMeters) {
            out.push(B);
            continue;
          }
          const n = Math.ceil(d / stepMeters);
          for (let k = 1; k < n; k++) {
            out.push(lerpLatLng(A, B, k / n));
          }
          out.push(B);
        }
        return out;
      }

      // Cumulative distances along polyline
      function cumulativeMeters(latlngs) {
        const cum = [0];
        for (let i = 1; i < latlngs.length; i++) {
          cum.push(cum[i - 1] + dist(latlngs[i - 1], latlngs[i]));
        }
        return cum;
      }

      // Find point at distance s meters from start (assumes s within [0,total])
      function pointAtDistance(latlngs, cum, s) {
        let i = 1;
        while (i < cum.length && cum[i] < s) i++;
        if (i === cum.length) return latlngs[latlngs.length - 1];
        const prev = latlngs[i - 1], next = latlngs[i];
        const segLen = cum[i] - cum[i - 1];
        const t = segLen > 0 ? (s - cum[i - 1]) / segLen : 0;
        return lerpLatLng(prev, next, t);
      }

      // Split polyline at a list of cut distances (meters from start)
      function splitAtDistances(latlngs, cum, cuts) {
        const segments = [];
        let startD = 0;
        for (const c of cuts) {
          const seg = [];
          // walk from startD to c
          const startPt = pointAtDistance(latlngs, cum, startD);
          seg.push(startPt);
          // push intermediate vertices strictly inside (startD, c)
          for (let i = 1; i < cum.length; i++) {
            if (cum[i] > startD && cum[i] < c) seg.push(latlngs[i]);
          }
          const endPt = pointAtDistance(latlngs, cum, c);
          seg.push(endPt);
          segments.push(seg);
          startD = c;
        }
        // tail
        const tail = [];
        tail.push(pointAtDistance(latlngs, cum, startD));
        for (let i = 1; i < cum.length; i++) {
          if (cum[i] > startD) tail.push(latlngs[i]);
        }
        if (tail.length >= 2) segments.push(tail);
        return segments;
      }

      // Global cache to preserve phase across re-renders
      const StripeState = new Map(); // key -> {phaseMeters}

      // Create striped polylines for a path + ordered colors
      function createStripedLayers(map, rawLatLngs, colors, options = {}) {
        const {
          stripePx = 18,         // visual stripe length target
          densifyStepM = 12,     // vertex spacing for stable cuts
          weight = 8,
          opacity = 1.0,
          lineCap = 'butt',
          lineJoin = 'miter',
          pane = undefined,
          className = ''
        } = options;

        if (!rawLatLngs || rawLatLngs.length < 2 || !colors || colors.length === 0)
          return [];

        // Normalize direction so identical overlaps stripe identically
        const start = rawLatLngs[0], end = rawLatLngs[rawLatLngs.length - 1];
        const dirKey = start.lat < end.lat ? 1 : (start.lat > end.lat ? -1 :
                      (start.lng <= end.lng ? 1 : -1));
        const latlngs = dirKey === 1 ? rawLatLngs.slice() : rawLatLngs.slice().reverse();

        const dense = densify(latlngs, densifyStepM);
        const cum = cumulativeMeters(dense);
        const total = cum[cum.length - 1];
        if (total === 0) return [];

        // Stripe length in meters for this zoom (lock to center latitude)
        const centerLat = dense[Math.floor(dense.length / 2)].lat;
        const mPerPx = metersPerPixelAtLat(map, centerLat);
        const segLenM = Math.max(5, stripePx * mPerPx); // guardrails

        // Build a stable key and phase
        const colorsKey = colors.join(',');
        const firstKey = `${dense[0].lat.toFixed(5)},${dense[0].lng.toFixed(5)}`;
        const seriesKey = `${firstKey}|${colorsKey}`;
        let state = StripeState.get(seriesKey);
        if (!state) {
          const h = hash32(seriesKey);
          const phaseMeters = h % segLenM;
          state = { phaseMeters };
          StripeState.set(seriesKey, state);
        } else {
          // If zoom changed (segLenM changed), keep phase fraction in [0,1)
          const fraction = state.phaseMeters / segLenM;
          state.phaseMeters = (fraction - Math.floor(fraction)) * segLenM;
        }

        // Compute cut distances starting at phase
        const cuts = [];
        for (let s = state.phaseMeters; s < total; s += segLenM) cuts.push(s);
        const pieces = splitAtDistances(dense, cum, cuts);

        // Paint alternating colors
        const layers = [];
        let colorIdx = 0;
        for (const seg of pieces) {
          const layer = L.polyline(seg, {
            color: colors[colorIdx % colors.length],
            weight, opacity, lineCap, lineJoin, pane, className,
            smoothFactor: 0
          });
          layers.push(layer);
          colorIdx++;
        }

        return layers;
      }

      // Convenience: add striped group to map and auto-redraw on zoom
      function addStripedGroup(map, latlngs, colors, options) {
        const group = L.layerGroup();
        const render = () => {
          group.clearLayers();
          const layers = createStripedLayers(map, latlngs, colors, options);
          layers.forEach(l => l.addTo(group));
        };
        map.on('zoomend', render);
        group._stripeCleanup = () => {
          map.off('zoomend', render);
          delete group._stripeCleanup;
        };
        group.on('remove', () => {
          if (typeof group._stripeCleanup === 'function') {
            group._stripeCleanup();
          }
        });
        render();
        return group;
      }

      // ===== Usage example =====
      // const overlapCenterline = [... array of L.LatLng ...];
      // const colorOrder = ['#0072bc','#ffdd00','#ff7300']; // Blue, Gold, Orange for example
      // const grp = addStripedGroup(map, overlapCenterline, colorOrder, { stripePx: 18, weight: 8 });
      // grp.addTo(map);

      async function loadAgencies() {
        try {
          const response = await fetch('https://admin.ridesystems.net/api/Clients/GetClients');
          const contentType = response.headers.get('content-type') || '';
          let clients = [];
          if (contentType.includes('application/json')) {
            clients = await response.json();
          } else {
            const text = await response.text();
            const parser = new DOMParser();
            const xml = parser.parseFromString(text, 'application/xml');
            clients = Array.from(xml.getElementsByTagName('Client')).map(c => ({
              Name: c.getElementsByTagName('Name')[0]?.textContent.trim(),
              WebAddress: c.getElementsByTagName('WebAddress')[0]?.textContent.trim()
            }));
          }
          agencies = clients.map(c => {
            const name = c.Name?.trim();
            const webAddress = c.WebAddress?.trim();
            if (!name || !webAddress) return null;
            const url = webAddress.startsWith('http')
              ? webAddress.replace(/^http:\/\//i, 'https://')
              : `https://${webAddress}`;
            return { name, url };
          }).filter(Boolean);
          agencies.sort((a, b) => a.name.localeCompare(b.name));
          const uvaIndex = agencies.findIndex(a => a.name === 'University of Virginia');
          if (uvaIndex > -1) {
            const uva = agencies.splice(uvaIndex, 1)[0];
            agencies.unshift(uva);
          }
          const consent = localStorage.getItem('agencyConsent') === 'true';
          const storedAgency = consent ? localStorage.getItem('selectedAgency') : null;
          if (storedAgency && agencies.some(a => a.url === storedAgency)) {
            baseURL = storedAgency;
          } else {
            baseURL = agencies[0]?.url || '';
          }
          updateRouteSelector(activeRoutes, true);
        } catch (e) {
          console.error('Failed to load agencies', e);
        }
      }

      function positionRouteTab() {
        const panel = document.getElementById("routeSelector");
        const tab = document.getElementById("routeSelectorTab");
        if (!panel || !tab) return;
        const panelStyle = window.getComputedStyle(panel);
        const gap = parseFloat(panelStyle.right) || 0;
        const offset = panel.offsetWidth + gap;
        tab.style.right = panel.classList.contains("hidden") ? "0" : offset + "px";
      }

      window.addEventListener("load", positionRouteTab);
      window.addEventListener("resize", positionRouteTab);

      // Global storage for routes from GetRoutes.
      let allRoutes = {};
      // Global object to store user selections (for admin mode).
      let routeSelections = {};
      // Tracks routes that currently have at least one vehicle assigned.
      let activeRoutes = new Set();
      // Tracks which routes the API designates as public-facing.
      let routeVisibility = {};

      const OVERLAP_DISTANCE_TOLERANCE_METERS = 15;
      const SEGMENT_SAMPLING_DISTANCE_METERS = 12;
      const ANGLE_TOLERANCE_DEGREES = 18;
      const LAT_LNG_BUCKET_SIZE = 0.00018;
      const MIN_SEGMENT_LENGTH_METERS = 0.5;
      const CONTRIBUTION_CLUSTER_DISTANCE_METERS = 4;
      const MAX_BOUNDARY_REPLACEMENT_DISTANCE_METERS = 4.5;

      // Routes default to visible if they currently have vehicles unless the user
      // overrides the selection via the route selector.
      function isRouteSelected(routeID) {
        if (!canDisplayRoute(routeID)) return false;
        const id = Number(routeID);
        if (Number.isNaN(id)) return false;
        if (routeSelections.hasOwnProperty(id)) return routeSelections[id];
        return activeRoutes.has(id);
      }

      function setRouteVisibility(route) {
        if (!route || typeof route.RouteID === 'undefined') return;
        const id = Number(route.RouteID);
        if (Number.isNaN(id)) return;
        routeVisibility[id] = route.IsVisibleOnMap !== false;
      }

      function isRoutePublicById(routeID) {
        const id = Number(routeID);
        if (Number.isNaN(id) || id === 0) return false;
        if (Object.prototype.hasOwnProperty.call(routeVisibility, id)) {
          return routeVisibility[id];
        }
        return true;
      }

      function canDisplayRoute(routeID) {
        const id = Number(routeID);
        if (Number.isNaN(id)) return false;
        if (id === 0) {
          return adminKioskMode || (!kioskMode && adminMode);
        }
        if (adminKioskMode) return true;
        if (kioskMode) return isRoutePublicById(id);
        if (adminMode) return true;
        return isRoutePublicById(id);
      }

      // Toggle between displaying speed or block numbers.
      function toggleSpeedOrBlock() {
        if (showSpeed) {
          showSpeed = false;
          showBlockNumbers = true;
        } else {
          showSpeed = true;
          showBlockNumbers = false;
        }
        document.getElementById("toggleDisplayButton").innerHTML = showSpeed ? "Show Block Numbers" : "Show Speed";
        refreshMap();
      }

      // updateRouteSelector rebuilds the route selector panel.
      // The list (excluding Out of Service) is alphabetized and defaults to
      // checking only routes that currently have vehicles.
      function updateRouteSelector(activeRoutes, forceUpdate = false) {
        const container = document.getElementById("routeSelector");
        if (!container) return;
        // If the agency dropdown is currently focused (open), skip rebuilding
        // the selector to avoid closing the dropdown.
        const agencyDropdown = document.getElementById('agencySelect');
        if (!forceUpdate && agencyDropdown && document.activeElement === agencyDropdown) {
          return;
        }
        let html = "";
        html += "<label for='agencySelect'>Select System:</label>";
        html += "<select id='agencySelect' onchange='changeAgency(this.value)'>";
        agencies.forEach(a => {
          html += `<option value="${a.url}" ${a.url === baseURL ? 'selected' : ''}>${a.name}</option>`;
        });
        html += "</select><br/><br/>";
        if (adminMode) {
          // Add the speed/block toggle button in admin mode only.
          html += "<div style='margin-bottom:10px;'><button id='toggleDisplayButton' onclick='toggleSpeedOrBlock()'>" + (showSpeed ? "Show Block Numbers" : "Show Speed") + "</button></div>";
        }
        html += "<h3>Select Routes</h3>" +
          "<button onclick='selectAllRoutes()'>Select All</button>" +
          "<button onclick='deselectAllRoutes()'>Deselect All</button><br/><br/>";

        if (adminMode && canDisplayRoute(0)) {
          // Add Out of Service option (routeID 0) at the top for admin mode.
          let outChecked = routeSelections.hasOwnProperty(0) ? routeSelections[0] : activeRoutes.has(0);
          html += `<label>
            <input type="checkbox" id="route_0" value="0" ${outChecked ? "checked" : ""}>
            <span class="color-box" style="background:${outOfServiceRouteColor};"></span> Out of Service
          </label>`;
        }

        // Get an array of route IDs (excluding 0) from allRoutes.
        let routeIDs = Object.keys(allRoutes)
          .map(id => Number(id))
          .filter(id => !Number.isNaN(id) && id !== 0 && canDisplayRoute(id));
        // Sort alphabetically by route Description (case-insensitive).
        routeIDs.sort((a, b) => {
          let descA = allRoutes[a].Description.toUpperCase();
          let descB = allRoutes[b].Description.toUpperCase();
          if (descA < descB) return -1;
          if (descA > descB) return 1;
          return 0;
        });
        // Append sorted routes.
        routeIDs.forEach(routeID => {
          let route = allRoutes[routeID];
          let checked = routeSelections.hasOwnProperty(routeID) ? routeSelections[routeID] : activeRoutes.has(routeID);
          let displayName = route.Description;
          if (route.InfoText && route.InfoText.trim() !== "") {
            displayName += ` &ndash; ${route.InfoText.trim()}`;
          }
          html += `<label>
            <input type="checkbox" id="route_${routeID}" value="${routeID}" ${checked ? "checked" : ""}>
            <span class="color-box" style="background:${route.MapLineColor};"></span> ${displayName}
          </label>`;
        });
        container.innerHTML = html;
        // Attach event listeners to update routeSelections.
        let outChk = document.getElementById("route_0");
        if (outChk) {
          outChk.addEventListener("change", function() {
            routeSelections[0] = outChk.checked;
            refreshMap();
          });
        }
        routeIDs.forEach(routeID => {
          if (!canDisplayRoute(routeID) || Number(routeID) === 0) return;
          let chk = document.getElementById("route_" + routeID);
          if (chk) {
            chk.addEventListener("change", function() {
              routeSelections[routeID] = chk.checked;
              refreshMap();
            });
          }
        });
      }

      function selectAllRoutes() {
        if (adminMode && canDisplayRoute(0)) {
          let outChk = document.getElementById("route_0");
          if (outChk) outChk.checked = true;
          routeSelections[0] = true;
        }
        for (let routeID in allRoutes) {
          if (!canDisplayRoute(routeID) || Number(routeID) === 0) continue;
          let chk = document.getElementById("route_" + routeID);
          if (chk) chk.checked = true;
          routeSelections[routeID] = true;
        }
        refreshMap();
      }

      function deselectAllRoutes() {
        if (adminMode && canDisplayRoute(0)) {
          let outChk = document.getElementById("route_0");
          if (outChk) outChk.checked = false;
          routeSelections[0] = false;
        }
        for (let routeID in allRoutes) {
          if (!canDisplayRoute(routeID) || Number(routeID) === 0) continue;
          let chk = document.getElementById("route_" + routeID);
          if (chk) chk.checked = false;
          routeSelections[routeID] = false;
        }
        refreshMap();
      }

      // togglePanel toggles the route selector panel's visibility.
      function togglePanel() {
        let panel = document.getElementById("routeSelector");
        let tab = document.getElementById("routeSelectorTab");
        if (panel.classList.contains("hidden")) {
          panel.classList.remove("hidden");
          tab.innerHTML = "&#9664;"; // left arrow
        } else {
          panel.classList.add("hidden");
          tab.innerHTML = "&#9654;"; // right arrow
        }
        positionRouteTab();
      }

      function updateRouteLegend(displayedRoutes = []) {
        const legend = document.getElementById("routeLegend");
        if (!legend) return;
        const shouldShowLegend = kioskMode || adminKioskMode;
        if (!shouldShowLegend) {
          legend.style.display = "none";
          legend.innerHTML = "";
          return;
        }

        // Admin kiosk mode should surface every visible route, including those hidden from the public map.
        // Public kiosk mode must continue to hide routes flagged as non-public.
        const routesToRender = adminKioskMode
          ? displayedRoutes
          : displayedRoutes.filter(route => isRoutePublicById(route.routeId ?? route.routeID ?? route.id));

        if (routesToRender.length === 0) {
          legend.style.display = "none";
          legend.innerHTML = "";
          return;
        }

        legend.style.display = "block";
        legend.innerHTML = "";

        const title = document.createElement("div");
        title.className = "legend-title";
        title.textContent = "Routes";
        legend.appendChild(title);

        routesToRender.forEach(route => {
          const item = document.createElement("div");
          item.className = "legend-item";

          const color = document.createElement("span");
          color.className = "legend-color";
          color.style.backgroundColor = route.color || "#000000";
          item.appendChild(color);

          const textContainer = document.createElement("div");
          textContainer.className = "legend-text";

          const name = document.createElement("div");
          name.className = "legend-name";
          name.textContent = route.name;
          textContainer.appendChild(name);

          if (route.description) {
            const description = document.createElement("div");
            description.className = "legend-description";
            description.textContent = route.description;
            textContainer.appendChild(description);
          }

          item.appendChild(textContainer);
          legend.appendChild(item);
        });
      }

      // refreshMap updates route paths and bus locations.
      function refreshMap() {
        fetchBusLocations().then(fetchRoutePaths);
      }

      function clearRefreshIntervals() {
        refreshIntervals.forEach(clearInterval);
        refreshIntervals = [];
      }

      function startRefreshIntervals() {
        refreshIntervals.push(setInterval(fetchBusLocations, 4000));
        refreshIntervals.push(setInterval(fetchBusStops, 60000));
        refreshIntervals.push(setInterval(fetchBlockAssignments, 60000));
        refreshIntervals.push(setInterval(() => {
          fetchStopArrivalTimes().then(allEtas => {
            cachedEtas = allEtas;
            updateCustomPopups();
          });
        }, 15000));
        refreshIntervals.push(setInterval(fetchRoutePaths, 15000));
      }

      function showCookieBanner() {
        if (kioskMode || adminKioskMode) {
          return;
        }
        if (localStorage.getItem('agencyConsent') !== 'true') {
          const banner = document.getElementById('cookieBanner');
          banner.style.display = 'block';
          document.getElementById('cookieAccept').addEventListener('click', () => {
            localStorage.setItem('agencyConsent', 'true');
            localStorage.setItem('selectedAgency', baseURL);
            banner.style.display = 'none';
          });
        }
      }

      function changeAgency(url) {
        if (localStorage.getItem('agencyConsent') === 'true') {
          localStorage.setItem('selectedAgency', url);
        }
        clearRefreshIntervals();
        baseURL = url;
        Object.values(markers).forEach(m => map.removeLayer(m));
        markers = {};
        Object.values(nameBubbles).forEach(b => {
          if (b.speedMarker) map.removeLayer(b.speedMarker);
          if (b.nameMarker) map.removeLayer(b.nameMarker);
          if (b.blockMarker) map.removeLayer(b.blockMarker);
        });
        nameBubbles = {};
        stopMarkers.forEach(m => map.removeLayer(m));
        stopMarkers = [];
        routeLayers.forEach(l => map.removeLayer(l));
        routeLayers = [];
        cachedRouteVisualization = null;
        busBlocks = {};
        previousBusData = {};
        cachedEtas = {};
        customPopups.forEach(p => p.remove());
        customPopups = [];
        allRoutes = {};
        routeSelections = {};
        activeRoutes = new Set();
        routeColors = {};
        routeVisibility = {};
        allRouteBounds = null;
        mapHasFitAllRoutes = false;
        updateRouteLegend([]);
        updateRouteSelector(new Set(), true);
        fetchRouteColors().then(() => {
          fetchBusStops();
          fetchBlockAssignments();
          fetchBusLocations().then(fetchRoutePaths);
          fetchStopArrivalTimes().then(allEtas => { cachedEtas = allEtas; updateCustomPopups(); });
          startRefreshIntervals();
        });
      }

      function getRouteColor(routeID) {
        if (routeID === 0) return outOfServiceRouteColor;
        return routeColors[routeID] || '#000000';
      }

      function initMap() {
          map = L.map('map', { zoomControl: false }).setView([38.03799212281404, -78.50981502838886], 15);
          const cartoLight = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
              attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>'
          });
          cartoLight.addTo(map);
          
          fetchRouteColors().then(() => {
              if (kioskMode || adminKioskMode) {
                document.getElementById("routeSelector").style.display = "none";
                document.getElementById("routeSelectorTab").style.display = "none";
              }
              fetchStopArrivalTimes().then(allEtas => {
                  cachedEtas = allEtas;
                  updateCustomPopups();
              });
              fetchBusStops();
              fetchBlockAssignments();
              fetchBusLocations().then(fetchRoutePaths);
              startRefreshIntervals();
          });
          fetchStopArrivalTimes().then(allEtas => { cachedEtas = allEtas; });
          map.on('move', updatePopupPositions);
          map.on('zoom', updatePopupPositions);
          map.on('zoomend', () => {
              if (cachedRouteVisualization) {
                  renderRouteVisualization(cachedRouteVisualization);
              }
          });
      }

      function fetchBusStops() {
          const currentBaseURL = baseURL;
          const stopsApiUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetStops?APIKey=8882812681`;
          fetch(stopsApiUrl)
              .then(response => response.json())
              .then(data => {
                  if (currentBaseURL !== baseURL) return;
                  let stopsArray = data.stops || data;
                  if (stopsArray && Array.isArray(stopsArray)) {
                      stopMarkers.forEach(marker => map.removeLayer(marker));
                      stopMarkers = [];
                      const groupedStops = {};
                      stopsArray.forEach(stop => {
                          const key = `${stop.Latitude},${stop.Longitude}`;
                          if (!groupedStops[key]) groupedStops[key] = [];
                          groupedStops[key].push(stop);
                      });
                      Object.keys(groupedStops).forEach(key => {
                          const [latitude, longitude] = key.split(',').map(Number);
                          const stopPosition = [latitude, longitude];
                          const stopMarker = L.circleMarker(stopPosition, {
                              radius: 6,
                              color: "#000000",
                              fillColor: "#FFFFFF",
                              fillOpacity: 1,
                              weight: 3
                          }).addTo(map);
                          const routeStopIds = groupedStops[key].map(stop => stop.RouteStopID);
                          const unifiedStopId = groupedStops[key][0].StopID || groupedStops[key][0].StopId;
                          const etas = [];
                          routeStopIds.forEach(routeStopId => {
                              if (cachedEtas[routeStopId]) {
                                  cachedEtas[routeStopId].forEach(eta => etas.push(eta));
                              }
                          });
                          const stopNames = groupedStops[key][0].Description;
                          const etaText = etas.length > 0
                            ? etas.sort((a, b) => a.etaMinutes - b.etaMinutes || a.routeDescription.localeCompare(b.routeDescription))
                                  .map(eta => `<tr><td style="padding: 5px; text-align: center;"><div class="route-pill" style="background-color: ${getRouteColor(eta.RouteId)}; color: ${getContrastColor(getRouteColor(eta.RouteId))};">${eta.routeDescription}</div></td><td style="padding: 5px; text-align: center;">${eta.etaMinutes < 1 ? 'Arriving' : eta.etaMinutes + ' min'}</td></tr>`).join('')
                            : '<tr><td colspan="2" style="padding: 5px; text-align: center;">No upcoming arrivals</td></tr>';
                          stopMarker.on('click', () => {
                              createCustomPopup(stopPosition, stopNames, etaText, routeStopIds, unifiedStopId);
                          });
                          stopMarkers.push(stopMarker);
                      });
                      stopMarkers.forEach(marker => marker.bringToFront());
                  }
              })
              .catch(error => console.error("Error fetching bus stops:", error));
      }

      function createCustomPopup(position, stopName, etaText, routeStopIds, stopId) {
          customPopups.forEach(popup => popup.remove());
          customPopups = [];
          const popupElement = document.createElement('div');
          popupElement.className = 'custom-popup';
          const etaTable = `
            <table style="width: 100%; margin-top: 10px; border-collapse: collapse;">
              <thead>
                <tr>
                  <th style="border-bottom: 1px solid white; padding: 5px;">Route</th>
                  <th style="border-bottom: 1px solid white; padding: 5px;">ETA</th>
                </tr>
              </thead>
              <tbody>
                ${etaText}
              </tbody>
            </table>
          `;
          popupElement.innerHTML = `
            <button class="custom-popup-close">&times;</button>
            <span style="font-size: 16px; font-weight: bold;">${stopName}</span><br>
            <span>Stop ID: ${stopId}</span><br>
            ${etaTable}
            <div class="custom-popup-arrow"></div>
          `;
          document.body.appendChild(popupElement);
          popupElement.dataset.position = `${position[0]},${position[1]}`;
          popupElement.dataset.stopName = stopName.replace('Stop Name: ', '');
          popupElement.dataset.routeStopIds = JSON.stringify(routeStopIds);
          popupElement.dataset.stopId = stopId;
          updatePopupPosition(popupElement, position);
          popupElement.querySelector('.custom-popup-close').addEventListener('click', () => {
              popupElement.remove();
              customPopups = customPopups.filter(popup => popup !== popupElement);
          });
          customPopups.push(popupElement);
      }

      function updatePopupPosition(popupElement, position) {
          const mapPos = map.latLngToContainerPoint(position);
          popupElement.style.left = `${mapPos.x}px`;
          popupElement.style.top = `${mapPos.y}px`;
      }

      function updatePopupPositions() {
          customPopups.forEach(popupElement => {
              const position = popupElement.dataset.position;
              if (position) {
                  const [latitude, longitude] = position.split(',').map(Number);
                  updatePopupPosition(popupElement, [latitude, longitude]);
              }
          });
      }

      function updateCustomPopups() {
          customPopups.forEach(popupElement => {
              const position = popupElement.dataset.position;
              if (position) {
                  const routeStopIds = JSON.parse(popupElement.dataset.routeStopIds);
                  const etas = [];
                  routeStopIds.forEach(routeStopId => {
                      if (cachedEtas[routeStopId]) {
                          cachedEtas[routeStopId].forEach(eta => etas.push(eta));
                      }
                  });
                  const etaText = etas.length > 0
                    ? etas.sort((a, b) => a.etaMinutes - b.etaMinutes || a.routeDescription.localeCompare(b.routeDescription))
                          .map(eta => `<tr><td style="padding: 5px; text-align: center;"><div class="route-pill" style="background-color: ${getRouteColor(eta.RouteId)}; color: ${getContrastColor(getRouteColor(eta.RouteId))};">${eta.routeDescription}</div></td><td style="padding: 5px; text-align: center;">${eta.etaMinutes < 1 ? 'Arriving' : eta.etaMinutes + ' min'}</td></tr>`).join('')
                    : '<tr><td colspan="2" style="padding: 5px; text-align: center;">No upcoming arrivals</td></tr>';
                  const etaTable = `
                    <table style="width: 100%; margin-top: 10px; border-collapse: collapse;">
                      <thead>
                        <tr>
                          <th style="border-bottom: 1px solid white; padding: 5px;">Route</th>
                          <th style="border-bottom: 1px solid white; padding: 5px;">ETA</th>
                        </tr>
                      </thead>
                      <tbody>
                        ${etaText}
                      </tbody>
                    </table>
                  `;
                  const stopId = popupElement.dataset.stopId;
                  popupElement.innerHTML = `
                    <button class="custom-popup-close">&times;</button>
                    <span style="font-size: 16px; font-weight: bold;">${popupElement.dataset.stopName}</span><br>
                    <span>Stop ID: ${stopId}</span><br>
                    ${etaTable}
                    <div class="custom-popup-arrow"></div>
                  `;
                  popupElement.querySelector('.custom-popup-close').addEventListener('click', () => {
                      popupElement.remove();
                      customPopups = customPopups.filter(popup => popup !== popupElement);
                  });
              }
          });
      }

      function fetchStopArrivalTimes() {
          const currentBaseURL = baseURL;
          const arrivalTimesApiUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetStopArrivalTimes?APIKey=8882812681`;
          return fetch(arrivalTimesApiUrl)
              .then(response => response.json())
              .then(data => {
                  if (currentBaseURL !== baseURL) return {};
                  let allEtas = {};
                  data.forEach(arrival => {
                      if (!allEtas[arrival.RouteStopId]) {
                          allEtas[arrival.RouteStopId] = [];
                      }
                      arrival.Times.forEach(time => {
                          const etaMinutes = Math.round(time.Seconds / 60);
                          allEtas[arrival.RouteStopId].push({
                              routeDescription: (arrival.RouteDescription === 'Night Pilot' ? arrival.RouteDescription : arrival.RouteDescription.slice(0, -5)),
                              etaMinutes: etaMinutes,
                              RouteId: arrival.RouteId
                          });
                      });
                  });
                  return allEtas;
              })
              .catch(error => {
                  console.error("Error fetching stop arrival times:", error);
                  return {};
              });
      }

      // Fetch routes from GetRoutes.
      function fetchRouteColors() {
        console.log('Fetching route colors...');
        const routesApiUrl = `${baseURL}/Services/JSONPRelay.svc/GetRoutes?APIKey=8882812681`;
        return fetch(routesApiUrl)
          .then(response => response.json())
          .then(data => {
            if (Array.isArray(data)) {
              data.forEach(route => {
                setRouteVisibility(route);
                allRoutes[route.RouteID] = Object.assign(allRoutes[route.RouteID] || {}, route);
                if (canDisplayRoute(route.RouteID)) {
                  routeColors[route.RouteID] = route.MapLineColor;
                  console.log(`Route ID: ${route.RouteID}, Color: ${route.MapLineColor}`);
                } else {
                  delete routeColors[route.RouteID];
                  console.log(`Route ID: ${route.RouteID} hidden due to display settings`);
                }
              });
            }
          })
          .catch(error => console.error("Error fetching route colors:", error));
      }

      function toRadians(degrees) {
        return degrees * Math.PI / 180;
      }

      function distanceMeters(a, b) {
        if (!a || !b || a.length < 2 || b.length < 2) return Infinity;
        const lat1 = toRadians(a[0]);
        const lat2 = toRadians(b[0]);
        const dLat = lat2 - lat1;
        const dLng = toRadians(b[1] - a[1]);
        const sinDLat = Math.sin(dLat / 2);
        const sinDLng = Math.sin(dLng / 2);
        const aa = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLng * sinDLng;
        const c = 2 * Math.atan2(Math.sqrt(aa), Math.sqrt(Math.max(0, 1 - aa)));
        return 6371000 * c;
      }

      function bearingDegrees(a, b) {
        if (!a || !b || a.length < 2 || b.length < 2) return 0;
        const lat1 = toRadians(a[0]);
        const lat2 = toRadians(b[0]);
        const dLng = toRadians(b[1] - a[1]);
        const y = Math.sin(dLng) * Math.cos(lat2);
        const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLng);
        const raw = Math.atan2(y, x);
        const degrees = (raw * 180 / Math.PI + 360) % 360;
        return degrees;
      }

      function normalizeBearing(angle) {
        if (!Number.isFinite(angle)) return 0;
        const normalized = ((angle % 360) + 360) % 360;
        return normalized >= 180 ? normalized - 180 : normalized;
      }

      function angleDifference(a, b) {
        if (!Number.isFinite(a) || !Number.isFinite(b)) return 180;
        const diff = Math.abs(a - b);
        return Math.min(diff, 180 - diff);
      }

      function densifyPolyline(points, maxSegmentLengthMeters) {
        if (!Array.isArray(points) || points.length === 0) return [];
        const result = [];
        const maxSegment = Math.max(1, maxSegmentLengthMeters || SEGMENT_SAMPLING_DISTANCE_METERS);
        result.push(points[0]);
        for (let i = 1; i < points.length; i++) {
          const start = points[i - 1];
          const end = points[i];
          if (!start || !end) continue;
          const dist = distanceMeters(start, end);
          if (!Number.isFinite(dist) || dist === 0) {
            const lastPoint = result[result.length - 1];
            if (!lastPoint || lastPoint[0] !== end[0] || lastPoint[1] !== end[1]) {
              result.push(end);
            }
            continue;
          }
          const segments = Math.max(1, Math.ceil(dist / maxSegment));
          for (let step = 1; step <= segments; step++) {
            const fraction = step / segments;
            const lat = start[0] + (end[0] - start[0]) * fraction;
            const lng = start[1] + (end[1] - start[1]) * fraction;
            const lastPoint = result[result.length - 1];
            if (!lastPoint || Math.abs(lastPoint[0] - lat) > 1e-12 || Math.abs(lastPoint[1] - lng) > 1e-12) {
              result.push([lat, lng]);
            }
          }
        }
        return result;
      }

      function computePolylineLength(points) {
        if (!Array.isArray(points) || points.length < 2) return 0;
        let total = 0;
        for (let i = 1; i < points.length; i++) {
          const dist = distanceMeters(points[i - 1], points[i]);
          if (Number.isFinite(dist)) {
            total += dist;
          }
        }
        return total;
      }

      function computeCumulativeDistances(points) {
        if (!Array.isArray(points) || points.length === 0) return [];
        const cumulative = [0];
        for (let i = 1; i < points.length; i++) {
          const prevTotal = cumulative[i - 1];
          const segmentLength = distanceMeters(points[i - 1], points[i]);
          cumulative.push(prevTotal + (Number.isFinite(segmentLength) && segmentLength > 0 ? segmentLength : 0));
        }
        return cumulative;
      }

      function getPointAtDistanceOnPath(points, targetDistance, cumulativeDistances = null) {
        if (!Array.isArray(points) || points.length === 0) return null;
        const cumulative = Array.isArray(cumulativeDistances) && cumulativeDistances.length === points.length
          ? cumulativeDistances
          : computeCumulativeDistances(points);
        if (cumulative.length === 0) return points[0];
        const totalLength = cumulative[cumulative.length - 1];
        if (!Number.isFinite(totalLength) || totalLength <= 0) {
          const first = points[0];
          return [first[0], first[1]];
        }
        const target = Math.max(0, Math.min(totalLength, Number.isFinite(targetDistance) ? targetDistance : 0));
        let index = 0;
        while (index < cumulative.length && cumulative[index] < target) {
          index++;
        }
        if (index <= 0) {
          const first = points[0];
          return [first[0], first[1]];
        }
        if (index >= cumulative.length) {
          const last = points[points.length - 1];
          return [last[0], last[1]];
        }
        if (Math.abs(cumulative[index] - target) <= 1e-9) {
          const exact = points[index];
          return [exact[0], exact[1]];
        }
        const prevIndex = index - 1;
        const prevDistance = cumulative[prevIndex];
        const segmentLength = cumulative[index] - prevDistance;
        if (!Number.isFinite(segmentLength) || segmentLength <= 0) {
          const point = points[index];
          return [point[0], point[1]];
        }
        const t = (target - prevDistance) / segmentLength;
        const start = points[prevIndex];
        const end = points[index];
        const lat = start[0] + (end[0] - start[0]) * t;
        const lng = start[1] + (end[1] - start[1]) * t;
        return [lat, lng];
      }

      function buildAveragedPath(referencePoints, referenceDistances, shapeInfos) {
        if (!Array.isArray(referencePoints) || referencePoints.length < 2) {
          return Array.isArray(referencePoints)
            ? referencePoints.map(pt => [pt[0], pt[1]])
            : [];
        }
        const sanitizedDistances = Array.isArray(referenceDistances) && referenceDistances.length === referencePoints.length
          ? referenceDistances
          : computeCumulativeDistances(referencePoints);
        if (sanitizedDistances.length !== referencePoints.length) {
          return referencePoints.map(pt => [pt[0], pt[1]]);
        }
        const totalReferenceLength = sanitizedDistances[sanitizedDistances.length - 1];
        if (!Number.isFinite(totalReferenceLength) || totalReferenceLength <= 0) {
          return referencePoints.map(pt => [pt[0], pt[1]]);
        }
        return referencePoints.map((refPoint, idx) => {
          const distanceAlong = sanitizedDistances[idx];
          const ratio = totalReferenceLength > 0 ? distanceAlong / totalReferenceLength : 0;
          const contributions = [];
          shapeInfos.forEach(info => {
            if (!info || !Array.isArray(info.pathPoints) || info.pathPoints.length === 0) return;
            const totalLength = Number.isFinite(info.totalLength) ? info.totalLength : 0;
            if (totalLength <= 0) {
              const first = info.pathPoints[0];
              contributions.push([first[0], first[1]]);
              return;
            }
            const targetDistance = ratio * totalLength;
            const point = getPointAtDistanceOnPath(info.pathPoints, targetDistance, info.cumulativeDistances);
            if (Array.isArray(point) && point.length === 2 && Number.isFinite(point[0]) && Number.isFinite(point[1])) {
              contributions.push(point);
            }
          });
          if (!contributions.length) {
            return [refPoint[0], refPoint[1]];
          }
          const clusters = [];
          contributions.forEach(coord => {
            if (!Array.isArray(coord) || coord.length < 2) return;
            let matchedCluster = null;
            for (const cluster of clusters) {
              if (distanceMeters(cluster.center, coord) <= CONTRIBUTION_CLUSTER_DISTANCE_METERS) {
                matchedCluster = cluster;
                break;
              }
            }
            if (matchedCluster) {
              matchedCluster.count += 1;
              const weight = 1 / matchedCluster.count;
              matchedCluster.center[0] = matchedCluster.center[0] + (coord[0] - matchedCluster.center[0]) * weight;
              matchedCluster.center[1] = matchedCluster.center[1] + (coord[1] - matchedCluster.center[1]) * weight;
            } else {
              clusters.push({
                center: [coord[0], coord[1]],
                count: 1
              });
            }
          });
          if (!clusters.length) {
            return [refPoint[0], refPoint[1]];
          }
          const summedCenters = clusters.reduce((acc, cluster) => {
            acc[0] += cluster.center[0];
            acc[1] += cluster.center[1];
            return acc;
          }, [0, 0]);
          return [
            summedCenters[0] / clusters.length,
            summedCenters[1] / clusters.length
          ];
        });
      }

      function mergeReplacementPoint(replacements, index, point, originalPoint = null) {
        if (!(replacements instanceof Map)) return;
        if (!Number.isFinite(index)) return;
        if (!Array.isArray(point) || point.length < 2) return;
        if (Array.isArray(originalPoint) && originalPoint.length >= 2) {
          const distance = distanceMeters(originalPoint, point);
          if (!Number.isFinite(distance) || distance > MAX_BOUNDARY_REPLACEMENT_DISTANCE_METERS) {
            return;
          }
        }
        const sanitized = [point[0], point[1]];
        if (replacements.has(index)) {
          const existing = replacements.get(index);
          if (Array.isArray(existing) && existing.length === 2) {
            replacements.set(index, [
              (existing[0] + sanitized[0]) / 2,
              (existing[1] + sanitized[1]) / 2
            ]);
            return;
          }
        }
        replacements.set(index, sanitized);
      }

      function getAdjustedPointForIndex(replacements, index, originalPoint) {
        if (!Array.isArray(originalPoint) || originalPoint.length < 2) return originalPoint;
        if (!(replacements instanceof Map) || !Number.isFinite(index)) {
          return [originalPoint[0], originalPoint[1]];
        }
        const replacement = replacements.get(index);
        if (!replacement || !Array.isArray(replacement) || replacement.length < 2) {
          return [originalPoint[0], originalPoint[1]];
        }
        return [replacement[0], replacement[1]];
      }

      function createSegmentBucketKey(segment) {
        const latIdx = Math.round(segment.mid[0] / LAT_LNG_BUCKET_SIZE);
        const lngIdx = Math.round(segment.mid[1] / LAT_LNG_BUCKET_SIZE);
        const angleIdx = Math.round(segment.bearing / ANGLE_TOLERANCE_DEGREES);
        return `${latIdx}|${lngIdx}|${angleIdx}`;
      }

      function clusterSegments(segments) {
        if (!Array.isArray(segments) || segments.length === 0) return [];
        const parents = segments.map((_, idx) => idx);

        function find(idx) {
          if (parents[idx] !== idx) {
            parents[idx] = find(parents[idx]);
          }
          return parents[idx];
        }

        function union(a, b) {
          const rootA = find(a);
          const rootB = find(b);
          if (rootA === rootB) return;
          parents[rootB] = rootA;
        }

        for (let i = 0; i < segments.length; i++) {
          for (let j = i + 1; j < segments.length; j++) {
            const segA = segments[i];
            const segB = segments[j];
            if (!segA || !segB) continue;
            if (segA.routeId === segB.routeId) continue;
            const angleDiff = angleDifference(segA.bearing, segB.bearing);
            if (angleDiff > ANGLE_TOLERANCE_DEGREES) continue;
            const midDist = distanceMeters(segA.mid, segB.mid);
            if (midDist > OVERLAP_DISTANCE_TOLERANCE_METERS) continue;
            union(i, j);
          }
        }

        const indicesByShape = new Map();
        segments.forEach((seg, idx) => {
          if (!seg || !seg.shapeId) return;
          const key = seg.shapeId;
          if (!indicesByShape.has(key)) indicesByShape.set(key, []);
          indicesByShape.get(key).push(idx);
        });
        indicesByShape.forEach(indexList => {
          indexList.sort((a, b) => segments[a].index - segments[b].index);
          for (let k = 1; k < indexList.length; k++) {
            const prevSeg = segments[indexList[k - 1]];
            const currSeg = segments[indexList[k]];
            if (prevSeg && currSeg && Math.abs(currSeg.index - prevSeg.index) === 1) {
              union(indexList[k - 1], indexList[k]);
            }
          }
        });

        const groupsMap = new Map();
        segments.forEach((seg, idx) => {
          if (!seg) return;
          const root = find(idx);
          if (!groupsMap.has(root)) groupsMap.set(root, []);
          groupsMap.get(root).push(seg);
        });
        return Array.from(groupsMap.values());
      }

      function normalizeColorInfos(colorInfos) {
        if (!Array.isArray(colorInfos)) return [];
        const unique = [];
        const seen = new Set();
        colorInfos.forEach(info => {
          if (!info) return;
          const color = typeof info.color === 'string' && info.color ? info.color : '#000000';
          const routeId = info.routeId;
          const key = routeId != null ? `id:${routeId}` : `color:${color}`;
          if (seen.has(key)) return;
          seen.add(key);
          unique.push({ routeId, color });
        });
        unique.sort((a, b) => {
          const idA = a.routeId;
          const idB = b.routeId;
          if (typeof idA === 'number' && typeof idB === 'number') {
            return idA - idB;
          }
          return String(idA).localeCompare(String(idB));
        });
        return unique;
      }

      function computeRouteOverlapGraphics(routeShapes) {
        if (!Array.isArray(routeShapes) || routeShapes.length === 0) {
          return { overlaps: [], nonOverlap: [] };
        }

        function sanitizePoints(points) {
          if (!Array.isArray(points)) return [];
          const sanitized = [];
          points.forEach(pt => {
            if (!Array.isArray(pt) || pt.length < 2) return;
            const lat = Number(pt[0]);
            const lng = Number(pt[1]);
            if (!Number.isFinite(lat) || !Number.isFinite(lng)) return;
            if (!sanitized.length) {
              sanitized.push([lat, lng]);
              return;
            }
            const prev = sanitized[sanitized.length - 1];
            if (Math.abs(prev[0] - lat) > 1e-12 || Math.abs(prev[1] - lng) > 1e-12) {
              sanitized.push([lat, lng]);
            }
          });
          return sanitized;
        }

        function sanitizeSlice(points) {
          const sanitized = sanitizePoints(points);
          return sanitized.length < 2 ? [] : sanitized;
        }

        const processedRoutes = [];
        const routeLookup = new Map();
        const segmentsList = [];

        routeShapes.forEach((shape, idx) => {
          if (!shape || !Array.isArray(shape.points) || shape.points.length < 2) return;
          const rawRouteId = shape.routeId;
          const routeId = rawRouteId != null ? rawRouteId : idx;
          const color = typeof shape.color === 'string' && shape.color ? shape.color : '#000000';
          const basePoints = sanitizePoints(shape.points);
          if (basePoints.length < 2) return;
          const densified = sanitizePoints(densifyPolyline(basePoints, SEGMENT_SAMPLING_DISTANCE_METERS));
          if (densified.length < 2) return;
          const cumulativeDistances = computeCumulativeDistances(densified);
          const totalLength = cumulativeDistances.length > 0
            ? cumulativeDistances[cumulativeDistances.length - 1]
            : computePolylineLength(densified);
          const routeKey = typeof routeId === 'number'
            ? `n:${routeId}`
            : `s:${String(routeId)}`;
          const routeData = {
            routeId,
            routeKey,
            color,
            rawPoints: densified.map(pt => [pt[0], pt[1]]),
            cumulativeDistances,
            totalLength,
            segments: [],
            overlapSegmentIndices: new Set()
          };
          for (let i = 1; i < densified.length; i++) {
            const start = densified[i - 1];
            const end = densified[i];
            const segLength = distanceMeters(start, end);
            if (!Number.isFinite(segLength) || segLength < MIN_SEGMENT_LENGTH_METERS) continue;
            const midLat = (start[0] + end[0]) / 2;
            const midLng = (start[1] + end[1]) / 2;
            const bearing = normalizeBearing(bearingDegrees(start, end));
            const latIdx = Math.round(midLat / LAT_LNG_BUCKET_SIZE);
            const lngIdx = Math.round(midLng / LAT_LNG_BUCKET_SIZE);
            const angleIdx = Math.round(bearing / ANGLE_TOLERANCE_DEGREES);
            const segment = {
              routeId,
              routeKey,
              color,
              start: [start[0], start[1]],
              end: [end[0], end[1]],
              mid: [midLat, midLng],
              length: segLength,
              bearing,
              routePointStartIndex: i - 1,
              routePointEndIndex: i,
              index: i - 1,
              latIdx,
              lngIdx,
              angleIdx,
              globalIndex: segmentsList.length,
              isOverlapping: false,
              matchRouteIds: new Set()
            };
            segmentsList.push(segment);
            routeData.segments.push(segment);
          }
          processedRoutes.push(routeData);
          routeLookup.set(routeKey, routeData);
        });

        if (!segmentsList.length) {
          const fallback = [];
          processedRoutes.forEach(route => {
            if (!Array.isArray(route.rawPoints) || route.rawPoints.length < 2) return;
            const path = sanitizeSlice(route.rawPoints);
            if (path.length >= 2) {
              fallback.push({
                path,
                color: route.color,
                routeId: route.routeId
              });
            }
          });
          return { overlaps: [], nonOverlap: fallback };
        }

        const bucketMap = new Map();
        segmentsList.forEach(segment => {
          const key = `${segment.latIdx}|${segment.lngIdx}|${segment.angleIdx}`;
          if (!bucketMap.has(key)) bucketMap.set(key, []);
          bucketMap.get(key).push(segment);
        });

        const parents = segmentsList.map((_, idx) => idx);
        const ranks = segmentsList.map(() => 0);

        function find(idx) {
          if (parents[idx] !== idx) {
            parents[idx] = find(parents[idx]);
          }
          return parents[idx];
        }

        function union(a, b) {
          const rootA = find(a);
          const rootB = find(b);
          if (rootA === rootB) return;
          const rankA = ranks[rootA];
          const rankB = ranks[rootB];
          if (rankA < rankB) {
            parents[rootA] = rootB;
          } else if (rankA > rankB) {
            parents[rootB] = rootA;
          } else {
            parents[rootB] = rootA;
            ranks[rootA] += 1;
          }
        }

        segmentsList.forEach(segment => {
          const { latIdx, lngIdx, angleIdx } = segment;
          for (let dLat = -1; dLat <= 1; dLat++) {
            for (let dLng = -1; dLng <= 1; dLng++) {
              for (let dAngle = -1; dAngle <= 1; dAngle++) {
                const key = `${latIdx + dLat}|${lngIdx + dLng}|${angleIdx + dAngle}`;
                const bucket = bucketMap.get(key);
                if (!bucket) continue;
                bucket.forEach(candidate => {
                  if (!candidate) return;
                  if (candidate.globalIndex <= segment.globalIndex) return;
                  if (candidate.routeKey === segment.routeKey) return;
                  const angleDiff = angleDifference(segment.bearing, candidate.bearing);
                  if (!Number.isFinite(angleDiff) || angleDiff > ANGLE_TOLERANCE_DEGREES) return;
                  const midDist = distanceMeters(segment.mid, candidate.mid);
                  if (!Number.isFinite(midDist) || midDist > OVERLAP_DISTANCE_TOLERANCE_METERS) return;
                  segment.isOverlapping = true;
                  candidate.isOverlapping = true;
                  segment.matchRouteIds.add(candidate.routeId);
                  candidate.matchRouteIds.add(segment.routeId);
                  union(segment.globalIndex, candidate.globalIndex);
                });
              }
            }
          }
        });

        processedRoutes.forEach(route => {
          const segs = route.segments;
          if (!Array.isArray(segs) || segs.length < 2) return;
          segs.sort((a, b) => a.routePointStartIndex - b.routePointStartIndex);
          for (let i = 1; i < segs.length; i++) {
            const prev = segs[i - 1];
            const curr = segs[i];
            if (!prev.isOverlapping || !curr.isOverlapping) continue;
            let sharesRoute = false;
            prev.matchRouteIds.forEach(id => {
              if (curr.matchRouteIds.has(id)) {
                sharesRoute = true;
              }
            });
            if (sharesRoute) {
              union(prev.globalIndex, curr.globalIndex);
            }
          }
        });

        const clusters = new Map();
        segmentsList.forEach(segment => {
          if (!segment.isOverlapping) return;
          const root = find(segment.globalIndex);
          if (!clusters.has(root)) clusters.set(root, []);
          clusters.get(root).push(segment);
        });

        const overlaps = [];

        clusters.forEach(clusterSegments => {
          if (!Array.isArray(clusterSegments) || clusterSegments.length === 0) return;
          const segmentsByRoute = new Map();
          clusterSegments.forEach(seg => {
            if (!segmentsByRoute.has(seg.routeKey)) segmentsByRoute.set(seg.routeKey, []);
            segmentsByRoute.get(seg.routeKey).push(seg);
          });
          if (segmentsByRoute.size <= 1) return;

          const contributions = [];
          const colorInfos = [];
          let referenceInfo = null;

          segmentsByRoute.forEach((segList, routeKey) => {
            const routeData = routeLookup.get(routeKey);
            if (!routeData || !segList.length) return;
            segList.sort((a, b) => a.routePointStartIndex - b.routePointStartIndex);
            let minIdx = Infinity;
            let maxIdx = -Infinity;
            segList.forEach(seg => {
              if (Number.isFinite(seg.routePointStartIndex)) {
                minIdx = Math.min(minIdx, seg.routePointStartIndex);
              }
              if (Number.isFinite(seg.routePointEndIndex)) {
                maxIdx = Math.max(maxIdx, seg.routePointEndIndex);
              }
            });
            if (!Number.isFinite(minIdx) || !Number.isFinite(maxIdx)) return;
            const startIndex = Math.max(0, Math.min(routeData.rawPoints.length - 2, Math.floor(minIdx)));
            const endIndex = Math.min(routeData.rawPoints.length - 1, Math.max(startIndex + 1, Math.ceil(maxIdx)));
            const slice = routeData.rawPoints.slice(startIndex, endIndex + 1);
            const sanitizedSlice = sanitizeSlice(slice);
            if (sanitizedSlice.length < 2) return;
            const subCumulative = [];
            const base = routeData.cumulativeDistances[startIndex];
            for (let idx2 = startIndex; idx2 <= endIndex; idx2++) {
              subCumulative.push(routeData.cumulativeDistances[idx2] - base);
            }
            const totalLength = subCumulative.length > 0 ? subCumulative[subCumulative.length - 1] : 0;
            const info = {
              routeId: routeData.routeId,
              color: routeData.color,
              pathPoints: sanitizedSlice,
              cumulativeDistances: subCumulative,
              totalLength
            };
            contributions.push({ routeData, segList, info });
            colorInfos.push({ routeId: routeData.routeId, color: routeData.color });
            if (!referenceInfo || totalLength > referenceInfo.totalLength) {
              referenceInfo = info;
            }
          });

          if (!referenceInfo || contributions.length < 2) return;

          const referencePoints = referenceInfo.pathPoints.map(pt => [pt[0], pt[1]]);
          const referenceDistances = referenceInfo.cumulativeDistances.slice();
          const replacements = new Map();
          contributions.forEach(({ info }) => {
            if (!info.pathPoints || info.pathPoints.length === 0) return;
            mergeReplacementPoint(replacements, 0, info.pathPoints[0], referencePoints[0]);
            mergeReplacementPoint(
              replacements,
              referencePoints.length - 1,
              info.pathPoints[info.pathPoints.length - 1],
              referencePoints[referencePoints.length - 1]
            );
          });
          const adjustedReference = referencePoints.map((pt, idx) => getAdjustedPointForIndex(replacements, idx, pt));
          const averagedPath = buildAveragedPath(adjustedReference, referenceDistances, contributions.map(c => c.info));
          const sanitizedPath = sanitizeSlice(averagedPath);
          if (sanitizedPath.length < 2) return;

          contributions.forEach(({ routeData, segList }) => {
            segList.forEach(seg => {
              if (Number.isFinite(seg.routePointStartIndex)) {
                routeData.overlapSegmentIndices.add(seg.routePointStartIndex);
              }
            });
          });

          const normalizedColors = normalizeColorInfos(colorInfos);
          overlaps.push({
            path: sanitizedPath,
            colorInfos: normalizedColors,
            normalizedColorInfos: normalizedColors
          });
        });

        const nonOverlap = [];
        processedRoutes.forEach(route => {
          const points = route.rawPoints;
          if (!Array.isArray(points) || points.length < 2) return;
          const overlapSet = route.overlapSegmentIndices;
          let currentStart = null;
          for (let segIdx = 0; segIdx < points.length - 1; segIdx++) {
            const isOverlap = overlapSet.has(segIdx);
            if (isOverlap) {
              if (currentStart !== null) {
                const slice = sanitizeSlice(points.slice(currentStart, segIdx + 1));
                if (slice.length >= 2) {
                  nonOverlap.push({
                    path: slice,
                    color: route.color,
                    routeId: route.routeId
                  });
                }
                currentStart = null;
              }
            } else {
              if (currentStart === null) {
                currentStart = segIdx;
              }
            }
          }
          if (currentStart !== null) {
            const slice = sanitizeSlice(points.slice(currentStart, points.length));
            if (slice.length >= 2) {
              nonOverlap.push({
                path: slice,
                color: route.color,
                routeId: route.routeId
              });
            }
          }
        });

        if (!nonOverlap.length && !overlaps.length) {
          processedRoutes.forEach(route => {
            const slice = sanitizeSlice(route.rawPoints);
            if (slice.length >= 2) {
              nonOverlap.push({
                path: slice,
                color: route.color,
                routeId: route.routeId
              });
            }
          });
        }

        return { overlaps, nonOverlap };
      }

      function renderRouteVisualization(visualization) {
        routeLayers.forEach(layer => {
          if (layer && typeof layer._stripeCleanup === 'function') {
            layer._stripeCleanup();
          }
          if (layer) {
            map.removeLayer(layer);
          }
        });
        routeLayers = [];

        if (!visualization) {
          stopMarkers.forEach(marker => marker.bringToFront());
          return;
        }

        const { overlaps, nonOverlap } = visualization;

        if (Array.isArray(nonOverlap)) {
          nonOverlap.forEach(segment => {
            if (!segment || !Array.isArray(segment.path) || segment.path.length < 2) return;
            const layer = L.polyline(segment.path, {
              color: segment.color || '#000000',
              weight: 6,
              opacity: 1,
              lineCap: 'butt',
              lineJoin: 'miter',
              smoothFactor: 0
            }).addTo(map);
            routeLayers.push(layer);
          });
        }

        if (Array.isArray(overlaps) && overlaps.length > 0) {
          overlaps.forEach(section => {
            if (!section || !Array.isArray(section.path) || section.path.length < 2) return;
            const normalized = section.normalizedColorInfos || normalizeColorInfos(section.colorInfos);
            if (!normalized.length) return;
            section.normalizedColorInfos = normalized;
            const colorOrder = normalized.map(info => info.color || '#000000');
            const latlngs = section.path.map(pt => L.latLng(pt[0], pt[1]));
            if (latlngs.length < 2) return;
            const group = addStripedGroup(map, latlngs, colorOrder, {
              stripePx: 18,
              weight: 8,
              densifyStepM: 12,
              opacity: 1,
              lineCap: 'butt',
              lineJoin: 'miter'
            });
            if (group) {
              group.addTo(map);
              routeLayers.push(group);
            }
          });
        }

        stopMarkers.forEach(marker => marker.bringToFront());
      }

      // Fetch route paths from GetRoutesForMapWithSchedule and center map on all routes.
      function fetchRoutePaths() {
          const currentBaseURL = baseURL;
          const routePathsApiUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetRoutesForMapWithScheduleWithEncodedLine?APIKey=8882812681`;
          fetch(routePathsApiUrl)
              .then(response => response.json())
              .then(data => {
                  if (currentBaseURL !== baseURL) return;
                  let bounds = null;
                  const displayedRoutes = new Map();
                  let visualization = null;
                  if (Array.isArray(data)) {
                      const selectedRoutesForDrawing = [];
                      data.forEach(route => {
                          setRouteVisibility(route);
                          allRoutes[route.RouteID] = Object.assign(allRoutes[route.RouteID] || {}, route);
                          const routeAllowed = canDisplayRoute(route.RouteID);
                          if (route.EncodedPolyline && routeAllowed) {
                              const decodedPolyline = polyline.decode(route.EncodedPolyline);
                              const polyBounds = L.latLngBounds(decodedPolyline);
                              bounds = bounds ? bounds.extend(polyBounds) : polyBounds;

                              const storedRoute = allRoutes[route.RouteID] || {};
                              const legendNameCandidates = [
                                  storedRoute.Description,
                                  route.Description,
                                  storedRoute.Name,
                                  route.Name,
                                  storedRoute.RouteName,
                                  route.RouteName
                              ];
                              let legendName = legendNameCandidates.find(value => typeof value === 'string' && value.trim() !== '');
                              legendName = legendName ? legendName.trim() : `Route ${route.RouteID}`;
                              const rawDescription = storedRoute.InfoText ?? route.InfoText ?? '';
                              const legendDescription = typeof rawDescription === 'string' ? rawDescription.trim() : '';
                              const numericRouteId = Number(route.RouteID);
                              const effectiveRouteId = Number.isNaN(numericRouteId) ? route.RouteID : numericRouteId;
                              const legendRouteId = Number.isNaN(numericRouteId) ? route.RouteID : numericRouteId;

                              if (isRouteSelected(route.RouteID)) {
                                  const routeColor = getRouteColor(route.RouteID);
                                  selectedRoutesForDrawing.push({
                                      routeId: effectiveRouteId,
                                      color: routeColor,
                                      points: decodedPolyline
                                  });
                                  displayedRoutes.set(route.RouteID, {
                                      routeId: legendRouteId,
                                      color: routeColor,
                                      name: legendName,
                                      description: legendDescription
                                  });
                              }
                          }
                      });

                      if (selectedRoutesForDrawing.length > 0) {
                          visualization = computeRouteOverlapGraphics(selectedRoutesForDrawing);
                      }
                  }
                  cachedRouteVisualization = visualization;
                  renderRouteVisualization(cachedRouteVisualization);
                  if (bounds) {
                      allRouteBounds = bounds;
                      if (!mapHasFitAllRoutes) {
                          if (!kioskMode && !adminKioskMode) {
                              map.fitBounds(allRouteBounds, { padding: [20, 20] });
                          }
                          mapHasFitAllRoutes = true;
                      }
                  }
                  updateRouteSelector(activeRoutes);
                  updateRouteLegend(Array.from(displayedRoutes.values()));
              })
              .catch(error => {
                  console.error("Error fetching route paths:", error);
                  cachedRouteVisualization = null;
                  renderRouteVisualization(null);
                  updateRouteLegend([]);
              });
      }

      function fetchBlockAssignments() {
          const currentBaseURL = baseURL;
          const d = new Date();
          const ds = `${d.getMonth() + 1}/${d.getDate()}/${d.getFullYear()}`;
          const schedUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetScheduleVehicleCalendarByDateAndRoute?dateString=${encodeURIComponent(ds)}`;
          fetch(schedUrl)
              .then(response => response.json())
              .then(sched => {
                  if (currentBaseURL !== baseURL) return;
                  const ids = (sched || []).map(s => s.ScheduleVehicleCalendarID).join(',');
                  if (!ids) {
                      busBlocks = {};
                      return;
                  }
                  const blockUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetDispatchBlockGroupData?scheduleVehicleCalendarIdsString=${ids}`;
                  return fetch(blockUrl).then(r => r.json());
              })
              .then(data => {
                  if (currentBaseURL !== baseURL || !data) return;
                  const groups = data?.BlockGroups || [];
                  const alias = {
                      "[01]": "[01]/[04]",
                      "[03]": "[05]/[03]",
                      "[04]": "[01]/[04]",
                      "[05]": "[05]/[03]",
                      "[06]": "[22]/[06]",
                      "[10]": "[20]/[10]",
                      "[15]": "[26]/[15]",
                      "[16] AM": "[21]/[16] AM",
                      "[17]": "[23]/[17]",
                      "[18] AM": "[24]/[18] AM",
                      "[20] AM": "[20]/[10]",
                      "[21] AM": "[21]/[16] AM",
                      "[22] AM": "[22]/[06]",
                      "[23]": "[23]/[17]",
                      "[24] AM": "[24]/[18] AM",
                      "[26] AM": "[26]/[15]"
                  };
                  let mapping = {};
                  groups.forEach(g => {
                      const block = (g.BlockGroupId || '').trim();
                      const vehicleId = g.Blocks?.[0]?.Trips?.[0]?.VehicleID ?? g.VehicleId;
                      if (block && block.includes('[') && vehicleId != null) {
                          mapping[vehicleId] = alias[block] || block;
                      }
                  });
                  busBlocks = mapping;
              })
              .catch(error => console.error("Error fetching block assignments:", error));
      }

      function fetchBusLocations() {
          const currentBaseURL = baseURL;
          const apiUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetMapVehiclePoints?APIKey=8882812681&returnVehiclesNotAssignedToRoute=true`;
          return fetch(apiUrl)
              .then(response => {
                  if (!response.ok) throw new Error("Network response was not ok: " + response.statusText);
                  return response.json();
              })
              .then(data => {
                  if (currentBaseURL !== baseURL) return;
                  if (Array.isArray(data)) {
                      let currentBusData = {};
                      let activeRoutesSet = new Set();
                      let vehicles = [];

                      // First pass: gather vehicles and determine active routes.
                      data.forEach(vehicle => {
                          const vehicleID = vehicle.VehicleID;
                          const newPosition = [vehicle.Latitude, vehicle.Longitude];
                          const isMoving = vehicle.GroundSpeed > 0;
                          const busName = vehicle.Name;
                          let routeID = vehicle.RouteID;
                          if (!routeID && adminMode) {
                              routeID = 0;
                          } else if (!routeID) {
                              return;
                          }
                          const numericRouteId = Number(routeID);
                          const effectiveRouteId = Number.isNaN(numericRouteId) ? routeID : numericRouteId;
                          if (!canDisplayRoute(effectiveRouteId)) return;
                          if (!adminMode && !routeColors.hasOwnProperty(effectiveRouteId)) return;
                          activeRoutesSet.add(effectiveRouteId);
                          vehicles.push({
                              vehicleID,
                              newPosition,
                              isMoving,
                              busName,
                              routeID: effectiveRouteId,
                              heading: vehicle.Heading,
                              groundSpeed: vehicle.GroundSpeed
                          });
                      });

                      // Update global activeRoutes and rebuild selector before rendering.
                      activeRoutes = activeRoutesSet;
                      updateRouteSelector(activeRoutesSet);

                      // Second pass: render only selected routes.
                      vehicles.forEach(v => {
                          const { vehicleID, newPosition, isMoving, busName, routeID, heading, groundSpeed } = v;
                          if (!isRouteSelected(routeID)) return;
                          currentBusData[vehicleID] = true;
                          const svgIcon = `
                              <svg width="40" height="80" viewBox="0 0 40 80" xmlns="http://www.w3.org/2000/svg">
                                <g>
                                  <circle cx="20" cy="20" r="15" fill="${getRouteColor(routeID)}" stroke="white" stroke-width="3" />
                                  ${isMoving ? `
                                    <line x1="20" y1="10" x2="20" y2="22" stroke="${getContrastColor(getRouteColor(routeID))}" stroke-width="4" stroke-linecap="round" style="transform: rotate(${heading + 180}deg); transform-origin: 20px 20px" />
                                    <polygon points="15,22 25,22 20,30" fill="${getContrastColor(getRouteColor(routeID))}" style="transform: rotate(${heading + 180}deg); transform-origin: 20px 20px" />
                                  ` : `
                                    <rect x="14" y="14" width="12" height="12" fill="${getContrastColor(getRouteColor(routeID))}" />
                                  `}
                                </g>
                              </svg>`;
                          const busIcon = L.divIcon({
                              html: svgIcon,
                              className: '',
                              iconSize: [40, 40],
                              iconAnchor: [20, 20]
                          });
                          if (markers[vehicleID]) {
                              animateMarkerTo(markers[vehicleID], newPosition);
                              markers[vehicleID].setIcon(busIcon);
                              markers[vehicleID].routeID = routeID;
                          } else {
                              markers[vehicleID] = L.marker(newPosition, { icon: busIcon });
                              markers[vehicleID].routeID = routeID;
                              markers[vehicleID].addTo(map);
                          }
                          if (adminMode && showSpeed && !kioskMode) {
                              const speedBubble = `
                                  <svg width="60" height="20" viewBox="0 0 60 20" xmlns="http://www.w3.org/2000/svg">
                                      <g>
                                          <rect x="0" y="0" width="60" height="20" rx="10" ry="10" fill="${getRouteColor(routeID)}" stroke="white" stroke-width="3" />
                                          <text x="30" y="15" font-size="12" font-weight="bold" text-anchor="middle" fill="${getContrastColor(getRouteColor(routeID))}" font-family="FGDC">${Math.round(groundSpeed)} MPH</text>
                                      </g>
                                  </svg>`;
                              const speedIcon = L.divIcon({
                                  html: speedBubble,
                                  className: '',
                                  iconSize: [60, 20],
                                  iconAnchor: [30, -15]
                              });
                              if (nameBubbles[vehicleID] && nameBubbles[vehicleID].speedMarker) {
                                  animateMarkerTo(nameBubbles[vehicleID].speedMarker, newPosition);
                                  nameBubbles[vehicleID].speedMarker.setIcon(speedIcon);
                              } else {
                                  nameBubbles[vehicleID] = nameBubbles[vehicleID] || {};
                                  nameBubbles[vehicleID].speedMarker = L.marker(newPosition, { icon: speedIcon, interactive: false }).addTo(map);
                              }
                          } else {
                              if (nameBubbles[vehicleID] && nameBubbles[vehicleID].speedMarker) {
                                  map.removeLayer(nameBubbles[vehicleID].speedMarker);
                                  delete nameBubbles[vehicleID].speedMarker;
                              }
                          }
                          if (adminMode && !kioskMode) {
                              const bubbleWidth = Math.max(40, busName.length * 10);
                              const nameBubble = `
                                  <svg width="${bubbleWidth}" height="30" viewBox="0 0 ${bubbleWidth} 30" xmlns="http://www.w3.org/2000/svg">
                                      <g>
                                          <rect x="0" y="5" width="${bubbleWidth}" height="20" rx="10" ry="10" fill="${getRouteColor(routeID)}" stroke="white" stroke-width="3" />
                                          <text x="${bubbleWidth / 2}" y="20" font-size="14" font-weight="bold" text-anchor="middle" fill="${getContrastColor(getRouteColor(routeID))}" font-family="FGDC">${busName}</text>
                                      </g>
                                  </svg>`;
                              const nameIcon = L.divIcon({
                                  html: nameBubble,
                                  className: '',
                                  iconSize: [bubbleWidth, 30],
                                  iconAnchor: [bubbleWidth / 2, 40]
                              });
                              if (nameBubbles[vehicleID] && nameBubbles[vehicleID].nameMarker) {
                                  animateMarkerTo(nameBubbles[vehicleID].nameMarker, newPosition);
                                  nameBubbles[vehicleID].nameMarker.setIcon(nameIcon);
                              } else {
                                  nameBubbles[vehicleID] = nameBubbles[vehicleID] || {};
                                  nameBubbles[vehicleID].nameMarker = L.marker(newPosition, { icon: nameIcon, interactive: false }).addTo(map);
                              }

                              const blockName = busBlocks[vehicleID];
                              if (showBlockNumbers && blockName && blockName.includes('[')) {
                                  const canvas = document.createElement('canvas');
                                  const ctx = canvas.getContext('2d');
                                  ctx.font = 'bold 14px FGDC';
                                  const textWidth = ctx.measureText(blockName).width;
                                  const blockWidth = Math.max(40, textWidth + 20);
                                  const blockBubble = `
                                      <svg width="${blockWidth}" height="30" viewBox="0 0 ${blockWidth} 30" xmlns="http://www.w3.org/2000/svg">
                                          <g>
                                              <rect x="0" y="5" width="${blockWidth}" height="20" rx="10" ry="10" fill="${getRouteColor(routeID)}" stroke="white" stroke-width="3" />
                                              <text x="${blockWidth / 2}" y="20" font-size="14" font-weight="bold" text-anchor="middle" fill="${getContrastColor(getRouteColor(routeID))}" font-family="FGDC">${blockName}</text>
                                          </g>
                                      </svg>`;
                                  const blockIcon = L.divIcon({
                                      html: blockBubble,
                                      className: '',
                                      iconSize: [blockWidth, 30],
                                      // Position the block number bubble so it touches but doesn't overlap the bus icon
                                      iconAnchor: [blockWidth / 2, -13]
                                  });
                                  if (nameBubbles[vehicleID] && nameBubbles[vehicleID].blockMarker) {
                                      animateMarkerTo(nameBubbles[vehicleID].blockMarker, newPosition);
                                      nameBubbles[vehicleID].blockMarker.setIcon(blockIcon);
                                  } else {
                                      nameBubbles[vehicleID] = nameBubbles[vehicleID] || {};
                                      nameBubbles[vehicleID].blockMarker = L.marker(newPosition, { icon: blockIcon, interactive: false }).addTo(map);
                                  }
                              } else {
                                  if (nameBubbles[vehicleID] && nameBubbles[vehicleID].blockMarker) {
                                      map.removeLayer(nameBubbles[vehicleID].blockMarker);
                                      delete nameBubbles[vehicleID].blockMarker;
                                  }
                              }
                          } else {
                              if (nameBubbles[vehicleID] && nameBubbles[vehicleID].nameMarker) {
                                  map.removeLayer(nameBubbles[vehicleID].nameMarker);
                                  delete nameBubbles[vehicleID].nameMarker;
                              }
                              if (nameBubbles[vehicleID] && nameBubbles[vehicleID].blockMarker) {
                                  map.removeLayer(nameBubbles[vehicleID].blockMarker);
                                  delete nameBubbles[vehicleID].blockMarker;
                              }
                          }
                      });

                      Object.keys(markers).forEach(vehicleID => {
                          if (!currentBusData[vehicleID] || !isRouteSelected(markers[vehicleID].routeID)) {
                              map.removeLayer(markers[vehicleID]);
                              delete markers[vehicleID];
                              if (nameBubbles[vehicleID]) {
                                  if (nameBubbles[vehicleID].speedMarker) map.removeLayer(nameBubbles[vehicleID].speedMarker);
                                  if (nameBubbles[vehicleID].nameMarker) map.removeLayer(nameBubbles[vehicleID].nameMarker);
                                  if (nameBubbles[vehicleID].blockMarker) map.removeLayer(nameBubbles[vehicleID].blockMarker);
                                  delete nameBubbles[vehicleID];
                              }
                          }
                      });
                      previousBusData = currentBusData;
                  }
              })
              .catch(error => console.error("Error fetching bus locations:", error));
      }

      function getContrastColor(hexColor) {
          hexColor = hexColor.replace('#', '');
          const r = parseInt(hexColor.substring(0, 2), 16);
          const g = parseInt(hexColor.substring(2, 4), 16);
          const b = parseInt(hexColor.substring(4, 6), 16);
          const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
          return luminance > 0.565 ? 'black' : 'white';
      }

      function animateMarkerTo(marker, newPosition) {
        const startPos = marker.getLatLng();
        const endPos = L.latLng(newPosition);
        const duration = 1000;
        const startTime = performance.now();
        function animate(time) {
          const elapsed = time - startTime;
          const t = Math.min(elapsed / duration, 1);
          const currentPos = L.latLng(
            startPos.lat + t * (endPos.lat - startPos.lat),
            startPos.lng + t * (endPos.lng - startPos.lng)
          );
          marker.setLatLng(currentPos);
          if (t < 1) requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);
      }

      document.addEventListener("DOMContentLoaded", () => {
        loadAgencies().then(() => {
          initMap();
          showCookieBanner();
        });
      });
    </script>
  </head>
  <body>
    <div id="map"></div>
    <div id="routeLegend" aria-live="polite"></div>
    <div id="routeSelector"></div>
    <div id="routeSelectorTab" onclick="togglePanel()">&#9664;</div>
    <div class="credit">proof of concept created by pat cox â€¢ phc6j@virginia.edu</div>
    <div id="cookieBanner" class="cookie-banner" style="display:none;">
      This site stores your selected transit agency on your device to remember your preference.
      <button id="cookieAccept">OK</button>
    </div>
  </body>
</html>
