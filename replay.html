<!DOCTYPE html>
<html>
<head>
  <title>Replay Map - Headway Guard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@mapbox/polyline@1.1.1"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <style>
    @font-face {
      font-family: 'FGDC';
      src: url('FGDC.ttf') format('truetype');
    }
    :root {
      --navy: #232D4B;
      --navy-dark: #1b274a;
      --navy-darker: #1a2441;
      --panel-surface: linear-gradient(180deg, rgba(255, 255, 255, 0.96), rgba(245, 248, 255, 0.96));
      --panel-border-color: rgba(35, 45, 75, 0.12);
      --panel-shadow: 0 20px 45px rgba(15, 23, 42, 0.25);
      --panel-highlight: rgba(35, 45, 75, 0.06);
      --panel-text-color: #1f2937;
      --panel-heading-color: #232D4B;
      --panel-muted-text: #4b5563;
      --accent: #E57200;
      --accent-bright: #ff9c3e;
      --accent-soft: rgba(229, 114, 0, 0.28);
      --controls-height: 180px;
    }
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: 'FGDC', sans-serif;
      background: linear-gradient(180deg, #e2e8f0, #f8fafc);
      color: var(--panel-text-color);
      overflow: hidden;
    }
    #map {
      height: 100%;
      width: 100%;
    }
    #controls.playback-controls {
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      width: min(1120px, calc(100% - 32px));
      background: var(--panel-surface);
      border-radius: 18px;
      border: 1px solid var(--panel-border-color);
      box-shadow: var(--panel-shadow);
      padding: 18px 20px 20px;
      display: flex;
      flex-direction: column;
      gap: 18px;
      z-index: 1200;
      backdrop-filter: blur(12px);
      box-sizing: border-box;
      transition: transform 0.35s ease, opacity 0.3s ease;
    }
    #controlsToggle {
      display: none;
    }
    .controls-row {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: center;
      justify-content: center;
    }
    .controls-row--filters {
      justify-content: flex-start;
    }
    .control-field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 140px;
      flex: 1 1 160px;
    }
    .control-field--button {
      flex: 0 0 auto;
      align-self: flex-end;
    }
    #controls label,
    .control-field label,
    .timeline-label {
      text-transform: uppercase;
      letter-spacing: 1.4px;
      font-size: 12px;
      color: rgba(35, 45, 75, 0.7);
    }
    .control-field input {
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid rgba(35, 45, 75, 0.25);
      background: rgba(255, 255, 255, 0.92);
      font-size: 16px;
      font-family: 'FGDC', sans-serif;
      box-shadow: 0 6px 18px rgba(17, 24, 39, 0.1);
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .control-field input:focus {
      outline: none;
      border-color: rgba(229, 114, 0, 0.8);
      box-shadow: 0 0 0 3px rgba(229, 114, 0, 0.2);
    }
    .speed-button-group {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
      align-items: center;
    }
    .speed-button-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .pill-button {
      border: none;
      border-radius: 999px;
      background: linear-gradient(135deg, rgba(35, 45, 75, 0.92), rgba(27, 39, 74, 0.92));
      color: #f8fafc;
      padding: 10px 18px;
      font-family: 'FGDC', sans-serif;
      font-weight: 600;
      font-size: 14px;
      letter-spacing: 0.3px;
      cursor: pointer;
      box-shadow: 0 12px 24px rgba(15, 23, 42, 0.25);
      transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }
    .pill-button:hover {
      transform: translateY(-1px);
      box-shadow: 0 16px 32px rgba(15, 23, 42, 0.28);
    }
    .pill-button:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px var(--accent-soft), 0 16px 32px rgba(15, 23, 42, 0.28);
    }
    .pill-button:active {
      transform: translateY(0);
      box-shadow: 0 8px 16px rgba(15, 23, 42, 0.2);
    }
    .pill-button.accent {
      background: linear-gradient(135deg, var(--accent), var(--accent-bright));
      color: #1f1300;
      box-shadow: 0 12px 24px rgba(229, 114, 0, 0.35);
    }
    .pill-button.accent:hover {
      box-shadow: 0 16px 30px rgba(229, 114, 0, 0.4);
    }
    .pill-button.is-active {
      background: linear-gradient(135deg, var(--accent), var(--accent-bright));
      color: #1f1300;
      box-shadow: 0 16px 30px rgba(229, 114, 0, 0.45);
    }
    .pill-button.is-active:hover {
      box-shadow: 0 20px 36px rgba(229, 114, 0, 0.48);
    }
    .timeline-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
      width: 100%;
    }
    #timeline {
      width: 100%;
      accent-color: var(--accent);
    }
    .timeline-value {
      font-size: 14px;
      letter-spacing: 0.3px;
      text-align: center;
      color: var(--panel-heading-color);
    }
    .selector-panel {
      width: 360px;
      position: fixed;
      top: 16px;
      bottom: calc(var(--controls-height) + 24px);
      z-index: 1100;
      background: var(--panel-surface);
      border-radius: 18px;
      border: 1px solid var(--panel-border-color);
      box-shadow: var(--panel-shadow);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      backdrop-filter: blur(12px);
      transition: transform 0.35s ease, box-shadow 0.3s ease, opacity 0.3s ease;
      font-size: 16px;
      color: var(--panel-text-color);
    }
    #busSelector {
      left: 16px;
    }
    #routeSelector {
      right: 16px;
    }
    #busSelector.hidden {
      transform: translateX(calc(-100% - 24px));
      opacity: 0;
      pointer-events: none;
    }
    #routeSelector.hidden {
      transform: translateX(calc(100% + 24px));
      opacity: 0;
      pointer-events: none;
    }
    .selector-panel .selector-header {
      background: linear-gradient(135deg, var(--navy), var(--navy-dark));
      color: #f8fafc;
      padding: 16px 20px 18px;
      box-shadow: inset 0 -1px 0 rgba(255, 255, 255, 0.08);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .selector-panel .selector-title {
      margin: 0;
      font-size: 22px;
      letter-spacing: 0.4px;
    }
    .selector-panel .selector-subtitle {
      margin: 0;
      font-size: 13px;
      opacity: 0.75;
      letter-spacing: 0.3px;
    }
    .selector-panel .selector-content {
      flex: 1;
      min-height: 0;
      overflow-y: auto;
      padding: 18px 20px 22px;
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    .selector-panel .selector-content::-webkit-scrollbar {
      width: 8px;
    }
    .selector-panel .selector-content::-webkit-scrollbar-track {
      background: rgba(35, 45, 75, 0.08);
      border-radius: 12px;
    }
    .selector-panel .selector-content::-webkit-scrollbar-thumb {
      background: rgba(35, 45, 75, 0.35);
      border-radius: 12px;
    }
    .selector-panel .selector-content::-webkit-scrollbar-thumb:hover {
      background: rgba(229, 114, 0, 0.6);
    }
    .selector-panel .selector-group {
      background: var(--panel-highlight);
      border-radius: 14px;
      padding: 14px 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .selector-panel .selector-section {
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    .selector-panel .selector-label {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 1.6px;
      color: rgba(35, 45, 75, 0.75);
    }
    .display-mode-group {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    .display-mode-group .pill-button {
      flex: 1 1 auto;
      text-align: center;
    }
    .route-action-buttons {
      justify-content: stretch;
    }
    .selector-panel .route-list,
    .selector-panel .selector-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .selector-panel label.route-option,
    .selector-panel label.selector-option {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      padding: 12px 14px;
      background: var(--panel-highlight);
      border-radius: 14px;
      border: 1px solid transparent;
      transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease, background-color 0.2s ease;
      cursor: pointer;
    }
    .selector-panel label.route-option:hover,
    .selector-panel label.selector-option:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 26px rgba(15, 23, 42, 0.12);
      border-color: rgba(35, 45, 75, 0.25);
    }
    .selector-panel label.route-option.is-active,
    .selector-panel label.selector-option.is-active {
      background: rgba(229, 114, 0, 0.16);
      border-color: rgba(229, 114, 0, 0.45);
      box-shadow: 0 16px 32px rgba(229, 114, 0, 0.24);
    }
    .selector-panel label.route-option--out {
      background: rgba(35, 45, 75, 0.08);
    }
    .selector-panel label.route-option input[type="checkbox"],
    .selector-panel label.selector-option input[type="checkbox"] {
      margin-top: 2px;
      width: 18px;
      height: 18px;
      accent-color: var(--accent);
      flex-shrink: 0;
      cursor: pointer;
    }
    .selector-panel .route-option-swatch {
      display: inline-flex;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      margin-top: 2px;
      border: 2px solid rgba(255, 255, 255, 0.9);
      box-shadow: 0 0 0 1px rgba(35, 45, 75, 0.2);
      flex-shrink: 0;
    }
    .selector-panel label.route-option input[type="checkbox"]:checked + .route-option-swatch {
      transform: scale(1.1);
      box-shadow: 0 0 0 2px rgba(229, 114, 0, 0.4);
    }
    .selector-panel .route-option-text,
    .selector-panel .selector-option-text {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 15px;
      line-height: 1.3;
    }
    .selector-panel .route-option-name,
    .selector-panel .selector-option-name {
      font-weight: 600;
      letter-spacing: 0.2px;
      color: var(--panel-heading-color);
    }
    .selector-panel .route-option-detail,
    .selector-panel .selector-option-detail {
      font-size: 13px;
      color: var(--panel-muted-text);
    }
    .panel-toggle {
      position: fixed;
      top: 50%;
      width: 34px;
      height: 70px;
      background: linear-gradient(180deg, var(--navy), var(--navy-darker));
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transform: translateY(-50%);
      z-index: 1150;
      text-align: center;
      font-size: 22px;
      user-select: none;
      transition: left 0.3s ease, right 0.3s ease, background 0.3s ease, box-shadow 0.3s ease;
      color: #f8fafc;
      box-shadow: 0 12px 28px rgba(15, 23, 42, 0.25);
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
    }
    .panel-toggle--left {
      left: 0;
      border-top-right-radius: 14px;
      border-bottom-right-radius: 14px;
    }
    .panel-toggle--right {
      right: 0;
      border-top-left-radius: 14px;
      border-bottom-left-radius: 14px;
    }
    .panel-toggle:hover {
      background: linear-gradient(180deg, #2d3a5e, #253355);
      box-shadow: 0 16px 32px rgba(15, 23, 42, 0.3);
    }
    .panel-toggle:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px var(--accent-soft), 0 16px 32px rgba(15, 23, 42, 0.3);
    }
    #disclaimerOverlay {
      position: fixed;
      inset: 0;
      background: rgba(35, 45, 75, 0.75);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2000;
    }
    #disclaimerBox {
      background: var(--panel-surface);
      padding: 28px 32px;
      border-radius: 18px;
      max-width: 640px;
      text-align: center;
      font-size: 18px;
      box-shadow: 0 24px 48px rgba(15, 23, 42, 0.35);
      border: 1px solid var(--panel-border-color);
      color: var(--panel-heading-color);
      letter-spacing: 0.2px;
      line-height: 1.5;
    }
    #disclaimerBox p {
      margin-bottom: 24px;
    }
    #disclaimerBtn {
      padding: 12px 26px;
      font-size: 18px;
      font-family: 'FGDC', sans-serif;
      background: linear-gradient(135deg, var(--accent), var(--accent-bright));
      color: #1f1300;
      border: none;
      border-radius: 999px;
      cursor: pointer;
      box-shadow: 0 16px 30px rgba(229, 114, 0, 0.4);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    #disclaimerBtn:hover {
      transform: translateY(-1px);
      box-shadow: 0 20px 36px rgba(229, 114, 0, 0.45);
    }
    #disclaimerBtn:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px var(--accent-soft), 0 20px 36px rgba(229, 114, 0, 0.45);
    }
    .loading-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(71, 85, 105, 0.55);
      color: #f1f5f9;
      font-family: 'FGDC', sans-serif;
      font-size: 18px;
      letter-spacing: 0.3rem;
      text-transform: uppercase;
      z-index: 3000;
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
      transition: opacity 0.25s ease, visibility 0.25s ease;
      backdrop-filter: blur(2px);
    }
    .loading-overlay.is-visible {
      opacity: 1;
      visibility: visible;
      pointer-events: all;
    }
    .loading-overlay__inner {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
    }
    .loading-overlay__spinner {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      border: 4px solid rgba(241, 245, 249, 0.35);
      border-top-color: #f8fafc;
      animation: loading-overlay-spin 1s linear infinite;
    }
    .loading-overlay__text {
      font-size: 16px;
      letter-spacing: 0.35rem;
    }
    @keyframes loading-overlay-spin {
      from {
        transform: rotate(0deg);
      }
      to {
        transform: rotate(360deg);
      }
    }
    @media (max-width: 1024px) {
      #controls.playback-controls {
        width: calc(100% - 32px);
      }
      .control-field {
        flex: 1 1 140px;
      }
    }
    @media (max-width: 720px) {
      #controls.playback-controls {
        gap: 8px;
        max-height: calc(100vh - 120px);
        overflow-y: auto;
        padding: 14px 14px 16px;
        scrollbar-width: thin;
        scrollbar-color: rgba(35, 45, 75, 0.35) transparent;
        -webkit-overflow-scrolling: touch;
      }
      #controls.playback-controls::-webkit-scrollbar {
        width: 6px;
      }
      #controls.playback-controls::-webkit-scrollbar-thumb {
        background: rgba(35, 45, 75, 0.35);
        border-radius: 999px;
      }
      .controls-row {
        flex-direction: column;
        align-items: stretch;
        gap: 6px;
      }
      .control-field {
        width: 100%;
        gap: 4px;
      }
      .control-field input {
        padding: 9px 12px;
        font-size: 15px;
      }
      .control-field--button {
        align-self: stretch;
      }
      .control-field--button .pill-button {
        width: 100%;
      }
      .speed-button-group {
        flex-direction: column;
        align-items: center;
        gap: 10px;
      }
      .speed-button-row {
        width: 100%;
        justify-content: center;
        flex-wrap: wrap;
        gap: 8px;
      }
      .speed-button-row .pill-button {
        flex: 0 0 auto;
      }
      #controls.playback-controls.is-collapsed {
        transform: translateX(-50%) translateY(calc(100% + 24px));
        opacity: 0;
        pointer-events: none;
      }
      #controlsToggle {
        position: fixed;
        left: 50%;
        bottom: calc(var(--controls-height) + 24px);
        transform: translateX(-50%);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 10px 18px;
        border-radius: 999px;
        border: none;
        font-family: 'FGDC', sans-serif;
        font-size: 14px;
        font-weight: 600;
        letter-spacing: 0.3px;
        color: #f8fafc;
        background: linear-gradient(135deg, var(--navy), var(--navy-dark));
        box-shadow: 0 12px 24px rgba(15, 23, 42, 0.25);
        cursor: pointer;
        z-index: 1250;
        transition: background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease, transform 0.3s ease;
      }
      #controlsToggle:hover {
        box-shadow: 0 16px 30px rgba(15, 23, 42, 0.28);
      }
      #controlsToggle:focus-visible {
        outline: none;
        box-shadow: 0 0 0 3px var(--accent-soft), 0 16px 30px rgba(15, 23, 42, 0.3);
      }
      body.controls-collapsed #controlsToggle {
        bottom: 16px;
        color: #1f1300;
        background: linear-gradient(135deg, var(--accent), var(--accent-bright));
        box-shadow: 0 12px 24px rgba(229, 114, 0, 0.35);
      }
      body.controls-collapsed #controlsToggle:hover {
        box-shadow: 0 16px 32px rgba(229, 114, 0, 0.4);
      }
      body.controls-collapsed #controlsToggle:focus-visible {
        box-shadow: 0 0 0 3px var(--accent-soft), 0 16px 32px rgba(229, 114, 0, 0.4);
      }
      .panel-toggle {
        width: 40px;
        height: 80px;
        font-size: 26px;
      }
      .selector-panel {
        width: calc(100% - 32px);
        left: 16px;
        right: 16px;
      }
      #busSelector,
      #routeSelector {
        left: 16px;
        right: 16px;
      }
      #busSelector.hidden {
        transform: translateX(calc(-100% - 20px));
      }
      #routeSelector.hidden {
        transform: translateX(calc(100% + 20px));
      }
    }
  </style>
</head>
<body>
  <div id="disclaimerOverlay">
    <div id="disclaimerBox">
      <p>Information on this page is only as accurate as information received from TransLoc, and may not be correct. This page should only be used for initial investigations following a report of an issue. Any information should be verified via camera footage.</p>
      <button id="disclaimerBtn">10-4</button>
    </div>
  </div>
  <div id="map"></div>
  <div id="busSelector" class="selector-panel hidden" aria-live="polite"></div>
  <div id="busSelectorTab" class="panel-toggle panel-toggle--left" onclick="toggleBusPanel()" title="Toggle vehicle selector">&#9664;</div>
  <div id="routeSelector" class="selector-panel hidden" aria-live="polite"></div>
  <div id="routeSelectorTab" class="panel-toggle panel-toggle--right" onclick="toggleRoutePanel()" title="Toggle route selector">&#9654;</div>
  <div id="controls" class="playback-controls">
    <div class="controls-row controls-row--filters">
      <div class="control-field">
        <label for="datePicker">Date</label>
        <input id="datePicker" placeholder="Date">
      </div>
      <div class="control-field">
        <label for="startTime">From</label>
        <input id="startTime" placeholder="Start time">
      </div>
      <div class="control-field">
        <label for="endTime">To</label>
        <input id="endTime" placeholder="End time">
      </div>
      <div class="control-field control-field--button">
        <button id="loadRangeBtn" type="button" class="pill-button accent">Load Range</button>
      </div>
    </div>
    <div class="controls-row controls-row--playback">
      <div class="speed-button-group">
        <div class="speed-button-row speed-button-row--primary">
          <button id="pauseBtn" type="button" class="pill-button speed-btn" title="Pause">&#10074;&#10074;</button>
          <button id="playBtn" type="button" class="pill-button speed-btn">1x</button>
          <button id="ff2Btn" type="button" class="pill-button speed-btn">2x</button>
          <button id="ff4Btn" type="button" class="pill-button speed-btn">4x</button>
          <button id="ff8Btn" type="button" class="pill-button speed-btn">8x</button>
          <button id="ff10Btn" type="button" class="pill-button speed-btn">10x</button>
        </div>
        <div class="speed-button-row speed-button-row--extended">
          <button id="ff30Btn" type="button" class="pill-button speed-btn">30x</button>
          <button id="ff100Btn" type="button" class="pill-button speed-btn">100x</button>
          <button id="ff200Btn" type="button" class="pill-button speed-btn">200x</button>
          <button id="ff500Btn" type="button" class="pill-button speed-btn">500x</button>
          <button id="ff1000Btn" type="button" class="pill-button speed-btn">1000x</button>
        </div>
      </div>
      <div class="timeline-group">
        <label for="timeline" class="timeline-label">Replay Timeline</label>
        <input type="range" id="timeline" min="0" value="0">
        <span id="timeLabel" class="timeline-value"></span>
      </div>
    </div>
  </div>
  <button id="controlsToggle" type="button" aria-controls="controls" aria-expanded="true">Hide Controls</button>
  <div id="loadingOverlay" class="loading-overlay" aria-live="polite" aria-busy="false">
    <div class="loading-overlay__inner">
      <div class="loading-overlay__spinner" aria-hidden="true"></div>
      <div class="loading-overlay__text">Loading range</div>
    </div>
  </div>
  <script>
    let map = L.map('map', { zoomControl: false }).setView([38.03799212281404, -78.50981502838886], 15);
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    flatpickr("#datePicker", {
      dateFormat: "Y-m-d",
      defaultDate: new Date().toLocaleDateString('en-CA', { timeZone: 'America/New_York' })
    });
    flatpickr("#startTime", {
      enableTime: true,
      noCalendar: true,
      dateFormat: "H:i",
      time_24hr: true,
      defaultDate: "00:00"
    });
    flatpickr("#endTime", {
      enableTime: true,
      noCalendar: true,
      dateFormat: "H:i",
      time_24hr: true,
      defaultDate: "23:59"
    });

    let playbackData = [];
    let playbackTimes = [];
    let startTime = null;
    let endTime = null;
    let userEndTime = null;
    let loadedHours = new Set();
    let markers = {};
    let nameMarkers = {};
    let speedMarkers = {};
    let blockMarkers = {};
    let routeLayers = [];
    let timer = null;       // handle for scheduled frame advance
    let playbackSpeed = 1;  // 1x, 2x, 4x, 8x, 10x, 30x, 100x, 200x, 500x, 1000x
    let routeColors = {};
    let allRoutes = {};
    let routeSelections = {};
    let activeRoutes = new Set();
    let allBuses = {};
    let busSelections = {};
    let activeBuses = new Set();
    let showSpeed = true; // default to showing speed
    let showBlockNumbers = false;
    let showNameBubbles = true;
    let lastPositions = {};
    let currentFrameIndex = 0;
    const outOfServiceRouteColor = '#000000';
    let isPlaying = false;
    const playBtn = document.getElementById('playBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const ff2Btn = document.getElementById('ff2Btn');
    const ff4Btn = document.getElementById('ff4Btn');
    const ff8Btn = document.getElementById('ff8Btn');
    const ff10Btn = document.getElementById('ff10Btn');
    const ff30Btn = document.getElementById('ff30Btn');
    const ff100Btn = document.getElementById('ff100Btn');
    const ff200Btn = document.getElementById('ff200Btn');
    const ff500Btn = document.getElementById('ff500Btn');
    const ff1000Btn = document.getElementById('ff1000Btn');
    const controlsContainer = document.getElementById('controls');
    const controlsToggleButton = document.getElementById('controlsToggle');
    let controlsCollapsed = false;
    const controlsViewportQuery = window.matchMedia ? window.matchMedia('(max-width: 720px)') : null;
    let activeRangeLoadCount = 0;
    let lastRouteSelectorStateKey = null;
    let lastBusSelectorStateKey = null;

    function showLoadingOverlay() {
      const overlay = document.getElementById('loadingOverlay');
      if (!overlay) return;
      overlay.classList.add('is-visible');
      overlay.setAttribute('aria-busy', 'true');
    }

    function hideLoadingOverlay() {
      const overlay = document.getElementById('loadingOverlay');
      if (!overlay) return;
      overlay.classList.remove('is-visible');
      overlay.setAttribute('aria-busy', 'false');
    }

    function beginRangeLoad() {
      activeRangeLoadCount += 1;
      showLoadingOverlay();
    }

    function completeRangeLoad() {
      activeRangeLoadCount = Math.max(0, activeRangeLoadCount - 1);
      if (activeRangeLoadCount === 0) {
        hideLoadingOverlay();
      }
    }

    function positionPanelTab(panelId, tabId, side = 'right') {
      const panel = document.getElementById(panelId);
      const tab = document.getElementById(tabId);
      if (!panel || !tab) return;

      const panelRect = panel.getBoundingClientRect();
      const tabRect = tab.getBoundingClientRect();
      const viewportHeight = window.innerHeight || document.documentElement.clientHeight || 0;
      const tabHeight = tabRect.height || tab.offsetHeight || parseFloat(window.getComputedStyle(tab).height) || 0;

      if (Number.isFinite(panelRect?.top) && Number.isFinite(panelRect?.height)) {
        const panelCenter = panelRect.top + panelRect.height / 2;
        if (Number.isFinite(panelCenter)) {
          const halfTab = Number.isFinite(tabHeight) ? tabHeight / 2 : 0;
          let targetTop = panelCenter;
          if (Number.isFinite(viewportHeight) && halfTab > 0) {
            const minTop = halfTab + 8;
            const maxTop = viewportHeight - halfTab - 8;
            if (Number.isFinite(minTop) && Number.isFinite(maxTop)) {
              targetTop = Math.min(Math.max(panelCenter, minTop), Math.max(minTop, maxTop));
            }
          }
          if (Number.isFinite(targetTop)) {
            tab.style.top = `${targetTop}px`;
          }
        }
      }

      const panelStyle = window.getComputedStyle(panel);
      const gap = side === 'right'
        ? (parseFloat(panelStyle.right) || 0)
        : (parseFloat(panelStyle.left) || 0);
      const offset = panel.offsetWidth + gap;
      const viewportWidth = window.innerWidth || document.documentElement.clientWidth || 0;
      const tabWidth = tabRect.width || tab.offsetWidth || parseFloat(window.getComputedStyle(tab).width) || 0;

      if (side === 'right') {
        if (panel.classList.contains('hidden')) {
          tab.style.right = '0';
        } else {
          const maxRight = Math.max(0, viewportWidth - tabWidth);
          const clampedOffset = Math.min(offset, maxRight);
          tab.style.right = `${clampedOffset}px`;
        }
        tab.style.left = '';
      } else {
        if (panel.classList.contains('hidden')) {
          tab.style.left = '0';
        } else {
          const maxLeft = Math.max(0, viewportWidth - tabWidth);
          const clampedOffset = Math.min(offset, maxLeft);
          tab.style.left = `${clampedOffset}px`;
        }
        tab.style.right = '';
      }
    }

    function positionAllPanelTabs() {
      positionPanelTab('busSelector', 'busSelectorTab', 'left');
      positionPanelTab('routeSelector', 'routeSelectorTab', 'right');
    }

    function setControlsCollapsed(collapsed) {
      controlsCollapsed = collapsed;
      document.body.classList.toggle('controls-collapsed', collapsed);
      if (controlsContainer) {
        controlsContainer.classList.toggle('is-collapsed', collapsed);
        if (typeof controlsContainer.inert === 'boolean') {
          controlsContainer.inert = collapsed;
        } else if (collapsed) {
          controlsContainer.setAttribute('inert', '');
        } else {
          controlsContainer.removeAttribute('inert');
        }
        controlsContainer.setAttribute('aria-hidden', collapsed ? 'true' : 'false');
      }
      if (controlsToggleButton) {
        controlsToggleButton.setAttribute('aria-expanded', String(!collapsed));
        controlsToggleButton.textContent = collapsed ? 'Show Controls' : 'Hide Controls';
      }
      updateControlsHeight();
    }

    function updateControlsHeight() {
      const controls = controlsContainer || document.getElementById('controls');
      if (!controls) return;
      if (controls.classList.contains('is-collapsed')) {
        document.documentElement.style.setProperty('--controls-height', '0px');
      } else {
        const height = controls.offsetHeight;
        document.documentElement.style.setProperty('--controls-height', `${height}px`);
      }
      positionAllPanelTabs();
    }

    window.addEventListener('load', () => {
      positionAllPanelTabs();
      updateControlsHeight();
      if (document.fonts && document.fonts.ready) {
        document.fonts.ready.then(() => {
          updateControlsHeight();
          positionAllPanelTabs();
        });
      }
    });
    window.addEventListener('resize', () => {
      positionAllPanelTabs();
      updateControlsHeight();
    });

    if (controlsToggleButton) {
      controlsToggleButton.addEventListener('click', () => {
        setControlsCollapsed(!controlsCollapsed);
      });

      const syncControlsForViewport = (event) => {
        const isMobile = event?.matches ?? (controlsViewportQuery ? controlsViewportQuery.matches : false);
        if (!isMobile && controlsCollapsed) {
          setControlsCollapsed(false);
        } else {
          setControlsCollapsed(controlsCollapsed);
        }
        if (controlsToggleButton) {
          controlsToggleButton.setAttribute('aria-hidden', isMobile ? 'false' : 'true');
          controlsToggleButton.tabIndex = isMobile ? 0 : -1;
        }
      };

      if (controlsViewportQuery) {
        syncControlsForViewport(controlsViewportQuery);
        if (typeof controlsViewportQuery.addEventListener === 'function') {
          controlsViewportQuery.addEventListener('change', syncControlsForViewport);
        } else if (typeof controlsViewportQuery.addListener === 'function') {
          controlsViewportQuery.addListener(syncControlsForViewport);
        }
      } else {
        setControlsCollapsed(false);
        controlsToggleButton.setAttribute('aria-hidden', 'true');
        controlsToggleButton.tabIndex = -1;
      }
    }

    function updateSpeedButtons() {
      playBtn.classList.remove('is-active');
      pauseBtn.classList.remove('is-active');
      ff2Btn.classList.remove('is-active');
      ff4Btn.classList.remove('is-active');
      ff8Btn.classList.remove('is-active');
      ff10Btn.classList.remove('is-active');
      ff30Btn.classList.remove('is-active');
      ff100Btn.classList.remove('is-active');
      ff200Btn.classList.remove('is-active');
      ff500Btn.classList.remove('is-active');
      ff1000Btn.classList.remove('is-active');
      if (!isPlaying) {
        pauseBtn.classList.add('is-active');
      } else if (playbackSpeed === 1) {
        playBtn.classList.add('is-active');
      } else if (playbackSpeed === 2) {
        ff2Btn.classList.add('is-active');
      } else if (playbackSpeed === 4) {
        ff4Btn.classList.add('is-active');
      } else if (playbackSpeed === 8) {
        ff8Btn.classList.add('is-active');
      } else if (playbackSpeed === 10) {
        ff10Btn.classList.add('is-active');
      } else if (playbackSpeed === 30) {
        ff30Btn.classList.add('is-active');
      } else if (playbackSpeed === 100) {
        ff100Btn.classList.add('is-active');
      } else if (playbackSpeed === 200) {
        ff200Btn.classList.add('is-active');
      } else if (playbackSpeed === 500) {
        ff500Btn.classList.add('is-active');
      } else if (playbackSpeed === 1000) {
        ff1000Btn.classList.add('is-active');
      }
    }

    function fetchRoutes() {
      return fetch('/v1/transloc/routes')
        .then(r => r.json())
        .then(data => {
          if (Array.isArray(data)) {
            data.forEach(route => {
              routeColors[route.RouteID] = route.MapLineColor;
              allRoutes[route.RouteID] = route;
              if (route.EncodedPolyline) {
                allRoutes[route.RouteID].decodedPolyline = polyline.decode(route.EncodedPolyline);
              }
            });
          }
        })
        .catch(err => console.error('Error fetching routes', err));
    }

    function getContrastColor(hexColor) {
      hexColor = hexColor.replace('#', '');
      const r = parseInt(hexColor.substring(0,2), 16);
      const g = parseInt(hexColor.substring(2,4), 16);
      const b = parseInt(hexColor.substring(4,6), 16);
      const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
      return luminance > 0.5 ? '#000000' : '#FFFFFF';
    }

    function getRouteColor(routeID) {
      if (routeID === 0) return outOfServiceRouteColor;
      return routeColors[routeID] || '#000000';
    }

    function isRouteSelected(routeID) {
      if (routeSelections.hasOwnProperty(routeID)) return routeSelections[routeID];
      return activeRoutes.has(Number(routeID));
    }

    function isBusSelected(busID) {
      if (busSelections.hasOwnProperty(busID)) return busSelections[busID];
      return activeBuses.has(Number(busID));
    }

    function refreshReplay() {
      const timeline = document.getElementById('timeline');
      const ms = parseInt(timeline.value);
      showFrame(currentFrameIndex, isNaN(ms) ? undefined : ms);
    }

    function setReplayDisplayMode(mode) {
      if (mode === 'block') {
        showSpeed = false;
        showBlockNumbers = true;
      } else if (mode === 'speed') {
        showSpeed = true;
        showBlockNumbers = false;
      } else if (mode === 'none') {
        showSpeed = false;
        showBlockNumbers = false;
      } else {
        return;
      }
      updateRouteSelector(activeRoutes, { force: true });
      refreshReplay();
    }

    function toggleSpeedOrBlock() {
      if (showSpeed) {
        setReplayDisplayMode('block');
      } else if (showBlockNumbers) {
        setReplayDisplayMode('none');
      } else {
        setReplayDisplayMode('speed');
      }
    }

    function toggleNameBubbles() {
      showNameBubbles = !showNameBubbles;
      updateRouteSelector(activeRoutes, { force: true });
      refreshReplay();
    }

    function applyBusOptionState(inputElement) {
      if (!inputElement || typeof inputElement.closest !== 'function') return;
      const parentLabel = inputElement.closest('label.selector-option');
      if (!parentLabel) return;
      parentLabel.classList.toggle('is-active', inputElement.checked);
    }

    function updateBusSelector(activeBusesSet, options) {
      const container = document.getElementById('busSelector');
      if (!container) return;

      options = options || {};
      const forceUpdate = options.force === true;

      const activeSet = activeBusesSet instanceof Set
        ? activeBusesSet
        : new Set(Array.isArray(activeBusesSet) ? activeBusesSet : []);

      const busIDs = Object.keys(allBuses)
        .map(id => Number(id))
        .filter(id => !Number.isNaN(id));

      busIDs.sort((a, b) => {
        const nameA = (allBuses[a] || `${a}`).toUpperCase();
        const nameB = (allBuses[b] || `${b}`).toUpperCase();
        if (nameA < nameB) return -1;
        if (nameA > nameB) return 1;
        return 0;
      });

      const activeSnapshot = Array.from(activeSet)
        .map(id => Number(id))
        .filter(id => !Number.isNaN(id))
        .sort((a, b) => a - b);
      const namesSnapshot = busIDs.map(id => allBuses[id] || '');
      const nextStateKey = JSON.stringify({
        ids: busIDs,
        active: activeSnapshot,
        names: namesSnapshot
      });

      if (!forceUpdate && nextStateKey === lastBusSelectorStateKey) {
        return;
      }

      const previousContent = container.querySelector('.selector-content');
      const previousScrollTop = previousContent ? previousContent.scrollTop : 0;

      let html = `
        <div class="selector-header">
          <div class="selector-title">Vehicle Filters</div>
          <div class="selector-subtitle">Pick the vehicles to follow during playback.</div>
        </div>
        <div class="selector-content">
          <div class="selector-section">
            <div class="selector-group">
              <div class="selector-label">Quick Select</div>
              <div class="display-mode-group route-action-buttons">
                <button type="button" class="pill-button" onclick="selectAllBuses()">Select All</button>
                <button type="button" class="pill-button" onclick="selectActiveBuses()">Select Active</button>
                <button type="button" class="pill-button" onclick="deselectAllBuses()">Deselect All</button>
              </div>
            </div>
      `;

      if (busIDs.length === 0) {
        html += `
            <div class="selector-group">
              <div class="selector-label">Vehicles</div>
              <div class="selector-option-detail">No vehicles detected in this frame.</div>
            </div>
          </div>
        </div>
        `;
      } else {
        html += `
            <div class="selector-group">
              <div class="selector-label">Vehicles</div>
              <div class="selector-list">
        `;
        busIDs.forEach(id => {
          const checked = Object.prototype.hasOwnProperty.call(busSelections, id)
            ? busSelections[id]
            : activeSet.has(id);
          const name = allBuses[id] || `Vehicle ${id}`;
          html += `
                <label class="selector-option ${checked ? 'is-active' : ''}">
                  <input type="checkbox" id="bus_${id}" value="${id}" ${checked ? 'checked' : ''}>
                  <span class="selector-option-text">
                    <span class="selector-option-name">${name}</span>
                  </span>
                </label>
          `;
        });
        html += `
              </div>
            </div>
          </div>
        </div>
        `;
      }

      container.innerHTML = html;

      const newContent = container.querySelector('.selector-content');
      if (newContent) {
        newContent.scrollTop = previousScrollTop;
      }

      busIDs.forEach(id => {
        const checkbox = document.getElementById(`bus_${id}`);
        if (checkbox) {
          checkbox.addEventListener('change', () => {
            busSelections[id] = checkbox.checked;
            applyBusOptionState(checkbox);
            refreshReplay();
          });
          applyBusOptionState(checkbox);
        }
      });

      lastBusSelectorStateKey = nextStateKey;
      positionAllPanelTabs();
    }

    function selectAllBuses() {
      Object.keys(allBuses).forEach(id => {
        const numericId = Number(id);
        if (Number.isNaN(numericId)) return;
        const checkbox = document.getElementById(`bus_${numericId}`);
        if (checkbox) {
          checkbox.checked = true;
          applyBusOptionState(checkbox);
        }
        busSelections[numericId] = true;
      });
      refreshReplay();
    }

    function selectActiveBuses() {
      const activeSet = activeBuses instanceof Set
        ? activeBuses
        : new Set(Array.isArray(activeBuses) ? activeBuses : []);

      Object.keys(allBuses).forEach(id => {
        const numericId = Number(id);
        if (Number.isNaN(numericId)) return;
        const checkbox = document.getElementById(`bus_${numericId}`);
        const shouldSelect = activeSet.has(numericId);
        if (checkbox) {
          checkbox.checked = shouldSelect;
          applyBusOptionState(checkbox);
        }
        busSelections[numericId] = shouldSelect;
      });
      refreshReplay();
    }

    function deselectAllBuses() {
      Object.keys(allBuses).forEach(id => {
        const numericId = Number(id);
        if (Number.isNaN(numericId)) return;
        const checkbox = document.getElementById(`bus_${numericId}`);
        if (checkbox) {
          checkbox.checked = false;
          applyBusOptionState(checkbox);
        }
        busSelections[numericId] = false;
      });
      refreshReplay();
    }

    function applyRouteOptionState(inputElement) {
      if (!inputElement || typeof inputElement.closest !== 'function') return;
      const parentLabel = inputElement.closest('label.route-option');
      if (!parentLabel) return;
      parentLabel.classList.toggle('is-active', inputElement.checked);
    }

    function updateRouteSelector(activeRoutesParam, options) {
      const container = document.getElementById('routeSelector');
      if (!container) return;

      options = options || {};
      const forceUpdate = options.force === true;

      const activeRoutesSet = activeRoutesParam instanceof Set
        ? activeRoutesParam
        : new Set(Array.isArray(activeRoutesParam) ? activeRoutesParam : []);

      const routeIDs = Object.keys(allRoutes)
        .map(id => Number(id))
        .filter(id => !Number.isNaN(id) && id !== 0);

      routeIDs.sort((a, b) => {
        const descA = (allRoutes[a]?.Description || `Route ${a}`).toUpperCase();
        const descB = (allRoutes[b]?.Description || `Route ${b}`).toUpperCase();
        if (descA < descB) return -1;
        if (descA > descB) return 1;
        return 0;
      });

      const routeInfoSnapshot = routeIDs.map(routeID => {
        const route = allRoutes[routeID] || {};
        return {
          id: routeID,
          description: route.Description || '',
          infoText: route.InfoText || '',
          color: route.MapLineColor || ''
        };
      });
      const activeSnapshot = Array.from(activeRoutesSet)
        .map(id => Number(id))
        .filter(id => !Number.isNaN(id))
        .sort((a, b) => a - b);
      const nextStateKey = JSON.stringify({
        routes: routeInfoSnapshot,
        active: activeSnapshot,
        showSpeed: !!showSpeed,
        showBlockNumbers: !!showBlockNumbers,
        showNameBubbles: !!showNameBubbles
      });

      if (!forceUpdate && nextStateKey === lastRouteSelectorStateKey) {
        return;
      }

      const previousContent = container.querySelector('.selector-content');
      const previousScrollTop = previousContent ? previousContent.scrollTop : 0;

      let html = `
        <div class="selector-header">
          <div class="selector-title">Route Filters</div>
          <div class="selector-subtitle">Choose which routes appear during playback.</div>
        </div>
        <div class="selector-content">
          <div class="selector-section">
            <div class="selector-group">
              <div class="selector-label">Vehicle Labels</div>
              <div class="display-mode-group">
                <button type="button" class="pill-button ${showSpeed ? 'is-active' : ''}" onclick="setReplayDisplayMode('speed')">Show Speed</button>
                <button type="button" class="pill-button ${showBlockNumbers ? 'is-active' : ''}" onclick="setReplayDisplayMode('block')">Show Blocks</button>
                <button type="button" class="pill-button ${(!showSpeed && !showBlockNumbers) ? 'is-active' : ''}" onclick="setReplayDisplayMode('none')">Show None</button>
              </div>
            </div>
            <div class="selector-group">
              <div class="selector-label">Name Bubbles</div>
              <button type="button" class="pill-button ${showNameBubbles ? 'is-active' : ''}" onclick="toggleNameBubbles()">${showNameBubbles ? 'Hide Name Bubbles' : 'Show Name Bubbles'}</button>
            </div>
            <div class="selector-group selector-group--route-actions">
              <div class="selector-label">Route Shortcuts</div>
              <div class="display-mode-group route-action-buttons">
                <button type="button" class="pill-button" onclick="selectAllRoutes()">Select All</button>
                <button type="button" class="pill-button" onclick="selectActiveRoutes()">Select Active</button>
                <button type="button" class="pill-button" onclick="deselectAllRoutes()">Deselect All</button>
              </div>
            </div>
            <div class="route-list">
      `;

      const outChecked = Object.prototype.hasOwnProperty.call(routeSelections, 0)
        ? routeSelections[0]
        : activeRoutesSet.has(0);

      html += `
              <label class="route-option route-option--out ${outChecked ? 'is-active' : ''}">
                <input type="checkbox" id="route_0" value="0" ${outChecked ? 'checked' : ''}>
                <span class="route-option-swatch" style="background:${outOfServiceRouteColor};"></span>
                <span class="route-option-text">
                  <span class="route-option-name">Out of Service</span>
                  <span class="route-option-detail">Vehicles without an assigned route</span>
                </span>
              </label>
      `;

      if (routeIDs.length === 0) {
        html += `
              <div class="selector-option-detail">No routes available for this replay.</div>
        `;
      } else {
        routeIDs.forEach(routeID => {
          const route = allRoutes[routeID] || {};
          const checked = Object.prototype.hasOwnProperty.call(routeSelections, routeID)
            ? routeSelections[routeID]
            : activeRoutesSet.has(routeID);
          const color = route.MapLineColor || '#A0AEC0';
          const description = route.Description || `Route ${routeID}`;
          const infoText = route.InfoText && route.InfoText.trim() ? route.InfoText.trim() : '';
          const detailParts = [];
          if (infoText) detailParts.push(infoText);
          if (activeRoutesSet.has(routeID)) detailParts.push('Active in frame');
          const detailHtml = detailParts.map(text => `<span class="route-option-detail">${text}</span>`).join('');
          html += `
              <label class="route-option ${checked ? 'is-active' : ''}">
                <input type="checkbox" id="route_${routeID}" value="${routeID}" ${checked ? 'checked' : ''}>
                <span class="route-option-swatch" style="background:${color};"></span>
                <span class="route-option-text">
                  <span class="route-option-name">${description}</span>
                  ${detailHtml}
                </span>
              </label>
          `;
        });
      }

      html += `
            </div>
          </div>
        </div>
      `;

      container.innerHTML = html;

      const newContent = container.querySelector('.selector-content');
      if (newContent) {
        newContent.scrollTop = previousScrollTop;
      }

      const outChk = document.getElementById('route_0');
      if (outChk) {
        outChk.addEventListener('change', () => {
          routeSelections[0] = outChk.checked;
          applyRouteOptionState(outChk);
          refreshReplay();
        });
        applyRouteOptionState(outChk);
      }

      routeIDs.forEach(routeID => {
        const checkbox = document.getElementById(`route_${routeID}`);
        if (checkbox) {
          checkbox.addEventListener('change', () => {
            routeSelections[routeID] = checkbox.checked;
            applyRouteOptionState(checkbox);
            refreshReplay();
          });
          applyRouteOptionState(checkbox);
        }
      });

      lastRouteSelectorStateKey = nextStateKey;
      positionAllPanelTabs();
    }

    function selectAllRoutes() {
      const outChk = document.getElementById('route_0');
      if (outChk) {
        outChk.checked = true;
        applyRouteOptionState(outChk);
      }
      routeSelections[0] = true;

      Object.keys(allRoutes).forEach(routeID => {
        const numericId = Number(routeID);
        if (Number.isNaN(numericId) || numericId === 0) return;
        const checkbox = document.getElementById(`route_${numericId}`);
        if (checkbox) {
          checkbox.checked = true;
          applyRouteOptionState(checkbox);
        }
        routeSelections[numericId] = true;
      });
      refreshReplay();
    }

    function selectActiveRoutes() {
      const activeSet = activeRoutes instanceof Set
        ? activeRoutes
        : new Set(Array.isArray(activeRoutes) ? activeRoutes : []);

      const outChk = document.getElementById('route_0');
      const shouldSelectOut = activeSet.has(0);
      if (outChk) {
        outChk.checked = shouldSelectOut;
        applyRouteOptionState(outChk);
      }
      routeSelections[0] = shouldSelectOut;

      Object.keys(allRoutes).forEach(routeID => {
        const numericId = Number(routeID);
        if (Number.isNaN(numericId) || numericId === 0) return;
        const checkbox = document.getElementById(`route_${numericId}`);
        const shouldSelect = activeSet.has(numericId);
        if (checkbox) {
          checkbox.checked = shouldSelect;
          applyRouteOptionState(checkbox);
        }
        routeSelections[numericId] = shouldSelect;
      });
      refreshReplay();
    }

    function deselectAllRoutes() {
      const outChk = document.getElementById('route_0');
      if (outChk) {
        outChk.checked = false;
        applyRouteOptionState(outChk);
      }
      routeSelections[0] = false;

      Object.keys(allRoutes).forEach(routeID => {
        const numericId = Number(routeID);
        if (Number.isNaN(numericId) || numericId === 0) return;
        const checkbox = document.getElementById(`route_${numericId}`);
        if (checkbox) {
          checkbox.checked = false;
          applyRouteOptionState(checkbox);
        }
        routeSelections[numericId] = false;
      });
      refreshReplay();
    }

    function togglePanelVisibility(panelId, tabId, expandedArrow, collapsedArrow) {
      const panel = document.getElementById(panelId);
      const tab = document.getElementById(tabId);
      if (!panel || !tab) return false;
      const isHidden = panel.classList.toggle('hidden');
      tab.innerHTML = isHidden ? collapsedArrow : expandedArrow;
      positionAllPanelTabs();
      return !isHidden;
    }

    function toggleRoutePanel() {
      const opened = togglePanelVisibility('routeSelector', 'routeSelectorTab', '&#9664;', '&#9654;');
      const busPanel = document.getElementById('busSelector');
      const busTab = document.getElementById('busSelectorTab');
      if (opened) {
        if (busPanel && !busPanel.classList.contains('hidden')) {
          busPanel.classList.add('hidden');
          if (busTab) busTab.innerHTML = '&#9664;';
        }
        if (busTab) busTab.style.display = 'none';
      } else if (busTab) {
        busTab.style.display = '';
      }
      positionAllPanelTabs();
    }

    function toggleBusPanel() {
      const opened = togglePanelVisibility('busSelector', 'busSelectorTab', '&#9654;', '&#9664;');
      const routePanel = document.getElementById('routeSelector');
      const routeTab = document.getElementById('routeSelectorTab');
      if (opened) {
        if (routePanel && !routePanel.classList.contains('hidden')) {
          routePanel.classList.add('hidden');
          if (routeTab) routeTab.innerHTML = '&#9654;';
        }
        if (routeTab) routeTab.style.display = 'none';
      } else if (routeTab) {
        routeTab.style.display = '';
      }
      positionAllPanelTabs();
    }

    function hourKey(ms) {
      const d = new Date(ms);
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      const h = String(d.getHours()).padStart(2, '0');
      return `${y}${m}${day}_${h}`;
    }

    async function loadHour(ms) {
      const key = hourKey(ms);
      if (loadedHours.has(key)) return;
      beginRangeLoad();
      try {
        const resp = await fetch(`/vehicle_log/${key}.jsonl`, { cache: 'no-store' });
        if (!resp.ok) { loadedHours.add(key); return; }
        const text = await resp.text();
        if (!text.trim()) { loadedHours.add(key); return; }
        const entries = text
          .split('\n')
          .filter(l => l.trim())
          .map(line => JSON.parse(line));
        playbackData = playbackData.concat(entries);
        playbackData.sort((a, b) => new Date(a.ts) - new Date(b.ts));
        playbackData = playbackData.filter(e => {
          const t = new Date(e.ts);
          return (!startTime || t >= startTime) && (!userEndTime || t <= userEndTime);
        });
        playbackTimes = playbackData.map(e => new Date(e.ts).getTime());
        loadedHours.add(key);
        if (playbackTimes.length) {
          const lastMs = playbackTimes[playbackTimes.length - 1];
          const timeline = document.getElementById('timeline');
          if (timeline) {
            const currentMax = parseInt(timeline.max, 10) || 0;
            if (lastMs > currentMax) {
              timeline.max = lastMs;
            }
          }
          if (lastMs > endTime.getTime()) {
            endTime = new Date(lastMs);
          }
          if (lastMs > userEndTime.getTime()) {
            userEndTime = new Date(lastMs);
            const endInput = document.getElementById('endTime');
            if (endInput && endInput._flatpickr) {
              endInput._flatpickr.setDate(new Date(lastMs), true);
            }
          }
        }
      } catch (err) {
        console.error('Failed to load log hour', err);
        loadedHours.add(key);
      } finally {
        completeRangeLoad();
      }
    }

    async function ensureLoaded(ms) {
      const key = hourKey(ms);
      if (!loadedHours.has(key)) {
        await loadHour(ms);
      }
    }

    function clearMarkers() {
      for (let id in markers) { map.removeLayer(markers[id]); }
      markers = {};
      for (let id in nameMarkers) { map.removeLayer(nameMarkers[id]); }
      nameMarkers = {};
      for (let id in speedMarkers) { map.removeLayer(speedMarkers[id]); }
      speedMarkers = {};
      for (let id in blockMarkers) { map.removeLayer(blockMarkers[id]); }
      blockMarkers = {};
    }

    function drawRoutes() {
      routeLayers.forEach(layer => map.removeLayer(layer));
      routeLayers = [];
      for (let routeID in allRoutes) {
        const route = allRoutes[routeID];
        if (!route.decodedPolyline) continue;
        if (!isRouteSelected(Number(routeID))) continue;
        const color = getRouteColor(Number(routeID));
        const layer = L.polyline(route.decodedPolyline, {
          color: color,
          weight: 6,
          opacity: 1
        }).addTo(map);
        routeLayers.push(layer);
      }
    }


    function findFrameIndex(ms) {
      let idx = 0;
      for (let i = 0; i < playbackTimes.length; i++) {
        if (playbackTimes[i] <= ms) {
          idx = i;
        } else {
          break;
        }
      }
      return idx;
    }

    function showFrame(i, displayMs) {
      if (!playbackData[i]) return;
      currentFrameIndex = i;
      const entry = playbackData[i];
      const timeline = document.getElementById('timeline');
      const timeMs = (typeof displayMs !== 'undefined') ? displayMs : playbackTimes[i];
      const formatted = new Date(timeMs).toLocaleString('en-US', {
        timeZone: 'America/New_York',
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false
      });
      timeline.value = timeMs;
      timeline.title = formatted; // show date/time when hovering the slider
      document.getElementById('timeLabel').textContent = `Showing: ${formatted}`;

      const activeRoutesSet = new Set();
      const activeBusesSet = new Set();
      entry.vehicles.forEach(v => {
        activeRoutesSet.add(v.RouteID || 0);
        activeBusesSet.add(v.VehicleID);
        const busName = v.Name ? v.Name.slice(0, -2) : '';
        if (busName) {
          allBuses[v.VehicleID] = busName;
        }
      });
      activeRoutes = activeRoutesSet;
      activeBuses = activeBusesSet;
      updateRouteSelector(activeRoutesSet);
      updateBusSelector(activeBusesSet);

      drawRoutes();
      clearMarkers();
      const blocks = entry.blocks || {};
      const seen = new Set();
      let smoothDuration = 0;
      if (playbackSpeed >= 10 && i > 0) {
        smoothDuration = (new Date(playbackData[i].ts) - new Date(playbackData[i-1].ts)) / playbackSpeed;
      }
      entry.vehicles.forEach(vehicle => {
        const routeID = vehicle.RouteID || 0;
        if (!isRouteSelected(routeID) || !isBusSelected(vehicle.VehicleID)) return;
        seen.add(vehicle.VehicleID);
        const pos = [vehicle.Latitude, vehicle.Longitude];
        const startPos = (playbackSpeed >= 10 && lastPositions[vehicle.VehicleID]) ? lastPositions[vehicle.VehicleID] : pos;
        const isMoving = vehicle.GroundSpeed > 0;
        const heading = vehicle.Heading;
        const routeColor = getRouteColor(routeID);
        const svgIcon = `
          <svg width="40" height="80" viewBox="0 0 40 80" xmlns="http://www.w3.org/2000/svg">
            <g>
              <circle cx="20" cy="20" r="15" fill="${routeColor}" stroke="white" stroke-width="3" />
              ${isMoving ? `
                <line x1="20" y1="10" x2="20" y2="22" stroke="white" stroke-width="4" stroke-linecap="round" style="transform: rotate(${heading + 180}deg); transform-origin: 20px 20px" />
                <polygon points="15,22 25,22 20,30" fill="white" style="transform: rotate(${heading + 180}deg); transform-origin: 20px 20px" />
              ` : `
                <rect x="14" y="14" width="12" height="12" fill="white" />
              `}
            </g>
          </svg>`;
        const busIcon = L.divIcon({ html: svgIcon, className: '', iconSize: [40,40], iconAnchor: [20,20] });
        const marker = L.marker(startPos, { icon: busIcon }).addTo(map);
        if (playbackSpeed >= 10 && smoothDuration > 0) {
          marker._icon.style.transition = `transform ${smoothDuration}ms linear`;
          setTimeout(() => marker.setLatLng(pos), 0);
        } else {
          marker.setLatLng(pos);
        }
        markers[vehicle.VehicleID] = marker;

        if (showSpeed) {
          const speedBubble = `
            <svg width="60" height="20" viewBox="0 0 60 20" xmlns="http://www.w3.org/2000/svg">
              <g>
                <rect x="0" y="0" width="60" height="20" rx="10" ry="10" fill="${routeColor}" stroke="white" stroke-width="3" />
                <text x="30" y="15" font-size="12" font-weight="bold" text-anchor="middle" fill="${getContrastColor(routeColor)}" font-family="FGDC">${Math.round(vehicle.GroundSpeed)} MPH</text>
              </g>
            </svg>`;
          const speedIcon = L.divIcon({ html: speedBubble, className: '', iconSize: [60,20], iconAnchor: [30,-15] });
          const sm = L.marker(startPos, { icon: speedIcon, interactive: false }).addTo(map);
          if (playbackSpeed >= 10 && smoothDuration > 0) {
            sm._icon.style.transition = `transform ${smoothDuration}ms linear`;
            setTimeout(() => sm.setLatLng(pos), 0);
          } else {
            sm.setLatLng(pos);
          }
          speedMarkers[vehicle.VehicleID] = sm;
        }

        if (showBlockNumbers) {
          const blockName = blocks[vehicle.VehicleID];
          if (blockName && blockName.includes('[')) {
            const ctx = document.createElement('canvas').getContext('2d');
            ctx.font = 'bold 14px FGDC';
            const textWidth = ctx.measureText(blockName).width;
            const blockWidth = Math.max(40, textWidth + 20);
            const blockBubble = `
              <svg width="${blockWidth}" height="30" viewBox="0 0 ${blockWidth} 30" xmlns="http://www.w3.org/2000/svg">
                <g>
                  <rect x="0" y="5" width="${blockWidth}" height="20" rx="10" ry="10" fill="${routeColor}" stroke="white" stroke-width="3" />
                  <text x="${blockWidth/2}" y="20" font-size="14" font-weight="bold" text-anchor="middle" fill="${getContrastColor(routeColor)}" font-family="FGDC">${blockName}</text>
                </g>
              </svg>`;
            const blockIcon = L.divIcon({ html: blockBubble, className: '', iconSize: [blockWidth,30], iconAnchor: [blockWidth/2,-13] });
            const bm = L.marker(startPos, { icon: blockIcon, interactive: false }).addTo(map);
            if (playbackSpeed >= 10 && smoothDuration > 0) {
              bm._icon.style.transition = `transform ${smoothDuration}ms linear`;
              setTimeout(() => bm.setLatLng(pos), 0);
            } else {
              bm.setLatLng(pos);
            }
            blockMarkers[vehicle.VehicleID] = bm;
          }
        }

        const busName = vehicle.Name ? vehicle.Name.slice(0, -2) : '';
        if (showNameBubbles && busName) {
          const bubbleWidth = Math.max(40, busName.length * 10);
          const nameBubble = `
            <svg width="${bubbleWidth}" height="30" viewBox="0 0 ${bubbleWidth} 30" xmlns="http://www.w3.org/2000/svg">
              <g>
                <rect x="0" y="5" width="${bubbleWidth}" height="20" rx="10" ry="10" fill="${routeColor}" stroke="white" stroke-width="3" />
                <text x="${bubbleWidth / 2}" y="20" font-size="14" font-weight="bold" text-anchor="middle" fill="${getContrastColor(routeColor)}" font-family="FGDC">${busName}</text>
              </g>
            </svg>`;
          const nameIcon = L.divIcon({ html: nameBubble, className: '', iconSize: [bubbleWidth,30], iconAnchor: [bubbleWidth/2,40] });
          const nm = L.marker(startPos, { icon: nameIcon, interactive: false }).addTo(map);
          if (playbackSpeed >= 10 && smoothDuration > 0) {
            nm._icon.style.transition = `transform ${smoothDuration}ms linear`;
            setTimeout(() => nm.setLatLng(pos), 0);
          } else {
            nm.setLatLng(pos);
          }
          nameMarkers[vehicle.VehicleID] = nm;
        }

        lastPositions[vehicle.VehicleID] = pos;
      });
      for (let id in lastPositions) {
        if (!seen.has(Number(id))) {
          delete lastPositions[id];
        }
      }
    }

    async function scheduleNext() {
      const current = currentFrameIndex;
      let next = current + 1;
      if (next >= playbackData.length) {
        if (endTime) {
          let ms = playbackTimes[playbackTimes.length - 1] + 1000;
          const endMs = endTime.getTime();
          while (ms <= endMs && next >= playbackData.length) {
            await loadHour(ms);
            next = current + 1;
            ms += 3600 * 1000; // step one hour forward
          }
          if (next >= playbackData.length) { pause(); return; }
        } else { pause(); return; }
      }
      const rawDelta = playbackTimes[next] - playbackTimes[current];
      const safeDelta = Math.max(rawDelta, 0);
      const maxGap = 60 * 1000; // cap wait to 60 seconds to skip long gaps quickly
      const wait = Math.min(safeDelta, maxGap) / playbackSpeed;
      timer = setTimeout(() => {
        showFrame(next);
        scheduleNext();
      }, wait);
    }

    function play() {
      pause();
      isPlaying = true;
      updateSpeedButtons();
      scheduleNext();
    }

    function pause() {
      if (timer) clearTimeout(timer);
      timer = null;
      if (isPlaying) {
        isPlaying = false;
      }
      updateSpeedButtons();
    }

    async function applyRange(initial = false) {
      beginRangeLoad();
      try {
        const dateStr = document.getElementById('datePicker').value;
        const startStr = document.getElementById('startTime').value || '00:00';
        const endStr = document.getElementById('endTime').value || '23:59';
        startTime = new Date(`${dateStr}T${startStr}:00`);
        userEndTime = new Date(`${dateStr}T${endStr}:00`);

        // If the selected date is today, don't try to load data beyond the current time
        const todayStr = new Date().toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
        let lastHour = new Date(`${dateStr}T23:00:00`);
        if (dateStr === todayStr) {
          const now = new Date(new Date().toLocaleString('en-US', { timeZone: 'America/New_York' }));
          if (userEndTime > now) {
            userEndTime = now;
          }
          // For the current day only load up to the current hour
          lastHour = new Date(`${dateStr}T${String(now.getHours()).padStart(2, '0')}:00:00`);
        }

        endTime = userEndTime;
        playbackData = [];
        playbackTimes = [];
        loadedHours = new Set();
        const timeline = document.getElementById('timeline');
        timeline.min = startTime.getTime();
        timeline.max = userEndTime.getTime();

        let startHour = new Date(startTime);
        startHour.setMinutes(0, 0, 0);
        let endHour = initial ? lastHour : new Date(userEndTime);
        endHour.setMinutes(0, 0, 0);

        for (let ms = startHour.getTime(); ms <= endHour.getTime(); ms += 3600 * 1000) {
          await loadHour(ms);
        }

        if (initial && playbackTimes.length) {
          const lastMs = playbackTimes[playbackTimes.length - 1];
          timeline.max = lastMs;
          const endInput = document.getElementById('endTime');
          if (endInput && endInput._flatpickr) {
            endInput._flatpickr.setDate(new Date(lastMs), true);
          }
          endTime = new Date(lastMs);
          userEndTime = new Date(lastMs);
        }

        if (playbackTimes.length) {
          const ms = startTime.getTime();
          const idx = findFrameIndex(ms);
          showFrame(idx, ms);
        }
      } finally {
        completeRangeLoad();
      }
    }

    // Periodically check for newly available data in the selected day
    function startAutoRefresh() {
      setInterval(async () => {
        const dateStr = document.getElementById('datePicker').value;
        const todayStr = new Date().toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
        if (dateStr !== todayStr) return;

        const now = new Date(new Date().toLocaleString('en-US', { timeZone: 'America/New_York' }));
        if (now > userEndTime) {
          userEndTime = now;
          endTime = now;
          const timeline = document.getElementById('timeline');
          timeline.max = now.getTime();
          await loadHour(now.getTime());
        }
      }, 60000);
    }

    const disclaimerOverlay = document.getElementById('disclaimerOverlay');
    const disclaimerBtn = document.getElementById('disclaimerBtn');
    disclaimerBtn.onclick = () => { disclaimerOverlay.style.display = 'none'; };

    playBtn.onclick = () => { playbackSpeed = 1; play(); };
    pauseBtn.onclick = pause;
    ff2Btn.onclick = () => { playbackSpeed = 2; play(); };
    ff4Btn.onclick = () => { playbackSpeed = 4; play(); };
    ff8Btn.onclick = () => { playbackSpeed = 8; play(); };
    ff10Btn.onclick = () => { playbackSpeed = 10; play(); };
    ff30Btn.onclick = () => { playbackSpeed = 30; play(); };
    ff100Btn.onclick = () => { playbackSpeed = 100; play(); };
    ff200Btn.onclick = () => { playbackSpeed = 200; play(); };
    ff500Btn.onclick = () => { playbackSpeed = 500; play(); };
    ff1000Btn.onclick = () => { playbackSpeed = 1000; play(); };
    document.getElementById('timeline').addEventListener('input', async e => {
      pause();
      const ms = parseInt(e.target.value);
      await ensureLoaded(ms);
      const idx = findFrameIndex(ms);
      showFrame(idx, ms);
    });
    document.getElementById('loadRangeBtn').onclick = () => { pause(); applyRange(false); };

    pause();
    fetchRoutes().then(() => { applyRange(true); startAutoRefresh(); });
  </script>
</body>
</html>
