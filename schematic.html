<!DOCTYPE html>
<html>
<head>
  <title>Schematic Map - Headway Guard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
    }
    #mapSvg {
      width: 100%;
      height: 100%;
      background: #fff;
    }
  </style>
  <script src="https://unpkg.com/@mapbox/polyline@1.1.1"></script>
</head>
<body>
  <svg id="mapSvg" viewBox="0 0 1000 800" preserveAspectRatio="xMidYMid meet"></svg>
  <script>
    const svg = document.getElementById('mapSvg');
    const width = 1000;
    const height = 800;
    const STROKE_WIDTH = 4;
    const OVERLAP_SPACING = STROKE_WIDTH + 2;
    const SEGMENT_TOLERANCE = STROKE_WIDTH * 2; // pixels used to detect near-overlaps

    function segmentKey(x1, y1, x2, y2) {
      const q = v => Math.round(v / SEGMENT_TOLERANCE) * SEGMENT_TOLERANCE;
      if (x1 < x2 || (x1 === x2 && y1 <= y2)) {
        return `${q(x1)},${q(y1)},${q(x2)},${q(y2)}`;
      }
      return `${q(x2)},${q(y2)},${q(x1)},${q(y1)}`;
    }

    // Ramer-Douglas-Peucker line simplification
    function simplifyLine(points, tolerance) {
      if (points.length <= 2) return points;
      const sqTol = tolerance * tolerance;

      function getSqSegDist(p, a, b) {
        let x = a[0], y = a[1];
        let dx = b[0] - x, dy = b[1] - y;
        if (dx !== 0 || dy !== 0) {
          const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);
          if (t > 1) { x = b[0]; y = b[1]; }
          else if (t > 0) { x += dx * t; y += dy * t; }
        }
        dx = p[0] - x; dy = p[1] - y;
        return dx * dx + dy * dy;
      }

      function simplifyDP(pts, first, last, res) {
        let maxDist = 0, index = first;
        for (let i = first + 1; i < last; i++) {
          const dist = getSqSegDist(pts[i], pts[first], pts[last]);
          if (dist > maxDist) { index = i; maxDist = dist; }
        }
        if (maxDist > sqTol) {
          if (index - first > 1) simplifyDP(pts, first, index, res);
          res.push(pts[index]);
          if (last - index > 1) simplifyDP(pts, index, last, res);
        }
      }

      const res = [points[0]];
      simplifyDP(points, 0, points.length - 1, res);
      res.push(points[points.length - 1]);
      return res;
    }

    // Build a straight polyline path
    function buildStraightPath(points) {
      if (!points.length) return '';
      let d = `M ${points[0][0]} ${points[0][1]}`;
      for (let i = 1; i < points.length; i++) {
        const [x, y] = points[i];
        d += ` L ${x} ${y}`;
      }
      return d;
    }

    function scaleAndRender(routes) {
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      routes.forEach(r => r.points.forEach(([y, x]) => {
        if (x < minX) minX = x;
        if (x > maxX) maxX = x;
        if (y < minY) minY = y;
        if (y > maxY) maxY = y;
      }));

      const scale = Math.min(width / (maxX - minX), height / (maxY - minY));
      const offsetX = (width - (maxX - minX) * scale) / 2;
      const offsetY = (height - (maxY - minY) * scale) / 2;

      // Scale and simplify all points first
      routes.forEach(r => {
        r.scaled = r.points.map(([y, x]) => {
          const sx = (x - minX) * scale + offsetX;
          const sy = height - ((y - minY) * scale + offsetY); // invert y
          return [sx, sy];
        });
        r.scaled = simplifyLine(r.scaled, 2);
      });

      // Map of segments to routes that share them
      const segMap = new Map();
      routes.forEach((r, ridx) => {
        const pts = r.scaled;
        for (let i = 0; i < pts.length - 1; i++) {
          const [x1, y1] = pts[i];
          const [x2, y2] = pts[i + 1];
          const key = segmentKey(x1, y1, x2, y2);
          if (!segMap.has(key)) segMap.set(key, []);
          segMap.get(key).push({ route: ridx, idx: i });
        }
      });

      // Prepare offset accumulators
      routes.forEach(r => {
        r.offsets = Array(r.scaled.length).fill(0).map(() => [0, 0]);
        r.counts = Array(r.scaled.length).fill(0);
        r.overlapSegments = [];
      });

      // Compute offsets for overlapping segments
      const overlaps = [];
      segMap.forEach((group, key) => {
        const n = group.length;
        if (n > 1) overlaps.push({ segment: key, routes: group.map(g => g.route) });

        // Average start and end points so near-overlaps align to a common centerline
        const avgStart = [0, 0];
        const avgEnd = [0, 0];
        group.forEach(info => {
          const pts = routes[info.route].scaled;
          const p1 = pts[info.idx];
          const p2 = pts[info.idx + 1];
          avgStart[0] += p1[0];
          avgStart[1] += p1[1];
          avgEnd[0] += p2[0];
          avgEnd[1] += p2[1];
        });
        avgStart[0] /= n; avgStart[1] /= n;
        avgEnd[0] /= n; avgEnd[1] /= n;
        const dx = avgEnd[0] - avgStart[0];
        const dy = avgEnd[1] - avgStart[1];
        const len = Math.hypot(dx, dy) || 1;

        group.forEach((info, idx) => {
          const route = routes[info.route];
          const pts = route.scaled;
          const i = info.idx;
          const offset = (idx - (n - 1) / 2) * OVERLAP_SPACING;
          const offX = -dy / len * offset;
          const offY = dx / len * offset;
          route.offsets[i][0] += (avgStart[0] - pts[i][0]) + offX;
          route.offsets[i][1] += (avgStart[1] - pts[i][1]) + offY;
          route.offsets[i + 1][0] += (avgEnd[0] - pts[i + 1][0]) + offX;
          route.offsets[i + 1][1] += (avgEnd[1] - pts[i + 1][1]) + offY;
          route.counts[i]++;
          route.counts[i + 1]++;
          if (n > 1) route.overlapSegments.push(i);
        });
      });
      if (overlaps.length) console.log('Overlapping segments', overlaps);

      // Render paths with averaged offsets
      routes.forEach(r => {
        const pts = r.scaled.map((p, i) => {
          if (r.counts[i]) {
            return [p[0] + r.offsets[i][0] / r.counts[i], p[1] + r.offsets[i][1] / r.counts[i]];
          }
          return p;
        });
        const d = buildStraightPath(pts);
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', d);
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke', r.color || '#000');
        path.setAttribute('stroke-width', STROKE_WIDTH);
        path.setAttribute('stroke-linejoin', 'miter');
        path.setAttribute('stroke-linecap', 'round');
        svg.appendChild(path);
      });
    }

    Promise.all([
      fetch('https://uva.transloc.com/Services/JSONPRelay.svc/GetRoutesForMapWithScheduleWithEncodedLine?APIKey=8882812681').then(r => r.json()),
      fetch('https://uva.transloc.com/Services/JSONPRelay.svc/GetMapVehiclePoints?APIKey=8882812681&returnVehiclesNotAssignedToRoute=true').then(r => r.json())
    ])
      .then(([routeData, vehicleData]) => {
        const activeRouteIds = new Set(
          (vehicleData || [])
            .filter(v => v.RouteID && v.RouteID > 0)
            .map(v => v.RouteID)
        );
        const routes = [];
        const seenRouteIds = new Set();
        (routeData || []).forEach(route => {
          if (
            route.IsRunning &&
            activeRouteIds.has(route.RouteID) &&
            route.EncodedPolyline &&
            !seenRouteIds.has(route.RouteID)
          ) {
            seenRouteIds.add(route.RouteID);
            const decoded = polyline.decode(route.EncodedPolyline);
            routes.push({
              color: route.MapLineColor || route.Color || '#000',
              points: decoded
            });
          }
        });
        scaleAndRender(routes);
      })
      .catch(err => console.error('Error loading data', err));
  </script>
</body>
</html>
