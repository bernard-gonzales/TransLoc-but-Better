<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>UTS Metro Schematic</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root {
            color-scheme: light;
            --bg: #f6f7fb;
            --panel-bg: #ffffff;
            --border: #d9dce3;
            --accent: #3657ff;
            --text: #141821;
            --muted: #5b6478;
            --danger: #c62828;
            --shadow: 0 18px 45px rgba(20, 24, 33, 0.08);
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            font-family: "Inter", "Segoe UI", "Helvetica Neue", Arial, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .app-shell {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .app-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: clamp(1rem, 2vw, 1.5rem) clamp(1.2rem, 4vw, 2.5rem);
            gap: 1.5rem;
        }

        .title-block h1 {
            font-size: clamp(1.6rem, 1.2rem + 1.1vw, 2.4rem);
            margin: 0;
            font-weight: 600;
        }

        .title-block p {
            margin: 0.35rem 0 0;
            color: var(--muted);
            font-size: 0.95rem;
        }

        .mode-toggle {
            display: inline-flex;
            background: #e5e8f1;
            border-radius: 999px;
            padding: 0.25rem;
            gap: 0.25rem;
        }

        .mode-button {
            border: none;
            background: transparent;
            padding: 0.4rem 0.95rem;
            border-radius: 999px;
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--muted);
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease;
        }

        .mode-button.is-active {
            background: var(--panel-bg);
            color: var(--accent);
            box-shadow: 0 6px 16px rgba(54, 87, 255, 0.18);
        }

        .mode-button:focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }

        .status-pill {
            margin-left: auto;
            padding: 0.4rem 0.85rem;
            border-radius: 999px;
            font-size: 0.85rem;
            background: #e5e8f1;
            color: var(--muted);
            white-space: nowrap;
        }

        .status-pill.is-dirty {
            background: rgba(255, 152, 0, 0.18);
            color: #a15c00;
        }

        .app-main {
            flex: 1 1 auto;
            padding: 0 clamp(1rem, 4vw, 3rem) clamp(1.5rem, 5vw, 3rem);
        }

        .pane {
            display: none;
        }

        .pane.is-visible {
            display: block;
        }

        .pane-inner {
            display: grid;
            gap: clamp(1rem, 3vw, 2rem);
        }

        .svg-panel {
            background: var(--panel-bg);
            border: 1px solid var(--border);
            border-radius: 1rem;
            padding: clamp(0.75rem, 2vw, 1.25rem);
            box-shadow: var(--shadow);
        }

        .svg-wrap {
            position: relative;
            width: 100%;
            min-height: clamp(420px, 60vh, 720px);
            border-radius: 0.75rem;
            overflow: hidden;
            background: #fff;
            border: 1px solid rgba(20, 24, 33, 0.08);
        }

        svg {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
            cursor: grab;
            background: #fff;
        }

        svg.is-dragging {
            cursor: grabbing;
        }

        .info-panel {
            display: flex;
            flex-direction: column;
            gap: clamp(1rem, 2vw, 1.5rem);
        }

        .card {
            background: var(--panel-bg);
            border: 1px solid var(--border);
            border-radius: 1rem;
            padding: 1rem 1.25rem;
            box-shadow: var(--shadow);
        }

        .card h2 {
            margin: 0 0 0.75rem;
            font-size: 1.05rem;
        }

        .legend-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: grid;
            gap: 0.5rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 0.95rem;
        }

        .legend-swatch {
            width: 1.25rem;
            height: 1.25rem;
            border-radius: 50%;
            border: 1px solid rgba(0, 0, 0, 0.2);
            flex: none;
        }

        .legend-name {
            flex: 1 1 auto;
        }

        .editor-layout {
            grid-template-columns: minmax(260px, 320px) 1fr;
        }

        .editor-sidebar {
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
        }

        .tool-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 0.5rem;
        }

        .tool-button {
            border: 1px solid var(--border);
            border-radius: 0.65rem;
            background: #f4f6fb;
            padding: 0.55rem 0.35rem;
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--muted);
            cursor: pointer;
            transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease;
        }

        .tool-button.is-active {
            background: rgba(54, 87, 255, 0.12);
            color: var(--accent);
            border-color: rgba(54, 87, 255, 0.45);
        }

        .tool-button:focus-visible {
            outline: 2px solid var(--accent);
            outline-offset: 2px;
        }

        .editor-canvas {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .editor-wrap svg {
            background: repeating-linear-gradient(
                to right,
                rgba(20, 24, 33, 0.04) 0,
                rgba(20, 24, 33, 0.04) 1px,
                transparent 1px,
                transparent 40px
            ),
            repeating-linear-gradient(
                to bottom,
                rgba(20, 24, 33, 0.04) 0,
                rgba(20, 24, 33, 0.04) 1px,
                transparent 1px,
                transparent 40px
            );
        }

        .editor-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            color: var(--muted);
            padding: 0 0.35rem;
        }

        .route-list {
            display: grid;
            gap: 0.4rem;
        }

        .route-item {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            padding: 0.45rem 0.6rem;
            border-radius: 0.6rem;
            cursor: pointer;
            transition: background 0.15s ease;
        }

        .route-item.is-active {
            background: rgba(54, 87, 255, 0.12);
        }

        .route-item:hover {
            background: rgba(20, 24, 33, 0.07);
        }

        .route-item .route-color {
            width: 1.2rem;
            height: 1.2rem;
            border-radius: 50%;
            border: 1px solid rgba(0, 0, 0, 0.2);
        }

        .route-editor {
            display: grid;
            gap: 0.6rem;
            margin-top: 0.75rem;
        }

        .route-path-list {
            display: grid;
            gap: 0.4rem;
            max-height: 220px;
            overflow-y: auto;
        }

        .path-pill {
            display: grid;
            grid-template-columns: 1fr auto auto auto;
            gap: 0.35rem;
            align-items: center;
            padding: 0.35rem 0.45rem;
            border-radius: 0.55rem;
            background: rgba(20, 24, 33, 0.06);
            font-size: 0.85rem;
        }

        .path-pill button {
            border: none;
            background: transparent;
            cursor: pointer;
            color: var(--accent);
            font-size: 0.75rem;
        }

        .path-pill button.is-stop {
            color: #0a7a1f;
            font-weight: 600;
        }

        .form-row {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
        }

        .form-row label {
            font-size: 0.8rem;
            color: var(--muted);
        }

        .form-row input {
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            padding: 0.45rem 0.6rem;
            font-size: 0.9rem;
        }

        .small-note {
            font-size: 0.8rem;
            color: var(--muted);
        }

        button.text {
            padding: 0.45rem 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border);
            background: #f4f6fb;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
        }

        button.text:hover {
            background: rgba(54, 87, 255, 0.08);
        }

        button.danger {
            color: var(--danger);
            border-color: rgba(198, 40, 40, 0.25);
            background: rgba(198, 40, 40, 0.06);
        }

        .toast {
            position: fixed;
            bottom: 1.25rem;
            right: 1.25rem;
            background: var(--panel-bg);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            padding: 0.65rem 0.95rem;
            box-shadow: 0 20px 55px rgba(20, 24, 33, 0.18);
            font-size: 0.9rem;
            color: var(--text);
            opacity: 0;
            transform: translateY(12px);
            transition: opacity 0.2s ease, transform 0.2s ease;
            pointer-events: none;
        }

        .toast.is-visible {
            opacity: 1;
            transform: translateY(0);
        }

        .toast.is-error {
            border-color: rgba(198, 40, 40, 0.35);
            color: var(--danger);
        }

        .hidden {
            display: none !important;
        }

        @media (max-width: 960px) {
            .pane-inner {
                grid-template-columns: 1fr;
            }

            .editor-layout {
                grid-template-columns: 1fr;
            }

            .app-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .status-pill {
                margin-left: 0;
            }
        }
    </style>
</head>
<body>
    <div class="app-shell">
        <header class="app-header">
            <div class="title-block">
                <h1>UTS Metro Schematic</h1>
                <p>Craft an octilinear map directly from stop graph nodes.</p>
            </div>
            <div class="mode-toggle" role="tablist">
                <button class="mode-button" data-mode="render" role="tab" aria-controls="renderPane">Render</button>
                <button class="mode-button" data-mode="edit" role="tab" aria-controls="editorPane">Editor</button>
            </div>
            <div class="status-pill" id="saveStatus">Loading…</div>
        </header>
        <main class="app-main">
            <section class="pane" id="renderPane">
                <div class="pane-inner" id="renderLayout">
                    <div class="svg-panel">
                        <div class="svg-wrap">
                            <svg id="renderSvg" viewBox="0 0 1600 1200" xmlns="http://www.w3.org/2000/svg" aria-label="Render schematic">
                                <g class="layer layer-chains"></g>
                                <g class="layer layer-stops"></g>
                                <g class="layer layer-ticks"></g>
                            </svg>
                        </div>
                    </div>
                    <aside class="info-panel">
                        <div class="card">
                            <h2>Routes</h2>
                            <ul class="legend-list" id="routeLegend"></ul>
                        </div>
                        <div class="card">
                            <h2>Dataset</h2>
                            <div class="small-note" id="renderMeta">–</div>
                        </div>
                    </aside>
                </div>
            </section>
            <section class="pane" id="editorPane">
                <div class="pane-inner editor-layout">
                    <aside class="editor-sidebar">
                        <div class="card">
                            <h2>Tools</h2>
                            <div class="tool-grid" id="toolGrid">
                                <button class="tool-button" data-tool="select">Select &amp; Move</button>
                                <button class="tool-button" data-tool="add-stop">Add Stop</button>
                                <button class="tool-button" data-tool="add-bend">Add Bend</button>
                                <button class="tool-button" data-tool="link">Link Nodes</button>
                                <button class="tool-button" data-tool="route">Route Builder</button>
                                <button class="tool-button" data-tool="stop">Toggle Stop</button>
                                <button class="tool-button" data-tool="delete">Delete</button>
                                <button class="tool-button" data-tool="measure">Measure</button>
                            </div>
                        </div>
                        <div class="card" id="routeCard">
                            <div style="display:flex; justify-content:space-between; align-items:center; gap:0.5rem;">
                                <h2 style="margin:0;">Routes</h2>
                                <button class="text" id="addRouteBtn">Add Route</button>
                            </div>
                            <div class="route-list" id="routeList"></div>
                            <div class="route-editor" id="routeEditor"></div>
                        </div>
                        <div class="card" id="nodeCard">
                            <h2>Node</h2>
                            <div id="nodeDetails" class="small-note">Select a node to edit name or coordinates.</div>
                        </div>
                        <div class="card">
                            <h2>Data</h2>
                            <div style="display:flex; gap:0.5rem; flex-wrap:wrap;">
                                <button class="text" id="saveBtn">Save</button>
                                <button class="text" id="importBtn">Seed from TransLoc</button>
                            </div>
                            <p class="small-note" style="margin-top:0.75rem;">Changes auto-save every 5s when dirty.</p>
                        </div>
                    </aside>
                    <div class="editor-canvas">
                        <div class="svg-wrap editor-wrap">
                            <svg id="editorSvg" viewBox="0 0 1600 1200" xmlns="http://www.w3.org/2000/svg" aria-label="Edit schematic">
                                <g class="layer grid"></g>
                                <g class="layer preview"></g>
                                <g class="layer links"></g>
                                <g class="layer nodes"></g>
                                <g class="layer labels"></g>
                            </svg>
                        </div>
                        <div class="editor-status">
                            <span id="cursorReadout">–</span>
                            <span id="toolHint">Select tool to begin editing.</span>
                        </div>
                    </div>
                </div>
            </section>
        </main>
    </div>
    <div class="toast hidden" id="toast" role="status"></div>
    <script>
        (function() {
            const LINE_WIDTH = 6;
            const GAP = 2;
            const MIN_LEG = 35;
            const MIN_DIAGONAL = 40;
            const STOP_RADIUS = 6;
            const STOP_STROKE = 3;

            const $ = (sel, root = document) => root.querySelector(sel);
            const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));

            function clamp(value, min, max) {
                return Math.max(min, Math.min(max, value));
            }

            function distance(a, b) {
                const dx = b.x - a.x;
                const dy = b.y - a.y;
                return Math.hypot(dx, dy);
            }

            function pathFromPoints(points) {
                if (!points || points.length === 0) return '';
                return points.map((p, idx) => `${idx === 0 ? 'M' : 'L'}${p.x.toFixed(2)},${p.y.toFixed(2)}`).join(' ');
            }

            function createSvgElement(tag, attrs = {}) {
                const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
                for (const [key, value] of Object.entries(attrs)) {
                    el.setAttribute(key, value);
                }
                return el;
            }

            const Directions = [
                { vec: [1, 0], type: 'axis' },
                { vec: [-1, 0], type: 'axis' },
                { vec: [0, 1], type: 'axis' },
                { vec: [0, -1], type: 'axis' },
                { vec: [Math.SQRT1_2, Math.SQRT1_2], type: 'diag' },
                { vec: [Math.SQRT1_2, -Math.SQRT1_2], type: 'diag' },
                { vec: [-Math.SQRT1_2, Math.SQRT1_2], type: 'diag' },
                { vec: [-Math.SQRT1_2, -Math.SQRT1_2], type: 'diag' }
            ];

            function isOctilinear(dx, dy) {
                const eps = 1e-4;
                if (Math.abs(dx) < eps || Math.abs(dy) < eps) return true;
                return Math.abs(Math.abs(dx) - Math.abs(dy)) < eps;
            }

            function computeDoglegPoint(a, b) {
                const D = { x: b.x - a.x, y: b.y - a.y };
                const direct = Math.hypot(D.x, D.y);
                let best = null;
                for (const dir1 of Directions) {
                    for (const dir2 of Directions) {
                        const det = dir1.vec[0] * dir2.vec[1] - dir1.vec[1] * dir2.vec[0];
                        if (Math.abs(det) < 1e-6) continue;
                        const t1 = (D.x * dir2.vec[1] - D.y * dir2.vec[0]) / det;
                        const t2 = (dir1.vec[0] * D.y - dir1.vec[1] * D.x) / det;
                        if (t1 <= MIN_LEG || t2 <= MIN_LEG) continue;
                        if (dir1.type === 'diag' && t1 < MIN_DIAGONAL) continue;
                        if (dir2.type === 'diag' && t2 < MIN_DIAGONAL) continue;
                        const candidate = {
                            x: a.x + dir1.vec[0] * t1,
                            y: a.y + dir1.vec[1] * t1
                        };
                        if (!Number.isFinite(candidate.x) || !Number.isFinite(candidate.y)) continue;
                        const total = t1 + t2;
                        const score = Math.abs(total - direct);
                        if (!best || score < best.score) {
                            best = { point: candidate, score };
                        }
                    }
                }
                if (best) {
                    return best.point;
                }
                return null;
            }

            function computeLinkGeometry(nodeA, nodeB) {
                if (!nodeA || !nodeB) return null;
                if (isOctilinear(nodeB.x - nodeA.x, nodeB.y - nodeA.y)) {
                    return [
                        { x: nodeA.x, y: nodeA.y },
                        { x: nodeB.x, y: nodeB.y }
                    ];
                }
                const bend = computeDoglegPoint(nodeA, nodeB);
                if (bend) {
                    return [
                        { x: nodeA.x, y: nodeA.y },
                        { x: bend.x, y: bend.y },
                        { x: nodeB.x, y: nodeB.y }
                    ];
                }
                const mid1 = { x: nodeA.x, y: nodeB.y };
                if (distance(nodeA, mid1) >= MIN_LEG && distance(mid1, nodeB) >= MIN_LEG) {
                    return [
                        { x: nodeA.x, y: nodeA.y },
                        { x: mid1.x, y: mid1.y },
                        { x: nodeB.x, y: nodeB.y }
                    ];
                }
                const mid2 = { x: nodeB.x, y: nodeA.y };
                return [
                    { x: nodeA.x, y: nodeA.y },
                    { x: mid2.x, y: mid2.y },
                    { x: nodeB.x, y: nodeB.y }
                ];
            }

            function mergeCollinear(points) {
                if (!points || points.length <= 2) return points ? points.slice() : [];
                const merged = [points[0]];
                for (let i = 1; i < points.length - 1; i++) {
                    const prev = merged[merged.length - 1];
                    const curr = points[i];
                    const next = points[i + 1];
                    const v1x = curr.x - prev.x;
                    const v1y = curr.y - prev.y;
                    const v2x = next.x - curr.x;
                    const v2y = next.y - curr.y;
                    const cross = v1x * v2y - v1y * v2x;
                    if (Math.abs(cross) < 1e-4) {
                        continue;
                    }
                    merged.push(curr);
                }
                merged.push(points[points.length - 1]);
                return merged;
            }

            function offsetPolyline(points, offset, miterLimit = 4) {
                if (!points || points.length < 2) return points ? points.slice() : [];
                const dirs = [];
                const normals = [];
                for (let i = 0; i < points.length - 1; i++) {
                    const dx = points[i + 1].x - points[i].x;
                    const dy = points[i + 1].y - points[i].y;
                    const len = Math.hypot(dx, dy) || 1;
                    const ux = dx / len;
                    const uy = dy / len;
                    dirs.push({ x: ux, y: uy, len });
                    normals.push({ x: -uy, y: ux });
                }
                const out = [];
                out.push({
                    x: points[0].x + normals[0].x * offset,
                    y: points[0].y + normals[0].y * offset
                });
                for (let i = 1; i < points.length - 1; i++) {
                    const prevDir = dirs[i - 1];
                    const nextDir = dirs[i];
                    const prevNormal = normals[i - 1];
                    const nextNormal = normals[i];
                    const p1 = {
                        x: points[i].x + prevNormal.x * offset,
                        y: points[i].y + prevNormal.y * offset
                    };
                    const p2 = {
                        x: points[i].x + nextNormal.x * offset,
                        y: points[i].y + nextNormal.y * offset
                    };
                    const cross = prevDir.x * nextDir.y - prevDir.y * nextDir.x;
                    if (Math.abs(cross) < 1e-5) {
                        const avgNormal = {
                            x: (prevNormal.x + nextNormal.x) / 2,
                            y: (prevNormal.y + nextNormal.y) / 2
                        };
                        const norm = Math.hypot(avgNormal.x, avgNormal.y) || 1;
                        const scale = offset / norm;
                        out.push({
                            x: points[i].x + avgNormal.x * scale,
                            y: points[i].y + avgNormal.y * scale
                        });
                    } else {
                        const t = ((p2.x - p1.x) * nextDir.y - (p2.y - p1.y) * nextDir.x) / cross;
                        const ix = p1.x + prevDir.x * t;
                        const iy = p1.y + prevDir.y * t;
                        const miterVecX = ix - p1.x;
                        const miterVecY = iy - p1.y;
                        const miterLength = Math.hypot(miterVecX, miterVecY) / Math.abs(offset);
                        if (miterLength > miterLimit) {
                            out.push(p1);
                            out.push(p2);
                        } else {
                            out.push({ x: ix, y: iy });
                        }
                    }
                }
                out.push({
                    x: points[points.length - 1].x + normals[normals.length - 1].x * offset,
                    y: points[points.length - 1].y + normals[normals.length - 1].y * offset
                });
                return out;
            }

            function sanitizeSchema(data) {
                const schema = data && typeof data === 'object' ? data : {};
                schema.meta = schema.meta && typeof schema.meta === 'object' ? schema.meta : {};
                schema.meta.version = 1;
                schema.nodes = schema.nodes && typeof schema.nodes === 'object' ? schema.nodes : {};
                schema.links = Array.isArray(schema.links) ? schema.links.slice() : [];
                schema.routes = Array.isArray(schema.routes) ? schema.routes.map(route => ({ ...route })) : [];
                for (const route of schema.routes) {
                    route.path = Array.isArray(route.path) ? route.path.slice() : [];
                    route.stops = Array.isArray(route.stops) ? route.stops.filter(Boolean) : [];
                }
                return schema;
            }
            function buildLinkRecords(schema) {
                const records = [];
                const map = new Map();
                for (const link of schema.links) {
                    const nodeA = schema.nodes[link.a];
                    const nodeB = schema.nodes[link.b];
                    if (!nodeA || !nodeB) continue;
                    const geometry = computeLinkGeometry(nodeA, nodeB);
                    const key = [link.a, link.b].sort().join('::');
                    const record = {
                        key,
                        link,
                        geometry,
                        routeSet: []
                    };
                    records.push(record);
                    map.set(key, record);
                }
                const usage = new Map();
                for (const route of schema.routes) {
                    if (!Array.isArray(route.path)) continue;
                    for (let i = 0; i < route.path.length - 1; i++) {
                        const a = route.path[i];
                        const b = route.path[i + 1];
                        const key = [a, b].sort().join('::');
                        if (!usage.has(key)) usage.set(key, new Set());
                        usage.get(key).add(route.id);
                    }
                }
                for (const record of records) {
                    const set = usage.get(record.key);
                    record.routeSet = set ? Array.from(set).sort() : [];
                }
                return records;
            }

            function buildChains(schema) {
                const records = buildLinkRecords(schema);
                const adjacency = new Map();
                const addAdj = (nodeId, routeKey, record) => {
                    if (!adjacency.has(nodeId)) adjacency.set(nodeId, new Map());
                    const byRoute = adjacency.get(nodeId);
                    if (!byRoute.has(routeKey)) byRoute.set(routeKey, []);
                    byRoute.get(routeKey).push(record);
                };
                for (const record of records) {
                    if (!record.geometry || record.geometry.length < 2) continue;
                    const routeKey = record.routeSet.join('|');
                    addAdj(record.link.a, routeKey, record);
                    addAdj(record.link.b, routeKey, record);
                }
                const visited = new Set();
                const chains = [];
                const orient = (record, fromNodeId) => {
                    const points = record.geometry ? record.geometry.slice() : [];
                    if (fromNodeId === record.link.a) {
                        return { points: points.slice(), end: record.link.b };
                    }
                    return { points: points.slice().reverse(), end: record.link.a };
                };
                for (const record of records) {
                    if (!record.geometry || record.geometry.length < 2) continue;
                    if (record.routeSet.length === 0) continue;
                    if (visited.has(record.link.id)) continue;
                    const routeKey = record.routeSet.join('|');
                    const adjA = (adjacency.get(record.link.a)?.get(routeKey) || []).length;
                    const adjB = (adjacency.get(record.link.b)?.get(routeKey) || []).length;
                    let startNode = record.link.a;
                    if (adjA === 2 && adjB !== 2) {
                        startNode = record.link.b;
                    } else if (adjA !== 2 && adjB === 2) {
                        startNode = record.link.a;
                    } else if (adjA !== 2) {
                        startNode = record.link.a;
                    } else if (adjB !== 2) {
                        startNode = record.link.b;
                    }
                    const points = [];
                    const chainLinks = [];
                    const visitedLocal = new Set();
                    const first = orient(record, startNode);
                    points.push(...first.points);
                    chainLinks.push(record.link.id);
                    visited.add(record.link.id);
                    visitedLocal.add(record.link.id);

                    const extend = (nodeId, forward = true) => {
                        let currentNode = nodeId;
                        let lastId = record.link.id;
                        while (true) {
                            const options = (adjacency.get(currentNode)?.get(routeKey) || []).filter(rec => !visitedLocal.has(rec.link.id));
                            if (options.length !== 1) break;
                            const nextRecord = options[0];
                            const oriented = orient(nextRecord, currentNode);
                            const newPoints = oriented.points.slice();
                            if (forward) {
                                points.push(...newPoints.slice(1));
                            } else {
                                const rev = newPoints.slice().reverse();
                                rev.pop();
                                points.unshift(...rev);
                            }
                            currentNode = oriented.end;
                            visitedLocal.add(nextRecord.link.id);
                            visited.add(nextRecord.link.id);
                            chainLinks.push(nextRecord.link.id);
                            lastId = nextRecord.link.id;
                        }
                    };
                    extend(first.end, true);
                    extend(startNode, false);
                    const merged = mergeCollinear(points);
                    chains.push({
                        routeKey,
                        routeSet: record.routeSet.slice(),
                        points: merged,
                        links: chainLinks.slice()
                    });
                }
                return chains;
            }

            function computeBoundingBox(nodes) {
                const ids = Object.keys(nodes);
                if (ids.length === 0) {
                    return { x: 0, y: 0, width: 1600, height: 1200 };
                }
                let minX = Infinity;
                let maxX = -Infinity;
                let minY = Infinity;
                let maxY = -Infinity;
                for (const node of Object.values(nodes)) {
                    if (typeof node.x !== 'number' || typeof node.y !== 'number') continue;
                    minX = Math.min(minX, node.x);
                    maxX = Math.max(maxX, node.x);
                    minY = Math.min(minY, node.y);
                    maxY = Math.max(maxY, node.y);
                }
                if (!Number.isFinite(minX) || !Number.isFinite(minY)) {
                    return { x: 0, y: 0, width: 1600, height: 1200 };
                }
                const pad = 80;
                return {
                    x: minX - pad,
                    y: minY - pad,
                    width: (maxX - minX) + pad * 2,
                    height: (maxY - minY) + pad * 2
                };
            }
            class RenderView {
                constructor(app, svg) {
                    this.app = app;
                    this.svg = svg;
                    this.chainLayer = svg.querySelector('.layer-chains');
                    this.stopLayer = svg.querySelector('.layer-stops');
                    this.tickLayer = svg.querySelector('.layer-ticks');
                    this.viewBox = { x: 0, y: 0, width: 1600, height: 1200 };
                    this.isPanning = false;
                    this.panStart = null;

                    this.svg.addEventListener('pointerdown', this.onPointerDown.bind(this));
                    window.addEventListener('pointerup', this.onPointerUp.bind(this));
                    window.addEventListener('pointermove', this.onPointerMove.bind(this));
                    this.svg.addEventListener('wheel', this.onWheel.bind(this), { passive: false });
                }

                applyViewBox() {
                    const { x, y, width, height } = this.viewBox;
                    this.svg.setAttribute('viewBox', `${x} ${y} ${width} ${height}`);
                }

                onPointerDown(event) {
                    if (event.button !== 0) return;
                    this.isPanning = true;
                    this.svg.classList.add('is-dragging');
                    this.panStart = {
                        clientX: event.clientX,
                        clientY: event.clientY,
                        viewX: this.viewBox.x,
                        viewY: this.viewBox.y
                    };
                    event.preventDefault();
                }

                onPointerMove(event) {
                    if (!this.isPanning || !this.panStart) return;
                    const scaleX = this.viewBox.width / this.svg.clientWidth;
                    const scaleY = this.viewBox.height / this.svg.clientHeight;
                    const dx = (event.clientX - this.panStart.clientX) * scaleX;
                    const dy = (event.clientY - this.panStart.clientY) * scaleY;
                    this.viewBox.x = this.panStart.viewX - dx;
                    this.viewBox.y = this.panStart.viewY - dy;
                    this.applyViewBox();
                }

                onPointerUp() {
                    if (this.isPanning) {
                        this.isPanning = false;
                        this.svg.classList.remove('is-dragging');
                        this.panStart = null;
                    }
                }

                onWheel(event) {
                    if (!this.app.schema) return;
                    event.preventDefault();
                    const rect = this.svg.getBoundingClientRect();
                    const mx = (event.clientX - rect.left) / rect.width;
                    const my = (event.clientY - rect.top) / rect.height;
                    const direction = event.deltaY > 0 ? 1.1 : 0.9;
                    const newWidth = clamp(this.viewBox.width * direction, 200, 8000);
                    const newHeight = clamp(this.viewBox.height * direction, 200, 8000);
                    const dx = (this.viewBox.width - newWidth) * mx;
                    const dy = (this.viewBox.height - newHeight) * my;
                    this.viewBox = {
                        x: this.viewBox.x + dx,
                        y: this.viewBox.y + dy,
                        width: newWidth,
                        height: newHeight
                    };
                    this.applyViewBox();
                }

                render() {
                    const schema = this.app.schema;
                    if (!schema) return;
                    const bbox = computeBoundingBox(schema.nodes);
                    this.viewBox = { ...bbox };
                    this.applyViewBox();
                    const chains = buildChains(schema).sort((a, b) => a.routeKey.localeCompare(b.routeKey));
                    const routeMap = new Map(schema.routes.map(route => [route.id, route]));
                    this.chainLayer.innerHTML = '';
                    this.stopLayer.innerHTML = '';
                    this.tickLayer.innerHTML = '';

                    for (const chain of chains) {
                        if (!chain.points || chain.points.length < 2) continue;
                        const members = chain.routeSet
                            .map(id => routeMap.get(id))
                            .filter(Boolean)
                            .sort((a, b) => {
                                const nameA = (a.name || a.id || '').toLowerCase();
                                const nameB = (b.name || b.id || '').toLowerCase();
                                if (nameA !== nameB) return nameA.localeCompare(nameB);
                                const colorA = (a.color || '').toLowerCase();
                                const colorB = (b.color || '').toLowerCase();
                                if (colorA !== colorB) return colorA.localeCompare(colorB);
                                return (a.id || '').localeCompare(b.id || '');
                            });
                        const N = members.length || 1;
                        for (let i = 0; i < N; i++) {
                            const member = members[i];
                            const offset = (i - (N - 1) / 2) * (LINE_WIDTH + GAP);
                            const offsetPoints = N === 1 ? chain.points : offsetPolyline(chain.points, offset);
                            const clean = mergeCollinear(offsetPoints);
                            const d = pathFromPoints(clean);
                            const casing = createSvgElement('path', {
                                d,
                                fill: 'none',
                                stroke: '#ffffff',
                                'stroke-width': LINE_WIDTH + GAP * 2,
                                'stroke-linejoin': 'round',
                                'stroke-linecap': 'round',
                                'vector-effect': 'non-scaling-stroke'
                            });
                            const strokeColor = member?.color || '#222222';
                            const line = createSvgElement('path', {
                                d,
                                fill: 'none',
                                stroke: strokeColor,
                                'stroke-width': LINE_WIDTH,
                                'stroke-linejoin': 'round',
                                'stroke-linecap': 'round',
                                'vector-effect': 'non-scaling-stroke'
                            });
                            this.chainLayer.appendChild(casing);
                            this.chainLayer.appendChild(line);
                        }

                        if (chain.points.length >= 2) {
                            const tickSize = 8;
                            const startA = chain.points[0];
                            const startB = chain.points[1];
                            const endA = chain.points[chain.points.length - 1];
                            const endB = chain.points[chain.points.length - 2];
                            const ticks = [
                                { base: startA, next: startB },
                                { base: endA, next: endB }
                            ];
                            for (const tick of ticks) {
                                const dx = tick.next.x - tick.base.x;
                                const dy = tick.next.y - tick.base.y;
                                const len = Math.hypot(dx, dy) || 1;
                                const nx = -dy / len;
                                const ny = dx / len;
                                const a = {
                                    x: tick.base.x + nx * tickSize,
                                    y: tick.base.y + ny * tickSize
                                };
                                const b = {
                                    x: tick.base.x - nx * tickSize,
                                    y: tick.base.y - ny * tickSize
                                };
                                const tickPath = createSvgElement('line', {
                                    x1: a.x,
                                    y1: a.y,
                                    x2: b.x,
                                    y2: b.y,
                                    stroke: '#222222',
                                    'stroke-width': LINE_WIDTH,
                                    'vector-effect': 'non-scaling-stroke',
                                    'stroke-linecap': 'round'
                                });
                                this.tickLayer.appendChild(tickPath);
                            }
                        }
                    }

                    for (const [nodeId, node] of Object.entries(schema.nodes)) {
                        if (node.type !== 'stop') continue;
                        if (typeof node.x !== 'number' || typeof node.y !== 'number') continue;
                        const circle = createSvgElement('circle', {
                            cx: node.x,
                            cy: node.y,
                            r: STOP_RADIUS,
                            fill: '#ffffff',
                            stroke: '#222222',
                            'stroke-width': STOP_STROKE,
                            'vector-effect': 'non-scaling-stroke'
                        });
                        circle.dataset.id = nodeId;
                        this.stopLayer.appendChild(circle);
                    }

                    const meta = $('#renderMeta');
                    if (meta) {
                        const updated = schema.meta?.updatedAt;
                        const text = updated ? `Updated ${new Date(updated).toLocaleString()}` : 'Updated unknown';
                        meta.textContent = `${schema.routes.length} routes, ${Object.keys(schema.nodes).length} nodes. ${text}`;
                    }
                    this.renderLegend();
                }

                renderLegend() {
                    const legend = $('#routeLegend');
                    if (!legend) return;
                    legend.innerHTML = '';
                    const sorted = (this.app.schema?.routes || []).slice().sort((a, b) => {
                        const nameA = (a.name || a.id || '').toLowerCase();
                        const nameB = (b.name || b.id || '').toLowerCase();
                        if (nameA !== nameB) return nameA.localeCompare(nameB);
                        return (a.id || '').localeCompare(b.id || '');
                    });
                    for (const route of sorted) {
                        const li = document.createElement('li');
                        li.className = 'legend-item';
                        const swatch = document.createElement('span');
                        swatch.className = 'legend-swatch';
                        swatch.style.background = route.color || '#222';
                        const name = document.createElement('span');
                        name.className = 'legend-name';
                        name.textContent = route.name || route.id || 'Route';
                        li.appendChild(swatch);
                        li.appendChild(name);
                        legend.appendChild(li);
                    }
                }
            }
            class EditorView {
                constructor(app, svg) {
                    this.app = app;
                    this.svg = svg;
                    this.gridLayer = svg.querySelector('.layer.grid');
                    this.previewLayer = svg.querySelector('.layer.preview');
                    this.linkLayer = svg.querySelector('.layer.links');
                    this.nodeLayer = svg.querySelector('.layer.nodes');
                    this.labelLayer = svg.querySelector('.layer.labels');
                    this.toolButtons = $$('#toolGrid .tool-button');
                    this.routeListEl = $('#routeList');
                    this.routeEditorEl = $('#routeEditor');
                    this.nodeDetailsEl = $('#nodeDetails');
                    this.cursorReadout = $('#cursorReadout');
                    this.toolHintEl = $('#toolHint');
                    this.addRouteBtn = $('#addRouteBtn');
                    this.saveBtn = $('#saveBtn');
                    this.importBtn = $('#importBtn');

                    this.selectedTool = 'select';
                    this.selectedNodeId = null;
                    this.selectedRouteId = null;
                    this.linkingFrom = null;
                    this.measureStart = null;
                    this.isPanning = false;
                    this.panStart = null;
                    this.dragState = null;
                    this.viewBox = { x: 0, y: 0, width: 1600, height: 1200 };

                    this.toolButtons.forEach(btn => {
                        btn.addEventListener('click', () => {
                            this.setTool(btn.dataset.tool);
                        });
                    });

                    if (this.addRouteBtn) {
                        this.addRouteBtn.addEventListener('click', () => this.handleAddRoute());
                    }

                    this.svg.addEventListener('pointerdown', this.onPointerDown.bind(this));
                    this.svg.addEventListener('wheel', this.onWheel.bind(this), { passive: false });
                    window.addEventListener('pointermove', this.onPointerMove.bind(this));
                    window.addEventListener('pointerup', this.onPointerUp.bind(this));
                    window.addEventListener('keydown', (event) => {
                        if (event.key === 'Escape') {
                            this.linkingFrom = null;
                            this.measureStart = null;
                            this.previewLayer.innerHTML = '';
                            this.updateToolHint();
                        }
                    });
                }

                setTool(tool) {
                    this.selectedTool = tool;
                    this.toolButtons.forEach(btn => btn.classList.toggle('is-active', btn.dataset.tool === tool));
                    if (tool !== 'link') {
                        this.linkingFrom = null;
                        this.previewLayer.innerHTML = '';
                    }
                    if (tool !== 'measure') {
                        this.measureStart = null;
                    }
                    this.updateToolHint();
                }

                updateToolHint() {
                    if (!this.toolHintEl) return;
                    const hints = {
                        select: 'Drag nodes to move. Shift-drag to constrain axis.',
                        'add-stop': 'Click on the map to place a stop node.',
                        'add-bend': 'Click to place a bend node used for geometry control.',
                        link: this.linkingFrom ? 'Select the second node to create a link.' : 'Click the first node to begin linking.',
                        route: 'Click nodes in order to extend the selected route path.',
                        stop: 'Click a node on the selected route to toggle stop placement.',
                        delete: 'Click a node or link to remove it from the schema.',
                        measure: this.measureStart ? 'Select another node to measure the straight-line distance.' : 'Click the first node to begin measuring.'
                    };
                    this.toolHintEl.textContent = hints[this.selectedTool] || '';
                }

                applyViewBox() {
                    const { x, y, width, height } = this.viewBox;
                    this.svg.setAttribute('viewBox', `${x} ${y} ${width} ${height}`);
                }

                onPointerDown(event) {
                    const target = event.target;
                    if (target.closest('[data-node-id]')) {
                        return;
                    }
                    if (this.selectedTool === 'add-stop' || this.selectedTool === 'add-bend') {
                        const pt = this.toSvgPoint(event);
                        if (!pt) return;
                        if (this.selectedTool === 'add-stop') {
                            this.addStopNode(pt);
                        } else {
                            this.addBendNode(pt);
                        }
                        event.preventDefault();
                        return;
                    }
                    if (event.button !== 0) return;
                    this.isPanning = true;
                    this.svg.classList.add('is-dragging');
                    this.panStart = {
                        clientX: event.clientX,
                        clientY: event.clientY,
                        viewX: this.viewBox.x,
                        viewY: this.viewBox.y
                    };
                    event.preventDefault();
                }

                onPointerMove(event) {
                    if (this.dragState) {
                        this.handleNodeDrag(event);
                        return;
                    }
                    if (!this.isPanning || !this.panStart) {
                        if (this.cursorReadout) {
                            const pt = this.toSvgPoint(event);
                            if (pt) {
                                this.cursorReadout.textContent = `${pt.x.toFixed(1)}, ${pt.y.toFixed(1)}`;
                            }
                        }
                        return;
                    }
                    const scaleX = this.viewBox.width / this.svg.clientWidth;
                    const scaleY = this.viewBox.height / this.svg.clientHeight;
                    const dx = (event.clientX - this.panStart.clientX) * scaleX;
                    const dy = (event.clientY - this.panStart.clientY) * scaleY;
                    this.viewBox.x = this.panStart.viewX - dx;
                    this.viewBox.y = this.panStart.viewY - dy;
                    this.applyViewBox();
                }

                onPointerUp() {
                    if (this.dragState) {
                        this.dragState = null;
                        return;
                    }
                    if (this.isPanning) {
                        this.isPanning = false;
                        this.svg.classList.remove('is-dragging');
                        this.panStart = null;
                    }
                }

                onWheel(event) {
                    event.preventDefault();
                    const rect = this.svg.getBoundingClientRect();
                    const mx = (event.clientX - rect.left) / rect.width;
                    const my = (event.clientY - rect.top) / rect.height;
                    const direction = event.deltaY > 0 ? 1.1 : 0.9;
                    const newWidth = clamp(this.viewBox.width * direction, 200, 8000);
                    const newHeight = clamp(this.viewBox.height * direction, 200, 8000);
                    const dx = (this.viewBox.width - newWidth) * mx;
                    const dy = (this.viewBox.height - newHeight) * my;
                    this.viewBox = {
                        x: this.viewBox.x + dx,
                        y: this.viewBox.y + dy,
                        width: newWidth,
                        height: newHeight
                    };
                    this.applyViewBox();
                }

                toSvgPoint(event) {
                    const pt = this.svg.createSVGPoint();
                    pt.x = event.clientX;
                    pt.y = event.clientY;
                    const matrix = this.svg.getScreenCTM();
                    if (!matrix) return null;
                    const transformed = pt.matrixTransform(matrix.inverse());
                    return { x: transformed.x, y: transformed.y };
                }
                addStopNode(pt) {
                    const name = window.prompt('Stop name?');
                    if (name === null) return;
                    const label = name.trim() || 'Stop';
                    const id = this.generateStopId(label);
                    this.app.schema.nodes[id] = {
                        name: label,
                        x: pt.x,
                        y: pt.y,
                        type: 'stop'
                    };
                    this.selectedNodeId = id;
                    this.app.markDirty();
                    this.render();
                    this.app.renderView.render();
                }

                addBendNode(pt) {
                    const id = this.generateBendId();
                    this.app.schema.nodes[id] = {
                        name: `Bend ${id.split(':')[1] || id}`,
                        x: pt.x,
                        y: pt.y,
                        type: 'bend'
                    };
                    this.selectedNodeId = id;
                    this.app.markDirty();
                    this.render();
                    this.app.renderView.render();
                }

                generateStopId(name) {
                    const base = 'STOP:' + (name || 'NODE').toUpperCase().replace(/[^A-Z0-9]+/g, '_').replace(/^_+|_+$/g, '') || 'STOP';
                    let candidate = base;
                    let attempt = 2;
                    while (this.app.schema.nodes[candidate]) {
                        candidate = `${base}_${attempt}`;
                        attempt += 1;
                    }
                    return candidate;
                }

                generateBendId() {
                    let idx = 1;
                    let candidate = `BEND:${String(idx).padStart(3, '0')}`;
                    while (this.app.schema.nodes[candidate]) {
                        idx += 1;
                        candidate = `BEND:${String(idx).padStart(3, '0')}`;
                    }
                    return candidate;
                }

                handleNodePointerDown(event, nodeId) {
                    if (event.button !== 0) return;
                    event.preventDefault();
                    const node = this.app.schema.nodes[nodeId];
                    if (!node) return;
                    const start = this.toSvgPoint(event);
                    if (!start) return;
                    const target = event.target;
                    if (target.setPointerCapture) {
                        try { target.setPointerCapture(event.pointerId); } catch (_) {}
                    }
                    this.dragState = {
                        nodeId,
                        pointerId: event.pointerId,
                        origin: { x: node.x, y: node.y },
                        start,
                        moved: false
                    };
                    this.selectedNodeId = nodeId;
                    this.updateNodeDetails();
                }

                handleNodeDrag(event) {
                    if (!this.dragState || event.pointerId !== this.dragState.pointerId) return;
                    const pt = this.toSvgPoint(event);
                    if (!pt) return;
                    const node = this.app.schema.nodes[this.dragState.nodeId];
                    if (!node) return;
                    let dx = pt.x - this.dragState.start.x;
                    let dy = pt.y - this.dragState.start.y;
                    let newX = this.dragState.origin.x + dx;
                    let newY = this.dragState.origin.y + dy;
                    if (event.shiftKey) {
                        if (Math.abs(dx) > Math.abs(dy)) {
                            newY = this.dragState.origin.y;
                        } else {
                            newX = this.dragState.origin.x;
                        }
                    }
                    if (Math.abs(newX - node.x) > 0.1 || Math.abs(newY - node.y) > 0.1) {
                        this.dragState.moved = true;
                    }
                    node.x = newX;
                    node.y = newY;
                    this.app.markDirty();
                    this.render();
                    this.app.renderView.render();
                    this.skipClickNodeId = this.dragState.nodeId;
                }

                handleNodeClick(event, nodeId) {
                    if (this.skipClickNodeId === nodeId) {
                        this.skipClickNodeId = null;
                        return;
                    }
                    const node = this.app.schema.nodes[nodeId];
                    if (!node) return;
                    if (this.selectedTool === 'select') {
                        this.selectedNodeId = nodeId;
                        this.updateNodeDetails();
                        return;
                    }
                    if (this.selectedTool === 'link') {
                        if (!this.linkingFrom) {
                            this.linkingFrom = nodeId;
                            this.previewLayer.innerHTML = '';
                            this.updateToolHint();
                        } else if (this.linkingFrom !== nodeId) {
                            this.createLink(this.linkingFrom, nodeId);
                            this.linkingFrom = null;
                            this.previewLayer.innerHTML = '';
                            this.updateToolHint();
                        }
                        return;
                    }
                    if (this.selectedTool === 'route') {
                        this.addNodeToRoute(nodeId);
                        return;
                    }
                    if (this.selectedTool === 'stop') {
                        this.toggleStop(nodeId);
                        return;
                    }
                    if (this.selectedTool === 'delete') {
                        this.deleteNode(nodeId);
                        return;
                    }
                    if (this.selectedTool === 'measure') {
                        if (!this.measureStart) {
                            this.measureStart = nodeId;
                            this.updateToolHint();
                        } else {
                            const other = this.app.schema.nodes[this.measureStart];
                            if (other) {
                                const dist = distance(other, node);
                                if (this.toolHintEl) {
                                    this.toolHintEl.textContent = `Distance: ${dist.toFixed(1)} px`;
                                }
                            }
                            this.measureStart = null;
                        }
                        return;
                    }
                }

                handleLinkClick(event, linkId) {
                    if (this.selectedTool !== 'delete') return;
                    event.stopPropagation();
                    const link = this.app.schema.links.find(l => l.id === linkId);
                    if (!link) return;
                    if (!window.confirm(`Delete link ${link.id}?`)) return;
                    this.app.schema.links = this.app.schema.links.filter(l => l.id !== linkId);
                    this.app.markDirty();
                    this.render();
                    this.app.renderView.render();
                }

                createLink(a, b) {
                    if (a === b) return;
                    const key = [a, b].sort().join('::');
                    const exists = this.app.schema.links.some(link => [link.a, link.b].sort().join('::') === key);
                    if (exists) {
                        this.app.showToast && this.app.showToast('Link already exists');
                        return;
                    }
                    const nextId = this.generateLinkId();
                    this.app.schema.links.push({ id: nextId, a, b });
                    this.app.markDirty();
                    this.render();
                    this.app.renderView.render();
                }

                generateLinkId() {
                    let max = 0;
                    for (const link of this.app.schema.links) {
                        const m = /^L(\d+)/.exec(link.id || '');
                        if (m) {
                            max = Math.max(max, parseInt(m[1], 10));
                        }
                    }
                    const next = max + 1;
                    return `L${String(next).padStart(3, '0')}`;
                }

                deleteNode(nodeId) {
                    if (!window.confirm(`Delete node ${nodeId}? This removes linked segments and route references.`)) return;
                    delete this.app.schema.nodes[nodeId];
                    this.app.schema.links = this.app.schema.links.filter(link => link.a !== nodeId && link.b !== nodeId);
                    for (const route of this.app.schema.routes) {
                        route.path = route.path.filter(id => id !== nodeId);
                        route.stops = Array.isArray(route.stops) ? route.stops.filter(stop => stop.node !== nodeId) : [];
                    }
                    this.selectedNodeId = null;
                    this.app.markDirty();
                    this.render();
                    this.app.renderView.render();
                }

                addNodeToRoute(nodeId) {
                    const route = this.getSelectedRoute();
                    if (!route) {
                        this.app.showToast && this.app.showToast('Select a route first', true);
                        return;
                    }
                    route.path = Array.isArray(route.path) ? route.path : [];
                    route.path.push(nodeId);
                    this.app.markDirty();
                    this.renderRouteEditor();
                    this.render();
                    this.app.renderView.render();
                }

                toggleStop(nodeId) {
                    const route = this.getSelectedRoute();
                    if (!route) return;
                    route.stops = Array.isArray(route.stops) ? route.stops : [];
                    const index = route.stops.findIndex(stop => stop.node === nodeId);
                    if (index >= 0) {
                        route.stops.splice(index, 1);
                    } else {
                        route.stops.push({ node: nodeId });
                    }
                    this.app.markDirty();
                    this.renderRouteEditor();
                    this.app.renderView.render();
                }

                handleAddRoute() {
                    const id = window.prompt('Route ID?', 'ROUTE');
                    if (!id) return;
                    const name = window.prompt('Route name?', id) || id;
                    const color = window.prompt('Route color hex?', '#0072ce') || '#0072ce';
                    const route = {
                        id,
                        name,
                        color,
                        path: [],
                        stops: []
                    };
                    this.app.schema.routes.push(route);
                    this.selectedRouteId = id;
                    this.app.markDirty();
                    this.render();
                    this.app.renderView.render();
                }
                getSelectedRoute() {
                    if (!this.selectedRouteId) return null;
                    return this.app.schema.routes.find(route => route.id === this.selectedRouteId) || null;
                }

                render() {
                    const schema = this.app.schema;
                    if (!schema) return;
                    if (!this.selectedRouteId && schema.routes.length) {
                        this.selectedRouteId = schema.routes[0].id;
                    }
                    const bbox = computeBoundingBox(schema.nodes);
                    this.viewBox = { ...bbox };
                    this.applyViewBox();
                    this.renderLinks();
                    this.renderNodes();
                    this.renderRouteList();
                    this.renderRouteEditor();
                    this.renderRoutePreview();
                    this.updateNodeDetails();
                    this.updateToolHint();
                }

                renderLinks() {
                    this.linkLayer.innerHTML = '';
                    const schema = this.app.schema;
                    const route = this.getSelectedRoute();
                    const routePairs = new Set();
                    if (route && Array.isArray(route.path)) {
                        for (let i = 0; i < route.path.length - 1; i++) {
                            const key = [route.path[i], route.path[i + 1]].sort().join('::');
                            routePairs.add(key);
                        }
                    }
                    for (const link of schema.links) {
                        const nodeA = schema.nodes[link.a];
                        const nodeB = schema.nodes[link.b];
                        if (!nodeA || !nodeB) continue;
                        const geometry = computeLinkGeometry(nodeA, nodeB);
                        if (!geometry) continue;
                        const d = pathFromPoints(geometry);
                        const isInRoute = routePairs.has([link.a, link.b].sort().join('::'));
                        const path = createSvgElement('path', {
                            d,
                            fill: 'none',
                            stroke: isInRoute ? (route?.color || '#3657ff') : '#bdc4d6',
                            'stroke-width': isInRoute ? 6 : 3,
                            'stroke-linecap': 'round',
                            'stroke-linejoin': 'round',
                            'vector-effect': 'non-scaling-stroke',
                            'data-link-id': link.id
                        });
                        path.addEventListener('click', (event) => this.handleLinkClick(event, link.id));
                        this.linkLayer.appendChild(path);
                    }
                }

                renderNodes() {
                    this.nodeLayer.innerHTML = '';
                    this.labelLayer.innerHTML = '';
                    const schema = this.app.schema;
                    for (const [nodeId, node] of Object.entries(schema.nodes)) {
                        if (typeof node.x !== 'number' || typeof node.y !== 'number') continue;
                        const group = createSvgElement('g', {
                            'data-node-id': nodeId,
                            cursor: 'pointer'
                        });
                        let shape;
                        if (node.type === 'stop') {
                            shape = createSvgElement('circle', {
                                cx: node.x,
                                cy: node.y,
                                r: 8,
                                fill: '#ffffff',
                                stroke: nodeId === this.selectedNodeId ? '#ff5722' : '#1a1f2b',
                                'stroke-width': nodeId === this.selectedNodeId ? 3 : 2,
                                'vector-effect': 'non-scaling-stroke'
                            });
                        } else {
                            shape = createSvgElement('rect', {
                                x: node.x - 6,
                                y: node.y - 6,
                                width: 12,
                                height: 12,
                                rx: 2,
                                ry: 2,
                                fill: '#f1f3fb',
                                stroke: nodeId === this.selectedNodeId ? '#ff5722' : '#425175',
                                'stroke-width': nodeId === this.selectedNodeId ? 3 : 2,
                                'vector-effect': 'non-scaling-stroke'
                            });
                        }
                        group.appendChild(shape);
                        group.addEventListener('pointerdown', (event) => this.handleNodePointerDown(event, nodeId));
                        group.addEventListener('click', (event) => {
                            event.stopPropagation();
                            this.handleNodeClick(event, nodeId);
                        });
                        group.addEventListener('pointerenter', () => this.previewLinkTo(nodeId));
                        group.addEventListener('pointerleave', () => this.clearPreview());
                        this.nodeLayer.appendChild(group);

                        const label = createSvgElement('text', {
                            x: node.x + 12,
                            y: node.y - 12,
                            fill: '#1a1f2b',
                            'font-size': '12px',
                            'font-weight': node.type === 'stop' ? '600' : '400',
                            'paint-order': 'stroke',
                            stroke: '#ffffff',
                            'stroke-width': 3,
                            'stroke-linejoin': 'round'
                        });
                        label.textContent = node.name || nodeId;
                        this.labelLayer.appendChild(label);
                    }
                }

                previewLinkTo(nodeId) {
                    if (this.selectedTool !== 'link' || !this.linkingFrom || this.linkingFrom === nodeId) {
                        this.previewLayer.innerHTML = '';
                        return;
                    }
                    const nodeA = this.app.schema.nodes[this.linkingFrom];
                    const nodeB = this.app.schema.nodes[nodeId];
                    if (!nodeA || !nodeB) return;
                    const geometry = computeLinkGeometry(nodeA, nodeB);
                    if (!geometry) return;
                    const path = createSvgElement('path', {
                        d: pathFromPoints(geometry),
                        fill: 'none',
                        stroke: '#3657ff',
                        'stroke-width': 4,
                        'stroke-dasharray': '8 6',
                        'vector-effect': 'non-scaling-stroke'
                    });
                    this.previewLayer.innerHTML = '';
                    this.previewLayer.appendChild(path);
                }

                clearPreview() {
                    if (this.selectedTool !== 'link') return;
                    this.previewLayer.innerHTML = '';
                }

                renderRouteList() {
                    if (!this.routeListEl) return;
                    this.routeListEl.innerHTML = '';
                    const routes = this.app.schema.routes.slice().sort((a, b) => (a.name || a.id || '').localeCompare(b.name || b.id || ''));
                    for (const route of routes) {
                        const item = document.createElement('div');
                        item.className = 'route-item' + (route.id === this.selectedRouteId ? ' is-active' : '');
                        item.dataset.routeId = route.id;
                        const swatch = document.createElement('span');
                        swatch.className = 'route-color';
                        swatch.style.background = route.color || '#3657ff';
                        const label = document.createElement('span');
                        label.textContent = route.name || route.id;
                        item.appendChild(swatch);
                        item.appendChild(label);
                        item.addEventListener('click', () => {
                            this.selectedRouteId = route.id;
                            this.renderRouteList();
                            this.renderRouteEditor();
                            this.renderRoutePreview();
                            this.renderLinks();
                        });
                        this.routeListEl.appendChild(item);
                    }
                    if (!routes.length) {
                        const empty = document.createElement('p');
                        empty.className = 'small-note';
                        empty.textContent = 'No routes defined yet. Add one to begin building paths.';
                        this.routeListEl.appendChild(empty);
                    }
                }

                renderRouteEditor() {
                    if (!this.routeEditorEl) return;
                    this.routeEditorEl.innerHTML = '';
                    const route = this.getSelectedRoute();
                    if (!route) {
                        const empty = document.createElement('p');
                        empty.className = 'small-note';
                        empty.textContent = 'Select a route to edit its path and stops.';
                        this.routeEditorEl.appendChild(empty);
                        return;
                    }
                    const nameRow = document.createElement('div');
                    nameRow.className = 'form-row';
                    const nameLabel = document.createElement('label');
                    nameLabel.textContent = 'Route name';
                    const nameInput = document.createElement('input');
                    nameInput.type = 'text';
                    nameInput.value = route.name || '';
                    nameInput.addEventListener('input', () => {
                        route.name = nameInput.value;
                        this.app.markDirty();
                        this.renderRouteList();
                        this.app.renderView.render();
                    });
                    nameRow.appendChild(nameLabel);
                    nameRow.appendChild(nameInput);

                    const colorRow = document.createElement('div');
                    colorRow.className = 'form-row';
                    const colorLabel = document.createElement('label');
                    colorLabel.textContent = 'Color';
                    const colorInput = document.createElement('input');
                    colorInput.type = 'color';
                    colorInput.value = route.color || '#3657ff';
                    colorInput.addEventListener('input', () => {
                        route.color = colorInput.value;
                        this.app.markDirty();
                        this.renderRouteList();
                        this.app.renderView.render();
                        this.renderLinks();
                        this.renderRoutePreview();
                    });
                    colorRow.appendChild(colorLabel);
                    colorRow.appendChild(colorInput);

                    const list = document.createElement('div');
                    list.className = 'route-path-list';
                    route.path = Array.isArray(route.path) ? route.path : [];
                    if (!route.path.length) {
                        const empty = document.createElement('p');
                        empty.className = 'small-note';
                        empty.textContent = 'Click nodes with the Route Builder tool to add them here.';
                        list.appendChild(empty);
                    }
                    const stopsSet = new Set(route.stops?.map(stop => stop.node));
                    route.path.forEach((nodeId, index) => {
                        const pill = document.createElement('div');
                        pill.className = 'path-pill';
                        const label = document.createElement('span');
                        label.textContent = this.app.schema.nodes[nodeId]?.name || nodeId;
                        const stopBtn = document.createElement('button');
                        stopBtn.textContent = 'Stop';
                        stopBtn.classList.toggle('is-stop', stopsSet.has(nodeId));
                        stopBtn.addEventListener('click', () => {
                            this.toggleStop(nodeId);
                            this.renderRouteEditor();
                        });
                        const upBtn = document.createElement('button');
                        upBtn.textContent = '↑';
                        upBtn.disabled = index === 0;
                        upBtn.addEventListener('click', () => {
                            if (index === 0) return;
                            [route.path[index - 1], route.path[index]] = [route.path[index], route.path[index - 1]];
                            this.app.markDirty();
                            this.renderRouteEditor();
                            this.app.renderView.render();
                            this.renderRoutePreview();
                        });
                        const downBtn = document.createElement('button');
                        downBtn.textContent = '↓';
                        downBtn.disabled = index === route.path.length - 1;
                        downBtn.addEventListener('click', () => {
                            if (index === route.path.length - 1) return;
                            [route.path[index], route.path[index + 1]] = [route.path[index + 1], route.path[index]];
                            this.app.markDirty();
                            this.renderRouteEditor();
                            this.app.renderView.render();
                            this.renderRoutePreview();
                        });
                        const removeBtn = document.createElement('button');
                        removeBtn.textContent = '✕';
                        removeBtn.addEventListener('click', () => {
                            route.path.splice(index, 1);
                            route.stops = route.stops.filter(stop => stop.node !== nodeId);
                            this.app.markDirty();
                            this.renderRouteEditor();
                            this.app.renderView.render();
                            this.renderRoutePreview();
                        });
                        pill.appendChild(label);
                        pill.appendChild(stopBtn);
                        pill.appendChild(upBtn);
                        pill.appendChild(downBtn);
                        pill.appendChild(removeBtn);
                        list.appendChild(pill);
                    });

                    const controls = document.createElement('div');
                    controls.style.display = 'flex';
                    controls.style.gap = '0.5rem';
                    controls.style.flexWrap = 'wrap';
                    const clearBtn = document.createElement('button');
                    clearBtn.className = 'text';
                    clearBtn.textContent = 'Clear path';
                    clearBtn.addEventListener('click', () => {
                        route.path = [];
                        route.stops = [];
                        this.app.markDirty();
                        this.renderRouteEditor();
                        this.app.renderView.render();
                        this.renderRoutePreview();
                    });
                    controls.appendChild(clearBtn);

                    this.routeEditorEl.appendChild(nameRow);
                    this.routeEditorEl.appendChild(colorRow);
                    this.routeEditorEl.appendChild(list);
                    this.routeEditorEl.appendChild(controls);
                }

                renderRoutePreview() {
                    this.previewLayer.innerHTML = '';
                    const route = this.getSelectedRoute();
                    if (!route || !Array.isArray(route.path) || route.path.length < 2) return;
                    const points = [];
                    for (let i = 0; i < route.path.length - 1; i++) {
                        const nodeA = this.app.schema.nodes[route.path[i]];
                        const nodeB = this.app.schema.nodes[route.path[i + 1]];
                        if (!nodeA || !nodeB) continue;
                        const geom = computeLinkGeometry(nodeA, nodeB);
                        if (!geom) continue;
                        if (!points.length) {
                            points.push(...geom);
                        } else {
                            points.push(...geom.slice(1));
                        }
                    }
                    if (!points.length) return;
                    const path = createSvgElement('path', {
                        d: pathFromPoints(points),
                        fill: 'none',
                        stroke: route.color || '#3657ff',
                        'stroke-width': 5,
                        'stroke-dasharray': '10 6',
                        'vector-effect': 'non-scaling-stroke'
                    });
                    this.previewLayer.appendChild(path);
                }

                updateNodeDetails() {
                    if (!this.nodeDetailsEl) return;
                    const node = this.selectedNodeId ? this.app.schema.nodes[this.selectedNodeId] : null;
                    if (!node) {
                        this.nodeDetailsEl.innerHTML = 'Select a node to edit name or coordinates.';
                        return;
                    }
                    const container = document.createElement('div');
                    container.className = 'form-row';
                    const title = document.createElement('div');
                    title.className = 'small-note';
                    title.textContent = `${this.selectedNodeId} (${node.type})`;
                    const nameInput = document.createElement('input');
                    nameInput.type = 'text';
                    nameInput.value = node.name || '';
                    nameInput.addEventListener('input', () => {
                        node.name = nameInput.value;
                        this.app.markDirty();
                        this.renderNodes();
                        this.app.renderView.render();
                    });
                    const xInput = document.createElement('input');
                    xInput.type = 'number';
                    xInput.step = '1';
                    xInput.value = node.x.toFixed(1);
                    xInput.addEventListener('change', () => {
                        const value = parseFloat(xInput.value);
                        if (Number.isFinite(value)) {
                            node.x = value;
                            this.app.markDirty();
                            this.render();
                            this.app.renderView.render();
                        }
                    });
                    const yInput = document.createElement('input');
                    yInput.type = 'number';
                    yInput.step = '1';
                    yInput.value = node.y.toFixed(1);
                    yInput.addEventListener('change', () => {
                        const value = parseFloat(yInput.value);
                        if (Number.isFinite(value)) {
                            node.y = value;
                            this.app.markDirty();
                            this.render();
                            this.app.renderView.render();
                        }
                    });
                    const xLabel = document.createElement('label');
                    xLabel.textContent = 'X';
                    const yLabel = document.createElement('label');
                    yLabel.textContent = 'Y';

                    const coordinateWrapper = document.createElement('div');
                    coordinateWrapper.style.display = 'grid';
                    coordinateWrapper.style.gridTemplateColumns = 'auto 1fr';
                    coordinateWrapper.style.gap = '0.35rem 0.5rem';
                    coordinateWrapper.style.alignItems = 'center';
                    coordinateWrapper.appendChild(xLabel);
                    coordinateWrapper.appendChild(xInput);
                    coordinateWrapper.appendChild(yLabel);
                    coordinateWrapper.appendChild(yInput);

                    container.appendChild(title);
                    container.appendChild(nameInput);
                    container.appendChild(coordinateWrapper);
                    this.nodeDetailsEl.innerHTML = '';
                    this.nodeDetailsEl.appendChild(container);
                }
            }
            class SchematicApp {
                constructor() {
                    this.schema = null;
                    this.dirty = false;
                    this.saveInFlight = false;
                    this.lastUpdatedAt = null;
                    this.statusEl = $('#saveStatus');
                    this.toastEl = $('#toast');
                    this.renderPane = $('#renderPane');
                    this.editorPane = $('#editorPane');
                    this.modeButtons = $$('.mode-button');
                    this.renderView = new RenderView(this, $('#renderSvg'));
                    this.editorView = new EditorView(this, $('#editorSvg'));
                    this.mode = this.initialMode();
                    this.autosaveHandle = null;

                    this.modeButtons.forEach(btn => {
                        btn.addEventListener('click', () => this.setMode(btn.dataset.mode));
                    });

                    const saveBtn = $('#saveBtn');
                    if (saveBtn) saveBtn.addEventListener('click', () => this.saveSchema());
                    const importBtn = $('#importBtn');
                    if (importBtn) importBtn.addEventListener('click', () => this.importStops());
                }

                initialMode() {
                    const params = new URLSearchParams(window.location.search);
                    const mode = params.get('mode');
                    if (mode === 'edit') return 'edit';
                    return 'render';
                }

                async init() {
                    try {
                        await this.loadSchema();
                        this.setMode(this.mode, false);
                        this.startAutosave();
                    } catch (err) {
                        console.error(err);
                        this.showToast('Failed to load schematic data', true);
                    }
                }

                async loadSchema() {
                    this.setStatus('Loading…');
                    const res = await fetch('/api/schema');
                    if (!res.ok) {
                        throw new Error(`Load failed: ${res.status}`);
                    }
                    const payload = await res.json();
                    this.schema = sanitizeSchema(payload);
                    this.lastUpdatedAt = this.schema.meta?.updatedAt || null;
                    this.dirty = false;
                    this.updateStatus();
                    this.renderView.render();
                    this.editorView.render();
                }

                setStatus(text) {
                    if (this.statusEl) {
                        this.statusEl.textContent = text;
                    }
                }

                updateStatus() {
                    if (!this.statusEl) return;
                    if (this.dirty) {
                        this.statusEl.textContent = 'Unsaved changes';
                        this.statusEl.classList.add('is-dirty');
                    } else if (this.lastUpdatedAt) {
                        this.statusEl.textContent = `Saved ${new Date(this.lastUpdatedAt).toLocaleString()}`;
                        this.statusEl.classList.remove('is-dirty');
                    } else {
                        this.statusEl.textContent = 'Loaded';
                        this.statusEl.classList.remove('is-dirty');
                    }
                }

                markDirty() {
                    if (!this.dirty) {
                        this.dirty = true;
                        this.updateStatus();
                    }
                }

                setMode(mode, pushState = true) {
                    this.mode = mode === 'edit' ? 'edit' : 'render';
                    this.modeButtons.forEach(btn => btn.classList.toggle('is-active', btn.dataset.mode === this.mode));
                    if (this.mode === 'edit') {
                        this.renderPane?.classList.remove('is-visible');
                        this.editorPane?.classList.add('is-visible');
                        this.editorView.render();
                    } else {
                        this.renderPane?.classList.add('is-visible');
                        this.editorPane?.classList.remove('is-visible');
                        this.renderView.render();
                    }
                    if (pushState) {
                        const params = new URLSearchParams(window.location.search);
                        params.set('mode', this.mode);
                        window.history.replaceState({}, '', `${window.location.pathname}?${params.toString()}`);
                    }
                }

                async saveSchema() {
                    if (!this.schema) return;
                    if (this.saveInFlight) return;
                    this.validateBeforeSave();
                    const payload = JSON.stringify(this.schema, null, 2);
                    this.saveInFlight = true;
                    this.setStatus('Saving…');
                    try {
                        const res = await fetch('/api/schema', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: payload
                        });
                        if (!res.ok) {
                            const body = await res.json().catch(() => ({}));
                            throw new Error(body.errors ? body.errors.join(', ') : body.error || `Save failed (${res.status})`);
                        }
                        const reply = await res.json();
                        this.dirty = false;
                        this.lastUpdatedAt = reply.updatedAt || new Date().toISOString();
                        if (this.schema.meta) {
                            this.schema.meta.updatedAt = this.lastUpdatedAt;
                        }
                        this.showToast('Saved schematic');
                    } catch (err) {
                        console.error(err);
                        this.showToast(`Save failed: ${err.message}`, true);
                    } finally {
                        this.saveInFlight = false;
                        this.updateStatus();
                    }
                }

                startAutosave() {
                    if (this.autosaveHandle) {
                        clearInterval(this.autosaveHandle);
                    }
                    this.autosaveHandle = setInterval(() => {
                        if (this.dirty && !this.saveInFlight) {
                            this.saveSchema();
                        }
                    }, 5000);
                }

                showToast(message, isError = false) {
                    if (!this.toastEl) return;
                    this.toastEl.textContent = message;
                    this.toastEl.classList.toggle('is-error', isError);
                    this.toastEl.classList.add('is-visible');
                    this.toastEl.classList.remove('hidden');
                    clearTimeout(this.toastTimer);
                    this.toastTimer = setTimeout(() => {
                        this.toastEl?.classList.remove('is-visible');
                    }, 2600);
                }

                validateBeforeSave() {
                    if (!this.schema) return;
                    const nodes = this.schema.nodes || {};
                    this.schema.links = Array.isArray(this.schema.links) ? this.schema.links : [];
                    this.schema.routes = Array.isArray(this.schema.routes) ? this.schema.routes : [];
                    const cleanedLinks = [];
                    const linkKeys = new Set();
                    let nextIdCounter = this.generateLinkIdSeed();
                    for (const link of this.schema.links) {
                        if (!nodes[link.a] || !nodes[link.b] || link.a === link.b) continue;
                        const key = [link.a, link.b].sort().join('::');
                        if (linkKeys.has(key)) continue;
                        linkKeys.add(key);
                        const id = link.id && typeof link.id === 'string' ? link.id : `L${String(nextIdCounter++).padStart(3, '0')}`;
                        cleanedLinks.push({ id, a: link.a, b: link.b });
                    }
                    this.schema.links = cleanedLinks;
                    const linkMap = new Map(this.schema.links.map(link => [[link.a, link.b].sort().join('::'), link]));
                    for (const route of this.schema.routes) {
                        route.path = Array.isArray(route.path) ? route.path.filter(id => nodes[id]) : [];
                        route.stops = Array.isArray(route.stops) ? route.stops.filter(stop => stop && nodes[stop.node]) : [];
                        for (let i = 0; i < route.path.length - 1; i++) {
                            const a = route.path[i];
                            const b = route.path[i + 1];
                            const key = [a, b].sort().join('::');
                            if (!linkMap.has(key)) {
                                const id = `L${String(nextIdCounter++).padStart(3, '0')}`;
                                const newLink = { id, a, b };
                                this.schema.links.push(newLink);
                                linkMap.set(key, newLink);
                            }
                        }
                    }
                    if (!this.schema.meta) this.schema.meta = {};
                    this.schema.meta.version = 1;
                }

                generateLinkIdSeed() {
                    let max = 0;
                    for (const link of this.schema.links) {
                        const match = /^L(\d+)/.exec(link.id || '');
                        if (match) {
                            max = Math.max(max, parseInt(match[1], 10));
                        }
                    }
                    return max + 1;
                }

                async importStops() {
                    this.showToast('Importing stops…');
                    try {
                        const res = await fetch('/api/import-stops', { method: 'POST' });
                        if (!res.ok) {
                            const body = await res.json().catch(() => ({}));
                            throw new Error(body.error || `Import failed (${res.status})`);
                        }
                        const data = await res.json();
                        if (data && data.nodes) {
                            this.schema = sanitizeSchema(data);
                            this.lastUpdatedAt = this.schema.meta?.updatedAt || null;
                            this.dirty = false;
                            this.editorView.render();
                            this.renderView.render();
                            this.updateStatus();
                        }
                        this.showToast('Stops imported');
                    } catch (err) {
                        console.error(err);
                        this.showToast(`Import failed: ${err.message}`, true);
                    }
                }
            }

            const app = new SchematicApp();
            window.utsSchematicApp = app;
            document.addEventListener('DOMContentLoaded', () => {
                app.init();
            });
        })();
    </script>
</body>
</html>
