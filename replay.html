<!DOCTYPE html>
<html>
<head>
  <title>Replay Map - Headway Guard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <style>
    @font-face {
      font-family: 'FGDC';
      src: url('FGDC.ttf') format('truetype');
    }
    html, body { height: 100%; margin: 0; font-family: 'FGDC', sans-serif; }
    #map { height: calc(100% - 90px); width: 100%; }
    #controls { position: fixed; bottom: 0; left: 0; width: 100%; height: 90px; background: rgba(255,255,255,0.9); display: flex; flex-wrap: wrap; align-items: center; padding: 5px; box-sizing: border-box; }
    #controls > * { margin: 2px; }
    #controls input, #controls button {
      padding: 6px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid #ccc;
    }
    #controls button.selected {
      background-color: #ccc;
    }
    #timeline { flex: 1; margin: 0 10px; }
    .play-icons { letter-spacing: -4px; }
    #routeSelector {
      width: 300px;
      position: fixed;
      top: 10px;
      right: 10px;
      bottom: 110px;
      z-index: 1100;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 5px;
      overflow-y: auto;
      transition: transform 0.3s ease;
      font-size: 21px;
    }
    #routeSelector.hidden { transform: translateX(320px); }
    #routeSelector h3 { margin-top: 0; }
    #routeSelector button {
      margin: 5px 2px;
      padding: 5px 10px;
      font-size: 24px;
      font-family: 'FGDC', sans-serif;
      background-color: #E57200;
      color: black;
      border: none;
      border-radius: 20px;
      cursor: pointer;
    }
    #routeSelector label { display: block; margin-bottom: 5px; cursor: pointer; }
    #routeSelector .color-box {
      display: inline-block;
      width: 12px;
      height: 12px;
      margin-right: 5px;
      vertical-align: middle;
    }
    #routeSelectorTab {
      position: fixed;
      top: 50%;
      right: 0;
      width: 30px;
      height: 60px;
      background: #ccc;
      border-top-left-radius: 10px;
      border-bottom-left-radius: 10px;
      cursor: pointer;
      display: block;
      transform: translateY(-50%);
      z-index: 1150;
      text-align: center;
      line-height: 60px;
      font-size: 20px;
      user-select: none;
    }
    @media (max-width: 600px) {
      #routeSelector { width: 80%; right: 10%; font-size: 18px; bottom: 110px; }
      #routeSelector.hidden { transform: translateX(calc(100% + 20px)); }
      #routeSelector button { font-size: 20px; }
      #routeSelector label { font-size: 18px; }
      #routeSelectorTab { width: 40px; height: 80px; font-size: 28px; }
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="routeSelector"></div>
  <div id="routeSelectorTab" onclick="togglePanel()">&#9664;</div>
  <div id="controls">
    <input id="datePicker" placeholder="Date">
    <input id="startTime" placeholder="Start time">
    <input id="endTime" placeholder="End time">
    <button id="loadRangeBtn">Load</button>
    <button id="playBtn">&#9654;</button>
    <button id="pauseBtn">&#10074;&#10074;</button>
    <button id="ff2Btn"><span class="play-icons">&#9654;&#9654;</span></button>
    <button id="ff4Btn"><span class="play-icons">&#9654;&#9654;&#9654;&#9654;</span></button>
    <input type="range" id="timeline" min="0" value="0">
    <span id="timeLabel"></span>
  </div>
  <script>
    let map = L.map('map', { zoomControl: false }).setView([38.03799212281404, -78.50981502838886], 15);
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    flatpickr("#datePicker", {
      dateFormat: "Y-m-d",
      defaultDate: new Date().toISOString().slice(0,10)
    });
    flatpickr("#startTime", {
      enableTime: true,
      noCalendar: true,
      dateFormat: "H:i",
      time_24hr: true,
      defaultDate: "00:00"
    });
    flatpickr("#endTime", {
      enableTime: true,
      noCalendar: true,
      dateFormat: "H:i",
      time_24hr: true,
      defaultDate: "23:59"
    });

    let logData = [];
    let playbackData = [];
    let markers = {};
    let nameMarkers = {};
    let speedMarkers = {};
    let blockMarkers = {};
    let timer = null;       // handle for scheduled frame advance
    let playbackSpeed = 1;  // 1x, 2x, 4x
    let routeColors = {};
    let allRoutes = {};
    let routeSelections = {};
    let activeRoutes = new Set();
    let showSpeed = false;
    let showBlockNumbers = true;
    let currentFrameIndex = 0;
    const outOfServiceRouteColor = '#000000';
    let isPlaying = false;
    const playBtn = document.getElementById('playBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const ff2Btn = document.getElementById('ff2Btn');
    const ff4Btn = document.getElementById('ff4Btn');

    function updateSpeedButtons() {
      playBtn.classList.remove('selected');
      ff2Btn.classList.remove('selected');
      ff4Btn.classList.remove('selected');
      if (playbackSpeed === 1) {
        playBtn.classList.add('selected');
      } else if (playbackSpeed === 2) {
        ff2Btn.classList.add('selected');
      } else if (playbackSpeed === 4) {
        ff4Btn.classList.add('selected');
      }
    }

    function fetchRouteColors() {
      const routesApiUrl = "https://uva.transloc.com/Services/JSONPRelay.svc/GetRoutes?APIKey=8882812681";
      return fetch(routesApiUrl)
        .then(r => r.json())
        .then(data => {
          if (Array.isArray(data)) {
            data.forEach(route => {
              routeColors[route.RouteID] = route.MapLineColor;
              allRoutes[route.RouteID] = route;
            });
          }
        });
    }

    function fetchRouteInfo() {
      const routePathsApiUrl = "https://uva.transloc.com/Services/JSONPRelay.svc/GetRoutesForMapWithScheduleWithEncodedLine?APIKey=8882812681";
      return fetch(routePathsApiUrl)
        .then(r => r.json())
        .then(data => {
          if (Array.isArray(data)) {
            data.forEach(route => {
              if (allRoutes[route.RouteID]) {
                allRoutes[route.RouteID].InfoText = route.InfoText;
              }
            });
          }
        })
        .catch(err => console.error('Error fetching route info', err));
    }

    function getContrastColor(hexColor) {
      hexColor = hexColor.replace('#', '');
      const r = parseInt(hexColor.substring(0,2), 16);
      const g = parseInt(hexColor.substring(2,4), 16);
      const b = parseInt(hexColor.substring(4,6), 16);
      const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
      return luminance > 0.5 ? '#000000' : '#FFFFFF';
    }

    function getRouteColor(routeID) {
      if (routeID === 0) return outOfServiceRouteColor;
      return routeColors[routeID] || '#000000';
    }

    function isRouteSelected(routeID) {
      if (routeSelections.hasOwnProperty(routeID)) return routeSelections[routeID];
      return activeRoutes.has(Number(routeID));
    }

    function refreshReplay() {
      showFrame(currentFrameIndex);
    }

    function toggleShowSpeed() {
      showSpeed = !showSpeed;
      const btn = document.getElementById('toggleSpeedButton');
      if (btn) btn.innerHTML = showSpeed ? 'Hide Speed' : 'Show Speed';
      refreshReplay();
    }

    function toggleShowBlockNumbers() {
      showBlockNumbers = !showBlockNumbers;
      const btn = document.getElementById('toggleBlockButton');
      if (btn) btn.innerHTML = showBlockNumbers ? 'Hide Block Numbers' : 'Show Block Numbers';
      refreshReplay();
    }

    function updateRouteSelector(activeRoutes) {
      const container = document.getElementById('routeSelector');
      if (!container) return;
      let html = "";
      html += "<div style='margin-bottom:10px;'><button id='toggleSpeedButton' onclick='toggleShowSpeed()'>" + (showSpeed ? "Hide Speed" : "Show Speed") + "</button><button id='toggleBlockButton' onclick='toggleShowBlockNumbers()'>" + (showBlockNumbers ? "Hide Block Numbers" : "Show Block Numbers") + "</button></div>";
      html += "<h3>Select Routes</h3>" +
        "<button onclick='selectAllRoutes()'>Select All</button>" +
        "<button onclick='deselectAllRoutes()'>Deselect All</button><br/><br/>";

      let outChecked = routeSelections.hasOwnProperty(0) ? routeSelections[0] : activeRoutes.has(0);
      html += `<label>
            <input type="checkbox" id="route_0" value="0" ${outChecked ? "checked" : ""}>
            <span class="color-box" style="background:${outOfServiceRouteColor};"></span> Out of Service
          </label>`;

      let routeIDs = Object.keys(allRoutes).map(Number).filter(id => id !== 0);
      routeIDs.sort((a,b) => {
        let descA = allRoutes[a].Description.toUpperCase();
        let descB = allRoutes[b].Description.toUpperCase();
        if (descA < descB) return -1;
        if (descA > descB) return 1;
        return 0;
      });

      routeIDs.forEach(routeID => {
        let route = allRoutes[routeID];
        let checked = routeSelections.hasOwnProperty(routeID) ? routeSelections[routeID] : activeRoutes.has(routeID);
        let displayName = route.Description;
        if (route.InfoText && route.InfoText.trim() !== "") {
          displayName += ` &ndash; ${route.InfoText.trim()}`;
        }
        html += `<label>
            <input type="checkbox" id="route_${routeID}" value="${routeID}" ${checked ? "checked" : ""}>
            <span class="color-box" style="background:${route.MapLineColor};"></span> ${displayName}
          </label>`;
      });

      container.innerHTML = html;

      let outChk = document.getElementById('route_0');
      if (outChk) {
        outChk.addEventListener('change', function() {
          routeSelections[0] = outChk.checked;
          refreshReplay();
        });
      }
      routeIDs.forEach(routeID => {
        let chk = document.getElementById('route_' + routeID);
        if (chk) {
          chk.addEventListener('change', function() {
            routeSelections[routeID] = chk.checked;
            refreshReplay();
          });
        }
      });
    }

    function selectAllRoutes() {
      let outChk = document.getElementById('route_0');
      if (outChk) outChk.checked = true;
      for (let routeID in allRoutes) {
        let chk = document.getElementById('route_' + routeID);
        if (chk) chk.checked = true;
        routeSelections[routeID] = true;
      }
      routeSelections[0] = true;
      refreshReplay();
    }

    function deselectAllRoutes() {
      let outChk = document.getElementById('route_0');
      if (outChk) outChk.checked = false;
      for (let routeID in allRoutes) {
        let chk = document.getElementById('route_' + routeID);
        if (chk) chk.checked = false;
        routeSelections[routeID] = false;
      }
      routeSelections[0] = false;
      refreshReplay();
    }

    function togglePanel() {
      let panel = document.getElementById('routeSelector');
      let tab = document.getElementById('routeSelectorTab');
      if (panel.classList.contains('hidden')) {
        panel.classList.remove('hidden');
        tab.innerHTML = '&#9664;';
      } else {
        panel.classList.add('hidden');
        tab.innerHTML = '&#9654;';
      }
    }

    function loadLog(retryDelay = 2000) {
      // Use absolute path so this works regardless of the current URL
      fetch('/vehicle_log.jsonl', { cache: 'no-store' })
        .then(r => (r.ok ? r.text() : ''))
        .then(text => {
          if (!text.trim()) {
            setTimeout(() => loadLog(retryDelay), retryDelay);
            return;
          }
          logData = text.trim().split('\n').map(line => JSON.parse(line));
          const hasData = logData.some(e => e.ts && (e.vehicles || []).length);
          if (!hasData) {
            setTimeout(() => loadLog(retryDelay), retryDelay);
            return;
          }
          playbackData = logData;
          const timeline = document.getElementById('timeline');
          timeline.max = playbackData.length - 1;
          const datePicker = document.getElementById('datePicker')._flatpickr;
          const first = playbackData[0] && new Date(playbackData[0].ts);
          if (first) { datePicker.setDate(first, true); }
          const last = playbackData[playbackData.length - 1] && new Date(playbackData[playbackData.length - 1].ts);
          const endPicker = document.getElementById('endTime')._flatpickr;
          if (last && endPicker) { endPicker.setDate(last, true); }
          showFrame(0);
        })
        .catch(err => {
          console.error('Failed to load vehicle log', err);
          setTimeout(() => loadLog(retryDelay), retryDelay);
        });
    }

    function clearMarkers() {
      for (let id in markers) { map.removeLayer(markers[id]); }
      markers = {};
      for (let id in nameMarkers) { map.removeLayer(nameMarkers[id]); }
      nameMarkers = {};
      for (let id in speedMarkers) { map.removeLayer(speedMarkers[id]); }
      speedMarkers = {};
      for (let id in blockMarkers) { map.removeLayer(blockMarkers[id]); }
      blockMarkers = {};
    }

    function showFrame(i) {
      if (!playbackData[i]) return;
      currentFrameIndex = i;
      const entry = playbackData[i];
      const timeline = document.getElementById('timeline');
      const date = new Date(entry.ts);
      const formatted = date.toLocaleString();
      timeline.value = i;
      timeline.title = formatted; // show date/time when hovering the slider
      document.getElementById('timeLabel').textContent = formatted;

      const activeRoutesSet = new Set();
      entry.vehicles.forEach(v => activeRoutesSet.add(v.RouteID || 0));
      activeRoutes = activeRoutesSet;
      updateRouteSelector(activeRoutesSet);

      clearMarkers();
      const blocks = entry.blocks || {};
      entry.vehicles.forEach(vehicle => {
        const routeID = vehicle.RouteID || 0;
        if (!isRouteSelected(routeID)) return;
        const pos = [vehicle.Latitude, vehicle.Longitude];
        const isMoving = vehicle.GroundSpeed > 0;
        const heading = vehicle.Heading;
        const routeColor = getRouteColor(routeID);
        const svgIcon = `
          <svg width="40" height="80" viewBox="0 0 40 80" xmlns="http://www.w3.org/2000/svg">
            <g>
              <circle cx="20" cy="20" r="15" fill="${routeColor}" stroke="white" stroke-width="3" />
              ${isMoving ? `
                <line x1="20" y1="10" x2="20" y2="22" stroke="white" stroke-width="4" stroke-linecap="round" style="transform: rotate(${heading + 180}deg); transform-origin: 20px 20px" />
                <polygon points="15,22 25,22 20,30" fill="white" style="transform: rotate(${heading + 180}deg); transform-origin: 20px 20px" />
              ` : `
                <rect x="14" y="14" width="12" height="12" fill="white" />
              `}
            </g>
          </svg>`;
        const busIcon = L.divIcon({ html: svgIcon, className: '', iconSize: [40,40], iconAnchor: [20,20] });
        const marker = L.marker(pos, { icon: busIcon }).addTo(map);
        markers[vehicle.VehicleID] = marker;

        if (showSpeed) {
          const speedBubble = `
            <svg width="60" height="20" viewBox="0 0 60 20" xmlns="http://www.w3.org/2000/svg">
              <g>
                <rect x="0" y="0" width="60" height="20" rx="10" ry="10" fill="${routeColor}" stroke="white" stroke-width="3" />
                <text x="30" y="15" font-size="12" font-weight="bold" text-anchor="middle" fill="${getContrastColor(routeColor)}" font-family="FGDC">${Math.round(vehicle.GroundSpeed)} MPH</text>
              </g>
            </svg>`;
          const speedIcon = L.divIcon({ html: speedBubble, className: '', iconSize: [60,20], iconAnchor: [30,-15] });
          speedMarkers[vehicle.VehicleID] = L.marker(pos, { icon: speedIcon, interactive: false }).addTo(map);
        }

        if (showBlockNumbers) {
          const blockName = blocks[vehicle.VehicleID];
          if (blockName && blockName.includes('[')) {
            const ctx = document.createElement('canvas').getContext('2d');
            ctx.font = 'bold 14px FGDC';
            const textWidth = ctx.measureText(blockName).width;
            const blockWidth = Math.max(40, textWidth + 20);
            const blockBubble = `
              <svg width="${blockWidth}" height="30" viewBox="0 0 ${blockWidth} 30" xmlns="http://www.w3.org/2000/svg">
                <g>
                  <rect x="0" y="5" width="${blockWidth}" height="20" rx="10" ry="10" fill="${routeColor}" stroke="white" stroke-width="3" />
                  <text x="${blockWidth/2}" y="20" font-size="14" font-weight="bold" text-anchor="middle" fill="${getContrastColor(routeColor)}" font-family="FGDC">${blockName}</text>
                </g>
              </svg>`;
            const blockIcon = L.divIcon({ html: blockBubble, className: '', iconSize: [blockWidth,30], iconAnchor: [blockWidth/2,-13] });
            blockMarkers[vehicle.VehicleID] = L.marker(pos, { icon: blockIcon, interactive: false }).addTo(map);
          }
        }

        const busName = vehicle.Name ? vehicle.Name.slice(0, -2) : '';
        if (busName) {
          const bubbleWidth = Math.max(40, busName.length * 10);
          const nameBubble = `
            <svg width="${bubbleWidth}" height="30" viewBox="0 0 ${bubbleWidth} 30" xmlns="http://www.w3.org/2000/svg">
              <g>
                <rect x="0" y="5" width="${bubbleWidth}" height="20" rx="10" ry="10" fill="${routeColor}" stroke="white" stroke-width="3" />
                <text x="${bubbleWidth / 2}" y="20" font-size="14" font-weight="bold" text-anchor="middle" fill="${getContrastColor(routeColor)}" font-family="FGDC">${busName}</text>
              </g>
            </svg>`;
          const nameIcon = L.divIcon({ html: nameBubble, className: '', iconSize: [bubbleWidth,30], iconAnchor: [bubbleWidth/2,40] });
          const nameMarker = L.marker(pos, { icon: nameIcon, interactive: false }).addTo(map);
          nameMarkers[vehicle.VehicleID] = nameMarker;
        }
      });
    }

    function scheduleNext() {
      const timeline = document.getElementById('timeline');
      const current = parseInt(timeline.value);
      const next = current + 1;
      if (next >= playbackData.length) { pause(); return; }
      const delta = new Date(playbackData[next].ts) - new Date(playbackData[current].ts);
      timer = setTimeout(() => {
        showFrame(next);
        scheduleNext();
      }, delta / playbackSpeed);
    }

    function play() {
      pause();
      isPlaying = true;
      updateSpeedButtons();
      scheduleNext();
    }

    function pause() {
      if (timer) clearTimeout(timer);
      timer = null;
      if (isPlaying) {
        isPlaying = false;
      }
      updateSpeedButtons();
    }

    function applyRange() {
      if (!logData.length) return;
      const dateStr = document.getElementById('datePicker').value;
      const startStr = document.getElementById('startTime').value || '00:00';
      const endStr = document.getElementById('endTime').value || '23:59';
      const start = new Date(`${dateStr}T${startStr}:00`);
      const end = new Date(`${dateStr}T${endStr}:00`);
      playbackData = logData.filter(entry => {
        const ts = new Date(entry.ts);
        return ts >= start && ts <= end;
      });
      const timeline = document.getElementById('timeline');
      timeline.max = playbackData.length ? playbackData.length - 1 : 0;
      showFrame(0);
    }

    playBtn.onclick = () => { playbackSpeed = 1; play(); };
    pauseBtn.onclick = pause;
    ff2Btn.onclick = () => { playbackSpeed = 2; play(); };
    ff4Btn.onclick = () => { playbackSpeed = 4; play(); };
    document.getElementById('timeline').addEventListener('input', e => { pause(); showFrame(parseInt(e.target.value)); });
    document.getElementById('loadRangeBtn').onclick = () => { pause(); applyRange(); };

    updateSpeedButtons();
    fetchRouteColors().then(fetchRouteInfo).then(loadLog);
  </script>
</body>
</html>
